QTASM rev 1.18x
   0                     ;; /**************************************************************************
   1                     ;;  *                                                                        *
   2                     ;;  *                               "Stierlitz"                              *
   3                     ;;  *                     Bus Munger as USB Mass Storage                     *
   4                     ;;  *                                                                        *
   5                     ;;  *************************************************************************/
   6                     
   7                     ;;  /*************************************************************************
   8                     ;;  *                (c) Copyright 2012 Stanislav Datskovskiy                *
   9                     ;;  *                         http://www.loper-os.org                        *
  10                     ;;  **************************************************************************
  11                     ;;  *                                                                        *
  12                     ;;  *  This program is free software: you can redistribute it and/or modify  *
  13                     ;;  *  it under the terms of the GNU General Public License as published by  *
  14                     ;;  *  the Free Software Foundation, either version 3 of the License, or     *
  15                     ;;  *  (at your option) any later version.                                   *
  16                     ;;  *                                                                        *
  17                     ;;  *  This program is distributed in the hope that it will be useful,       *
  18                     ;;  *  but WITHOUT ANY WARRANTY; without even the implied warranty of        *
  19                     ;;  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
  20                     ;;  *  GNU General Public License for more details.                          *
  21                     ;;  *                                                                        *
  22                     ;;  *  You should have received a copy of the GNU General Public License     *
  23                     ;;  *  along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  24                     ;;  *                                                                        *
  25                     ;;  *************************************************************************/
  26                     
  27                     ;*****************************************************************************
  28                     include knobs.asm

   0                      ;; /*************************************************************************
   1                      ;; *                     This file is part of Stierlitz:                    *
   2                      ;; *               https://github.com/asciilifeform/Stierlitz               *
   3                      ;; *************************************************************************/
   4                     
   5                      ;; /*************************************************************************
   6                      ;; *                (c) Copyright 2012 Stanislav Datskovskiy                *
   7                      ;; *                         http://www.loper-os.org                        *
   8                      ;; **************************************************************************
   9                      ;; *                                                                        *
  10                      ;; *  This program is free software: you can redistribute it and/or modify  *
  11                      ;; *  it under the terms of the GNU General Public License as published by  *
  12                      ;; *  the Free Software Foundation, either version 3 of the License, or     *
  13                      ;; *  (at your option) any later version.                                   *
  14                      ;; *                                                                        *
  15                      ;; *  This program is distributed in the hope that it will be useful,       *
  16                      ;; *  but WITHOUT ANY WARRANTY; without even the implied warranty of        *
  17                      ;; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
  18                      ;; *  GNU General Public License for more details.                          *
  19                      ;; *                                                                        *
  20                      ;; *  You should have received a copy of the GNU General Public License     *
  21                      ;; *  along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  22                      ;; *                                                                        *
  23                      ;; *************************************************************************/
  24                     
  25                     ;*****************************************************************************
  26                     ;; Knobs
  27                     ;*****************************************************************************
  28                     
  29                     ;*****************************************************************************
  30                     ;; The Payload (Virtual File)
  31                     ;*****************************************************************************
  32                     ;; QTASM is Retarded...:
  33                     ;*****************************************************************************
  34                     
  35                     ;;;;;;;;;;;;; 1024 meg
  36                     ;; FILE_SIZE_LW		equ	0x0000
  37                     ;; FILE_SIZE_UW		equ	0x4000
  38                     ;; FILE_SIZE_IN_BLKS_LW	equ	0x0000
  39                     ;; FILE_SIZE_IN_BLKS_UW	equ	0x0020
  40                     ;; FAKE_FILE_CLUSTERS	equ	32768
  41                     
  42                     ;;;;;;;;;;;;; 256 meg
  43                     ;; FILE_SIZE_LW		equ	0x0000
  44                     ;; FILE_SIZE_UW		equ	0x1000
  45                     ;; FILE_SIZE_IN_BLKS_LW	equ	0x0000
  46                     ;; FILE_SIZE_IN_BLKS_UW	equ	0x0008
  47                     ;; FAKE_FILE_CLUSTERS	equ	8192
  48                     
  49                     ;;;;;;;;;;;;; 1 meg
  50                     ;; FILE_SIZE_LW		equ	0x0000
  51                     ;; FILE_SIZE_UW		equ	0x0010
  52                     ;; FILE_SIZE_IN_BLKS_LW	equ	0x0800
  53                     ;; FILE_SIZE_IN_BLKS_UW	equ	0x0000
  54                     ;; FAKE_FILE_CLUSTERS	equ	32
  55                     
  56                     ;;;;;;;;;;;;; 128K
  57                     ;; FILE_SIZE_LW		equ	0x0000
  58                     ;; FILE_SIZE_UW		equ	0x0002
  59                     ;; FILE_SIZE_IN_BLKS_LW	equ	0x0100
  60                     ;; FILE_SIZE_IN_BLKS_UW	equ	0x0000
  61                     ;; FAKE_FILE_CLUSTERS	equ	4
  62                     
  63                     ;;;;;;;;;;;; BPI 8.9 meg (9232444)
  64           ffffe03c  FILE_SIZE_LW		equ	0xE03C
  65           0000008c  FILE_SIZE_UW		equ	0x008C
  66           00004671  FILE_SIZE_IN_BLKS_LW	equ	0x4671
  67           00000000  FILE_SIZE_IN_BLKS_UW	equ	0x0000
  68           0000011a  FAKE_FILE_CLUSTERS	equ	282
  69                     
  70                     ;*****************************************************************************
  71                     
  72                     
  73                     ;*****************************************************************************
  74                     ;; Other: no need to change these much
  75                     ;*****************************************************************************
  76           00000001  FW_REV      		equ 	0x1       ; Firmware revision
  77           000008ec  VENDOR_ID   		equ 	0x08EC    ; "M-Systems Flash Disk"
  78           00000020  PRODUCT_ID  		equ 	0x0020    ; "TravelDrive"
  79                     
  80           ffffffff  MAXBLOCK		equ	4194303 ; Index of last block (NOT block count!)
  81                     
  82                     ;; Because QTASM is braindead:
  83           00000000  MAXBLOCK_3		equ	0x00
  84           0000003f  MAXBLOCK_2		equ	0x3F
  85           000000ff  MAXBLOCK_1		equ	0xFF
  86           000000ff  MAXBLOCK_0		equ	0xFF
  87                     ;*****************************************************************************
  88                     
  89                     
  90                     ;*****************************************************************************
  91                     ;; Really shouldn't change this
  92                     ;*****************************************************************************
  93           00000110  USB_VER			equ     0x0110 ; 0x0110 for USB 1.1; 0x0200 for USB 2.0
  94                     ;; Endpoints:
  95           00000001  EP_IN			equ	0x01 ; 0x81 (ep1)
  96           00000002  EP_OUT			equ	0x02 ; 0x02 (ep2)
  97                     
  98           00000081  EP_IN_ADDR		equ	0x81
  99           00000002  EP_OUT_ADDR		equ	0x02
 100           00000040  USB_PACKET_SIZE		equ     0x0040 ; 64 bytes
 101           00000000  EP_IN_BINTERVAL		equ	0x00
 102           00000000  EP_OUT_BINTERVAL	equ	0x00
 103                     ;*****************************************************************************

  29                     ;*****************************************************************************
  30                     
  31           00000500  ORIGIN equ 0x500
  32                     
  33                     .xlist
  36                     .list
  37                     
  38                     ;*****************************************************************************
  39                     .code
  40 04f0                    org    (ORIGIN - 16)
  41 04f0 c3b6               dw     SCAN_SIGNATURE    ; dummy signature to align the structure
  42 04f2 0004               dw	   4                 ; length
  43 04f4 00                 db     0                 ; COPY opcode
  44 04f5 e000               dw     IROM_BEGIN        ; mov [0xe000],0 - dummy write for alignment
  45 04f7 0000               dw     0
  46 04f9 c3b6               dw     SCAN_SIGNATURE    ; copy data to ORIGIN
  47 04fb 15ec               dw     ((rom_end-rom_start)+2) ; length
  48 04fd 00                 db     0
  49 04fe 0500               dw     ORIGIN            ; Copy Destination
  50           00000000      reloc  ORIGIN            ; Relocate to this symbol
  51                     ;*****************************************************************************
  52 0500                rom_start:
  53 0500 cf9f 06a2          jmp	   init_code
  54                     ;*****************************************************************************
  55                     
  56                     
  57                     
  58                     include debug.asm ;; RS-232 Debugger

   0                      ;; /*************************************************************************
   1                      ;; *                     This file is part of Stierlitz:                    *
   2                      ;; *               https://github.com/asciilifeform/Stierlitz               *
   3                      ;; *************************************************************************/
   4                     
   5                      ;; /*************************************************************************
   6                      ;; *                (c) Copyright 2012 Stanislav Datskovskiy                *
   7                      ;; *                         http://www.loper-os.org                        *
   8                      ;; **************************************************************************
   9                      ;; *                                                                        *
  10                      ;; *  This program is free software: you can redistribute it and/or modify  *
  11                      ;; *  it under the terms of the GNU General Public License as published by  *
  12                      ;; *  the Free Software Foundation, either version 3 of the License, or     *
  13                      ;; *  (at your option) any later version.                                   *
  14                      ;; *                                                                        *
  15                      ;; *  This program is distributed in the hope that it will be useful,       *
  16                      ;; *  but WITHOUT ANY WARRANTY; without even the implied warranty of        *
  17                      ;; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
  18                      ;; *  GNU General Public License for more details.                          *
  19                      ;; *                                                                        *
  20                      ;; *  You should have received a copy of the GNU General Public License     *
  21                      ;; *  along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  22                      ;; *                                                                        *
  23                      ;; *************************************************************************/
  24                     
  25                     
  26                     ;*****************************************************************************
  27                     ;; RS-232 debugger
  28                     ;*****************************************************************************
  29 0504                dbg_enable:
  30 0504 0017               push   r0
  31 0506 07c0 000d          mov    r0, 13		; 9600 baud
  32 050a af75               int    KBHIT_INT
  33 050c 05c0               pop    r0
  34 050e cf97               ret
  35                     ;*****************************************************************************
  36 0510                dbg_putchar:
  37 0510 0097               push   r2
  38 0512 0017               push   r0
  39 0514 67c0 00ff          and    r0, 0xFF
  40 0518 0002               mov    r2, r0
  41 051a 07c0 0001          mov    r0, 1      ; write to the UART
  42 051e af42               int    UART_INT   ; call UART_INT
  43 0520 05c0               pop    r0
  44 0522 05c2               pop    r2
  45 0524 cf97               ret
  46                     ;*****************************************************************************
  47 0526                dbg_getchar:
  48 0526 9000               xor    r0, r0     ;R0 = read data from the keyboard
  49 0528 af42               int    UART_INT   ;call UART_INT
  50 052a cf97               ret    	      ;return character in R0
  51                     ;*****************************************************************************
  52 052c                dbg_dump_tx_buffer:
  53 052c af49               int    PUSHALL_INT
  54 052e af9f 05d4          call   print_newline
  55 0532 07c0 0054          mov    r0, 0x0054		; 'T'
  56 0536 af9f 0510          call   dbg_putchar
  57 053a 07c0 0058          mov    r0, 0x0058		; 'X'
  58 053e af9f 0510          call   dbg_putchar
  59 0542 af9f 05d4          call   print_newline
  60 0546 07c8 14ea          mov    r8, send_buffer	; address of buffer
  61 054a 07c9 0040          mov    r9, 64		; number of bytes to print
  62 054e af9f 0580          call   dbg_dump_buffer
  63 0552 af4a               int    POPALL_INT
  64 0554 cf97               ret
  65                     ;*****************************************************************************
  66 0556                dbg_dump_rx_buffer:
  67 0556 af49               int    PUSHALL_INT
  68 0558 af9f 05d4          call   print_newline
  69 055c 07c0 0052          mov    r0, 0x0052		; 'R'
  70 0560 af9f 0510          call   dbg_putchar
  71 0564 07c0 0058          mov    r0, 0x0058		; 'X'
  72 0568 af9f 0510          call   dbg_putchar
  73 056c af9f 05d4          call   print_newline
  74 0570 07c8 16ea          mov    r8, receive_buffer	; address of buffer
  75 0574 07c9 0040          mov    r9, 64		; number of bytes to print
  76 0578 af9f 0580          call   dbg_dump_buffer
  77 057c af4a               int    POPALL_INT
  78 057e cf97               ret
  79                     ;*****************************************************************************
  80 0580                dbg_dump_buffer:
  81 0580 90c3               xor    r3, r3
  82 0582                print_byte:
  83 0582 9041               xor    r1, r1
  84 0584 d803               addi   r3, 1
  85 0586 0601               mov    r1, b[r8] 		; get byte from buffer
  86 0588 af9f 05a8          call   print_hex_byte	; print byte as hex
  87 058c d808               addi   r8, 1
  88 058e 07c0 0020          mov    r0, 0x0020
  89 0592 af9f 0510          call   dbg_putchar 		; print space between byte values:
  90 0596 00c4               mov    r4, r3
  91 0598 67c4 000f          and    r4, 0x0F		; every 16 bytes
  92 059c c102               jnz    @f
  93 059e af9f 05d4          call   print_newline 	; print possible EOL
  94 05a2                @@:
  95 05a2 da09               dec    r9
  96 05a4 c16e               jnz    print_byte
  97 05a6 cf97               ret
  98                     ;*****************************************************************************
  99 05a8                print_hex_byte:			; in r1
 100 05a8 67c1 00ff          and    r1, 0xFF
 101 05ac 0040               mov    r0, r1
 102 05ae d0c0               shr    r0, 4
 103 05b0 af9f 05bc          call   print_hex_digit 	; print upper nibble:
 104 05b4 0040               mov    r0, r1
 105 05b6 af9f 05bc          call   print_hex_digit	; print lower nibble:
 106 05ba cf97               ret
 107 05bc                print_hex_digit:
 108 05bc 67c0 000f          and    r0, 0x000F
 109 05c0 57c0 0009          cmp    r0, 0x0009
 110 05c4 c902               jbe    @f
 111 05c6 17c0 0007          add    r0, 0x07
 112 05ca                @@:
 113 05ca 17c0 0030          add    r0, 0x30
 114 05ce af9f 0510          call   dbg_putchar
 115 05d2 cf97               ret
 116                     ;*****************************************************************************
 117 05d4                print_newline:
 118 05d4 0017               push   r0
 119 05d6 07c0 000d          mov    r0, 0x0D
 120 05da af9f 0510          call   dbg_putchar
 121 05de 07c0 000a          mov    r0, 0x0A
 122 05e2 af9f 0510          call   dbg_putchar
 123 05e6 05c0               pop    r0
 124 05e8 cf97               ret
 125                     ;*****************************************************************************
 126                     ;; Title char in Debug_Title; Word in {Debug_UW, Debug_LW}
 127 05ea 0000           Debug_Title	dw	0x0000
 128 05ec 0000           Debug_LW	dw	0x0000
 129 05ee 0000           Debug_UW	dw	0x0000
 130                     ;*****************************************************************************
 131 05f0                dbg_print_32bit:
 132 05f0 af49               int    PUSHALL_INT
 133 05f2 09c0 05ea          mov	   r0, w[Debug_Title]
 134 05f6 af9f 0510          call   dbg_putchar
 135 05fa 07c0 003d          mov	   r0, 0x003D		; =
 136 05fe af9f 0510          call   dbg_putchar
 137 0602 09c1 05ee          mov    r1, w[Debug_UW]
 138 0606 d1c1               shr    r1, 8
 139 0608 67c1 00ff          and    r1, 0xFF
 140 060c af9f 05a8          call   print_hex_byte
 141 0610 09c1 05ee          mov    r1, w[Debug_UW]
 142 0614 67c1 00ff          and    r1, 0xFF
 143 0618 af9f 05a8          call   print_hex_byte
 144 061c 09c1 05ec          mov    r1, w[Debug_LW]
 145 0620 d1c1               shr    r1, 8
 146 0622 67c1 00ff          and    r1, 0xFF
 147 0626 af9f 05a8          call   print_hex_byte
 148 062a 09c1 05ec          mov    r1, w[Debug_LW]
 149 062e 67c1 00ff          and    r1, 0xFF
 150 0632 af9f 05a8          call   print_hex_byte
 151 0636 af4a               int    POPALL_INT
 152 0638 cf97               ret
 153                     ;*****************************************************************************
 154 063a                dbg_printspace:
 155 063a 07c0 0020          mov    r0, 0x0020
 156 063e af9f 0510          call   dbg_putchar 		; print space between byte values:
 157 0642 cf97               ret
 158                     ;*****************************************************************************
 159                     ;; Print current block index:
 160                     ;*****************************************************************************
 161 0644                dbg_print_read_block_index:
 162 0644 af49               int    PUSHALL_INT
 163 0646 07c0 0052          mov	   r0, 0x0052		; R
 164 064a cf03               jmp    @f
 165 064c                dbg_print_write_block_index:
 166 064c af49               int    PUSHALL_INT
 167 064e 07c0 0057          mov	   r0, 0x0057		; W
 168 0652                @@:
 169 0652 af9f 0510          call   dbg_putchar
 170 0656 07c0 0042          mov	   r0, 0x0042		; B
 171 065a af9f 0510          call   dbg_putchar   
 172 065e 07c0 003d          mov	   r0, 0x003D		; =
 173 0662 af9f 0510          call   dbg_putchar
 174                         ;; print actual LBA index:
 175 0666 09c1 1128          mov    r1, w[actual_lba_uw]
 176 066a d1c1               shr    r1, 8
 177 066c 67c1 00ff          and    r1, 0xFF
 178 0670 af9f 05a8          call   print_hex_byte
 179 0674 09c1 1128          mov    r1, w[actual_lba_uw]
 180 0678 67c1 00ff          and    r1, 0xFF
 181 067c af9f 05a8          call   print_hex_byte
 182 0680 09c1 1126          mov    r1, w[actual_lba_lw]
 183 0684 d1c1               shr    r1, 8
 184 0686 67c1 00ff          and    r1, 0xFF
 185 068a af9f 05a8          call   print_hex_byte
 186 068e 09c1 1126          mov    r1, w[actual_lba_lw]
 187 0692 67c1 00ff          and    r1, 0xFF
 188 0696 af9f 05a8          call   print_hex_byte
 189 069a af9f 05d4          call   print_newline
 190 069e af4a               int    POPALL_INT
 191 06a0 cf97               ret
 192                     ;*****************************************************************************

  59                     
  60                     
  61                     ;; TODO: enable watchdog timer?
  62                     
  63                     ;*****************************************************************************
  64                     ;*****************************************************************************
  65                     
  66                     ;*****************************************************************************
  67                     ;; Set up BIOS hooks.
  68                     ;*****************************************************************************
  69 06a2                init_code:
  70 06a2 af9f 0504          call   dbg_enable ; Enable RS-232 Debug Port.
  71                     
  72 06a6 af9f 0726          call   insert_vectors ; Overwrite stock ISRs
  73                     
  74                         ;; HPI
  75 06aa 07e7 0500 c01c     mov    w[GPIO_CNTRL], GIO_IntCtl_Mode_HPIbm ; Enable HPI pins
  76 06b0 87e7 0020 c00e     or     w[INT_EN_REG], bmINT_EN_MBX_OUT ; enable Mailbox OUT IRQ
  77 06b6 87e7 0040 c00e     or     w[INT_EN_REG], bmINT_EN_MBX_IN ; enable Mailbox IN IRQ
  78                         
  79                         ;;DEBUG;;
  80 06bc af9f 05d4          call   print_newline
  81 06c0 07c0 002a          mov	   r0, 0x002A		; *
  82 06c4 af9f 0510          call   dbg_putchar
  83                         ;;DEBUG;;
  84                         
  85                         ;; init:
  86 06c8 9041               xor    r1, r1		; full speed
  87 06ca 07c2 0002          mov    r2, 2		; SIE2
  88 06ce af71               int    SUSB_INIT_INT
  89                     
  90                         ;; enable idler:
  91 06d0 07ef 0000 06fa     mov    b[main_enable], 0x00 ; we want to enable self when configured
  92 06d6 07e7 06de 008e     mov    [(IDLER_INT*2)], aux_idler
  93 06dc cf97               ret
  94                     ;*****************************************************************************
  95                     
  96                     
  97                     ;*****************************************************************************
  98                     ;; Main Loop
  99                     ;*****************************************************************************
 100 06de                aux_idler:
 101 06de d84f               addi   r15, 2
 102 06e0 57ef 0000 06fc     cmp    b[main_lock], 0x00
 103 06e6 c108               jne    @f
 104 06e8 07ef 0001 06fc     mov    b[main_lock], 1
 105 06ee af9f 06fe          call   main_idler
 106 06f2 07ef 0000 06fc     mov    b[main_lock], 0
 107 06f8                @@:
 108 06f8 af47               int    IDLER_INT
 109                     ;*****************************************************************************
 110                     
 111                     
 112                     ;*****************************************************************************
 113 06fa 0000           main_enable			dw 0x0000
 114 06fc 0000           main_lock			dw 0x0000
 115           0000      align 2
 116                     ;*****************************************************************************
 117 06fe                main_idler:
 118 06fe af9f 0b98          call   bios_idle
 119 0702 57ef 0000 06fa     cmp    b[main_enable], 0 	; global enable toggled by delta_config
 120 0708 c07a               je     main_idler		; if disabled, skip MSC routines
 121 070a af9f 0970          call   usb_host_to_dev_handler ; handle any input from host
 122 070e af9f 0ac2          call   usb_dev_to_host_handler ; handle any output to host
 123 0712 cf75               jmp    main_idler
 124                     ;*****************************************************************************
 125                     
 126                     
 127           0000      align 2
 128                     ;*****************************************************************************
 129                     include usbstd.asm

   0                      ;; /*************************************************************************
   1                      ;; *                     This file is part of Stierlitz:                    *
   2                      ;; *               https://github.com/asciilifeform/Stierlitz               *
   3                      ;; *************************************************************************/
   4                     
   5                      ;; /*************************************************************************
   6                      ;; *                (c) Copyright 2012 Stanislav Datskovskiy                *
   7                      ;; *                         http://www.loper-os.org                        *
   8                      ;; **************************************************************************
   9                      ;; *                                                                        *
  10                      ;; *  This program is free software: you can redistribute it and/or modify  *
  11                      ;; *  it under the terms of the GNU General Public License as published by  *
  12                      ;; *  the Free Software Foundation, either version 3 of the License, or     *
  13                      ;; *  (at your option) any later version.                                   *
  14                      ;; *                                                                        *
  15                      ;; *  This program is distributed in the hope that it will be useful,       *
  16                      ;; *  but WITHOUT ANY WARRANTY; without even the implied warranty of        *
  17                      ;; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
  18                      ;; *  GNU General Public License for more details.                          *
  19                      ;; *                                                                        *
  20                      ;; *  You should have received a copy of the GNU General Public License     *
  21                      ;; *  along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  22                      ;; *                                                                        *
  23                      ;; *************************************************************************/
  24                     
  25                     ;*****************************************************************************
  26                     ;;;;;; Intercepts
  27                     ;*****************************************************************************
  28                     
  29                     ;;  /*************************************************************************
  30                     ;;  *     "We are what we pretend to be, so we must be careful about what    *
  31                     ;;  *      we pretend to be." (K. Vonnegut, "Mother Night")                  *
  32                     ;;  *************************************************************************/
  33                     
  34                     ;*****************************************************************************
  35                     ;; Replace stock vectors
  36                     ;*****************************************************************************
  37                     ;; save bios handlers here:
  38 0714 dead           bios_standard_usb_reset_handler dw	0xDEAD
  39 0716 dead           bios_standard_request_handler:	dw	0xDEAD
  40 0718 dead           bios_class_request_handler: 	dw	0xDEAD
  41 071a dead           bios_configuration_change:  	dw	0xDEAD
  42 071c dead           bios_idle_chain:  		dw	0xDEAD
  43 071e dead           bios_ep1_in_isr:    		dw	0xDEAD
  44 0720 dead           bios_ep2_out_isr:   		dw	0xDEAD
  45 0722 dead           bios_hpi_tx_isr:    		dw	0xDEAD
  46 0724 dead           bios_hpi_rx_isr:    		dw	0xDEAD
  47                     ;*****************************************************************************
  48 0726                insert_vectors:
  49                         ; Update USB reset handler.
  50 0726 09e7 0038 0714     mov    [bios_standard_usb_reset_handler], [SIE2_SLAVE_RESET_VEC]
  51 072c 07e7 07b6 0038     mov    [SIE2_SLAVE_RESET_VEC], my_standard_usb_reset_handler
  52                         ; Update BIOS SIE2 descriptor pointers.
  53 0732 07e7 1486 00d4     mov    [SUSB2_DEV_DESC_VEC], dev_desc
  54 0738 07e7 1498 00d6     mov    [SUSB2_CONFIG_DESC_VEC], conf_desc
  55 073e 07e7 14b8 00d8     mov    [SUSB2_STRING_DESC_VEC], string_desc
  56                         ;; Back up BIOS handler locations
  57 0744 09e7 00c6 0716     mov    [bios_standard_request_handler], [(SUSB2_STANDARD_INT*2)]
  58 074a 09e7 00ce 0718     mov    [bios_class_request_handler], [(SUSB2_CLASS_INT*2)]
  59 0750 09e7 00de 071a     mov    [bios_configuration_change], [(SUSB2_DELTA_CONFIG_INT*2)]
  60                         ;; Overwrite BIOS handler locations with ours
  61 0756 07e7 0866 00c6     mov    [(SUSB2_STANDARD_INT*2)], my_standard_request_handler
  62 075c 07e7 0810 00ce     mov    [(SUSB2_CLASS_INT*2)], my_class_request_handler
  63 0762 07e7 086e 00de     mov    [(SUSB2_DELTA_CONFIG_INT*2)], my_configuration_change
  64                         ;; Overwrite EP ISRs
  65 0768 09e7 0052 071e     mov    w[bios_ep1_in_isr], w[SIE2_EP1_VEC]
  66 076e 09e7 0054 0720     mov    w[bios_ep2_out_isr], w[SIE2_EP2_VEC]
  67 0774 07e7 07e1 0052     mov    w[SIE2_EP1_VEC], my_ep1_in_vec
  68 077a 07e7 07f9 0054     mov    w[SIE2_EP2_VEC], my_ep2_out_vec
  69                         ;; HPI Mailbox ISRs
  70 0780 09e7 0016 0722     mov    w[bios_hpi_tx_isr], w[HPI_MBOX_TX_EMPTY_VEC]
  71 0786 07e7 079b 0016     mov    w[HPI_MBOX_TX_EMPTY_VEC], my_hpi_tx_empty_vec
  72 078c 09e7 0014 0724     mov    w[bios_hpi_rx_isr], w[HPI_MBOX_RX_FULL_VEC]
  73 0792 07e7 07a9 0014     mov    w[HPI_MBOX_RX_FULL_VEC], my_hpi_rx_full_vec
  74 0798 cf97               ret
  75                     ;*****************************************************************************
  76                     
  77                     
  78                     ;*****************************************************************************
  79                     ;; HPI mailbox was read by host
  80                     ;*****************************************************************************
  81 079a 00             hpi_was_read		db	0x00
  82                     ;*****************************************************************************
  83 079b                my_hpi_tx_empty_vec:
  84 079c afa7 0722          call   [bios_hpi_tx_isr]
  85 07a0 07ef 0001 079a     mov    b[hpi_was_read], 0x01
  86 07a6 cf97               ret
  87                     ;*****************************************************************************
  88                     
  89                     
  90                     ;*****************************************************************************
  91                     ;; HPI mailbox was written by host
  92                     ;*****************************************************************************
  93 07a8 00             hpi_was_written		db	0x00
  94                     ;*****************************************************************************
  95 07a9                my_hpi_rx_full_vec:
  96 07aa afa7 0724          call   [bios_hpi_rx_isr]
  97 07ae 07ef 0001 07a8     mov    b[hpi_was_written], 0x01
  98 07b4 cf97               ret
  99                     ;*****************************************************************************
 100                     
 101                     
 102                     ;*****************************************************************************
 103                     ;; USB reset handler.
 104                     ;*****************************************************************************
 105 07b6                my_standard_usb_reset_handler:
 106 07b6 77ef 0001 06fa     test   b[main_enable], 1
 107 07bc c002               jz     @f
 108 07be af9f 07c8          call   warm_boot
 109 07c2                @@:
 110 07c2 afa7 0714          call   [bios_standard_usb_reset_handler]
 111 07c6 cf97               ret
 112                     ;*****************************************************************************    
 113                     
 114                     
 115                     ;*****************************************************************************
 116                     ;; Warm reboot.
 117                     ;*****************************************************************************
 118 07c8                warm_boot:
 119                         ;; mov	   r0, 0x0021		; !
 120                         ;; call   dbg_putchar
 121 07c8 07ef 0000 06fa     mov    b[main_enable], 0x00
 122 07ce 07ef 0000 086c     mov    b[conf_count], 0x00
 123 07d4 07ef 0000 06fc     mov    b[main_lock], 0
 124                         ;; reset hack
 125 07da cf9f e000          jmpl   0xE000
 126 07de                wd_hang:
 127 07de cf7f               jmp    wd_hang
 128                         ; should never get here...
 129                     ;*****************************************************************************    
 130                     
 131                     
 132                     ;*****************************************************************************
 133 07e0 00             ep1_in_fired		db	0x00
 134                     ;*****************************************************************************
 135 07e1                my_ep1_in_vec:			; fires on packet SENDING
 136 07e2 afa7 071e          call   [bios_ep1_in_isr]
 137 07e6 09d7 c000          push   [CPU_FLAGS_REG]	; push flags register
 138 07ea af49               int    PUSHALL_INT
 139 07ec d82f 07e0          addi   b[ep1_in_fired], 1
 140 07f0 af4a               int    POPALL_INT
 141 07f2 05e7 c000          pop    [CPU_FLAGS_REG]	; push flags register
 142 07f6 cf97               ret
 143                     ;*****************************************************************************
 144                     
 145                     
 146                     ;*****************************************************************************
 147 07f8 00             ep2_out_fired		db	0x00
 148                     ;*****************************************************************************
 149 07f9                my_ep2_out_vec:			; fires on packet RECEIVING
 150 07fa afa7 0720          call   [bios_ep2_out_isr]
 151 07fe 09d7 c000          push   [CPU_FLAGS_REG]	; push flags register
 152 0802 af49               int    PUSHALL_INT
 153 0804 d82f 07f8          addi   b[ep2_out_fired], 1
 154 0808 af4a               int    POPALL_INT
 155 080a 05e7 c000          pop    [CPU_FLAGS_REG]	; push flags register
 156 080e cf97               ret
 157                     ;*****************************************************************************
 158                     
 159                     
 160                     ;*****************************************************************************
 161                     ;; Device request offsets
 162           00000000  bmRequest	equ	0
 163           00000001  bRequest	equ	1
 164           00000002  wValue		equ	2
 165           00000004  wIndex		equ	4
 166           00000006  wLength		equ	6
 167                     ;*****************************************************************************
 168                     
 169                     ;*****************************************************************************
 170                     ;; CLASS_INT vector
 171                     ;*****************************************************************************
 172 0810                my_class_request_handler: ;; Handle MSC class requests.
 173 0810 0e00 0001          mov	   r0, b[r8 + bRequest] ; save request value
 174 0814 57c0 00ff          cmp	   r0, MSC_REQUEST_RESET
 175 0818 c017               je	   class_req_eq_request_reset
 176 081a 57c0 00fe          cmp	   r0, MSC_REQUEST_GET_MAX_LUN
 177 081e c002               je	   class_req_eq_request_get_max_lun
 178 0820 af69               int	   SUSB2_FINISH_INT	; replace BIOS's handler: call STATUS phrase
 179 0822 cf97               ret
 180                         ;;; ----------------------
 181 0824                class_req_eq_request_get_max_lun:
 182                         ;; No LUNs on this device, so send back a zero:
 183 0824 07e7 0864 085e     mov	   [ctlsend_addr], ctlsend_buffer ; address of buffer
 184 082a 07e7 0000 0864     mov	   [ctlsend_buffer], 0x0000 ; EP0Buf[0] = 0
 185 0830 07e7 0001 0860     mov	   [ctlsend_len], 0x0001 ; send 1 byte
 186 0836 07e7 0000 0862     mov    [ctlsend_call], 0x0000 ; no callback
 187 083c 07c8 085c          mov    r8, ctlsend_link	; pointer to linker
 188 0840 07c1 0000          mov    r1, 0x0000 		; which endpoint to send to
 189 0844 af60               int    SUSB2_SEND_INT	; call interrupt
 190 0846 cf09               jmp	   end_class_request_handler
 191 0848                class_req_eq_request_reset:
 192                         ;; TODO: implement genuine reset of EVERYTHING...
 193 0848 07ef 0000 1460     mov    b[scsi_state], SCSI_state_CBW
 194 084e 07e7 0000 145c     mov    [SCSI_dw_sense_lw], 0x0000
 195 0854 07e7 0000 145e     mov    [SCSI_dw_sense_uw], 0x0000 ; dwSense = 0
 196                         ;; int	   SUSB2_FINISH_INT
 197                         ;; ----------------------------------
 198                         ;; Done with class request handler
 199 085a                end_class_request_handler:
 200 085a cf97               ret
 201                     ;*****************************************************************************
 202                     ;; CTL Send data structure
 203           0000      align 2
 204 085c 0000           ctlsend_link			dw 0x0000
 205 085e 0000           ctlsend_addr			dw 0x0000
 206 0860 0000           ctlsend_len			dw 0x0000
 207 0862 0000           ctlsend_call			dw 0x0000
 208 0864 0000           ctlsend_buffer			dw 0x0000
 209                     ;*****************************************************************************
 210                     
 211                     ;*****************************************************************************
 212                     ;; STANDARD_INT vector
 213                     ;*****************************************************************************
 214 0866                my_standard_request_handler:
 215 0866 cfa7 0716          jmp    [bios_standard_request_handler]
 216                     ;*****************************************************************************
 217                     
 218                     ;*****************************************************************************
 219                     ;; DELTA_CONFIG_INT vector
 220                     ;*****************************************************************************
 221 086a 0000           req_wvalue		dw 0x0000
 222 086c 0000           conf_count		dw 0x0000
 223                     ;*****************************************************************************
 224 086e                my_configuration_change:
 225 086e 09d7 c000          push   [CPU_FLAGS_REG]	; push flags register
 226 0872 af49               int    PUSHALL_INT
 227                     
 228 0874 d827 086c          addi   [conf_count], 1
 229                         
 230 0878 07c8 0308          mov    r8, SIE2_DEV_REQ
 231 087c 0c00 0002          mov	   r0, w[r8 + wValue]
 232 0880 0027 086a          mov    [req_wvalue], r0
 233 0884 afa7 071a          call   [bios_configuration_change] ; let BIOS configure endpoints...
 234 0888 09c0 086a          mov	   r0, [req_wvalue]
 235 088c 67c0 00ff          and    r0, 0xFF
 236 0890 57c0 0001          cmp    r0, 1 ; [bConfigurationValue]
 237 0894 c107               jne    @f ; it isn't time yet
 238                     
 239 0896 57ef 0004 086c     cmp    b[conf_count], 4
 240 089c c203               jb     @f
 241                         
 242 089e 07e7 0001 06fa     mov    [main_enable], 1 ; we want to enable self when configured
 243                     
 244                         ;; mov	   r0, 0x002B		; +
 245                         ;; call   dbg_putchar
 246                         
 247 08a4                @@:
 248 08a4 af4a               int    POPALL_INT
 249 08a6 05e7 c000          pop    [CPU_FLAGS_REG]	; push flags register
 250 08aa cf97               ret
 251                     ;*****************************************************************************

 130                     include usb-bulk.asm

   0                      ;; /*************************************************************************
   1                      ;; *                     This file is part of Stierlitz:                    *
   2                      ;; *               https://github.com/asciilifeform/Stierlitz               *
   3                      ;; *************************************************************************/
   4                     
   5                      ;; /*************************************************************************
   6                      ;; *                (c) Copyright 2012 Stanislav Datskovskiy                *
   7                      ;; *                         http://www.loper-os.org                        *
   8                      ;; **************************************************************************
   9                      ;; *                                                                        *
  10                      ;; *  This program is free software: you can redistribute it and/or modify  *
  11                      ;; *  it under the terms of the GNU General Public License as published by  *
  12                      ;; *  the Free Software Foundation, either version 3 of the License, or     *
  13                      ;; *  (at your option) any later version.                                   *
  14                      ;; *                                                                        *
  15                      ;; *  This program is distributed in the hope that it will be useful,       *
  16                      ;; *  but WITHOUT ANY WARRANTY; without even the implied warranty of        *
  17                      ;; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
  18                      ;; *  GNU General Public License for more details.                          *
  19                      ;; *                                                                        *
  20                      ;; *  You should have received a copy of the GNU General Public License     *
  21                      ;; *  along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  22                      ;; *                                                                        *
  23                      ;; *************************************************************************/
  24                     
  25                     
  26                     ;*****************************************************************************
  27                     ;*****************************************************************************
  28                     ; Bulk Endpoint I/O
  29                     ;*****************************************************************************
  30                     ;*****************************************************************************
  31                     
  32                     ;*****************************************************************************
  33                     ;; wait for event on EP1
  34                     ;*****************************************************************************
  35 08ac                wait_for_ep1_in_fired:
  36 08ac                @@:
  37 08ac af9f 0b98          call   bios_idle
  38 08b0 57ef 0001 07e0     cmp    b[ep1_in_fired], 0x01
  39 08b6 c17a               jne    @b
  40 08b8 07ef 0000 07e0     mov    b[ep1_in_fired], 0x00
  41 08be cf97               ret
  42                     ;*****************************************************************************
  43                     
  44                     
  45                     ;*****************************************************************************
  46                     ;; wait for event on EP2
  47                     ;*****************************************************************************
  48 08c0                wait_for_ep2_out_fired:
  49 08c0                @@:
  50 08c0 af9f 0b98          call   bios_idle
  51 08c4 57ef 0001 07f8     cmp    b[ep2_out_fired], 0x01
  52 08ca c17a               jne    @b
  53 08cc 07ef 0000 07f8     mov    b[ep2_out_fired], 0x00
  54 08d2 cf97               ret
  55                     ;*****************************************************************************
  56                     
  57                     
  58                     ;*****************************************************************************
  59                     ; Transmit usbsend_len bytes to endpoint send_endpoint from send_buffer.
  60                     ;*****************************************************************************
  61                     ;; tx_spin_lock			db 0x00
  62 08d4 0000           send_buffer_offset		dw 0x0000
  63           0000      align 2
  64                     ;*****************************************************************************
  65 08d6                usb_send_data:
  66 08d6 07e7 0000 090e     mov    w[usbsend_link], 0	; must be 0x0000 for send routine
  67 08dc 07e7 14ea 0910     mov    w[usbsend_addr], send_buffer
  68 08e2 09c0 08d4          mov    r0, w[send_buffer_offset]
  69 08e6 1027 0910          add    w[usbsend_addr], r0
  70 08ea 07e7 090c 0914     mov    w[usbsend_call], usb_send_done ;; set up callback
  71                         ;; mov    b[tx_spin_lock], 1
  72 08f0                usb_tx:
  73 08f0 07c8 090e          mov    r8, usbsend_link	; pointer to linker
  74 08f4 9041               xor    r1, r1
  75 08f6 07c1 0001          mov    r1, EP_IN ; which endpoint to send to
  76 08fa af60               int    SUSB2_SEND_INT	; call interrupt
  77 08fc af9f 08ac          call   wait_for_ep1_in_fired
  78 0900 09c0 0912          mov    r0, w[usbsend_len]
  79 0904 57c0 0000          cmp    r0, 0x0000
  80 0908 c173               jne    usb_tx
  81                         ;; mov    b[tx_spin_lock], 0
  82 090a cf97               ret
  83 090c                usb_send_done: ;; Callback
  84                         ;; mov    b[tx_spin_lock], 0
  85 090c cf97               ret
  86                     ;*****************************************************************************
  87                     ;; Send data structure
  88           0000      align 2
  89 090e 0000           usbsend_link			dw 0x0000
  90 0910 0000           usbsend_addr			dw 0x0000
  91 0912 0000           usbsend_len			dw 0x0000
  92 0914 0000           usbsend_call			dw 0x0000
  93                     ;*****************************************************************************
  94                     
  95                     
  96                     ;*****************************************************************************
  97                     ; Transmit [usbsend_len] bytes from send_buffer to host via EP_IN.
  98                     ; r0 will equal number of bytes which were NOT sent.
  99                     ;*****************************************************************************
 100 0916                bulk_send:
 101 0916 af9f 08d6          call   usb_send_data	; transmit answer
 102 091a 09c0 0912          mov    r0, w[usbsend_len]	; bytes failed (0 if all were sent.)
 103 091e cf97               ret
 104                     ;*****************************************************************************
 105                     
 106                     
 107                     ;*****************************************************************************
 108                     ; Receive usbrecv_length bytes of data from Bulk OUT endpoint into usbrecv_addr.
 109                     ; r0 will equal number of bytes NOT received.
 110                     ;*****************************************************************************
 111                     ;; rx_spin_lock			db 0x00
 112           0000      align 2
 113                     ;*****************************************************************************
 114 0920                usb_receive_data:
 115                         ;; mov    b[rx_spin_lock], 1
 116 0920 07e7 0000 094c     mov    w[usbrecv_link], 0
 117                         ;; mov    w[usbrecv_addr], receive_buffer
 118 0926 07e7 094a 0952     mov    w[usbrecv_call], receiver_done
 119 092c                usb_rx:
 120 092c 07c8 094c          mov    r8, usbrecv_link	; pointer to linker
 121 0930 07c1 0002          mov    r1, EP_OUT           ; from which endpoint to receive
 122 0934 67c1 000f          and    r1, 0x0F
 123 0938 af61               int    SUSB2_RECEIVE_INT	; call interrupt
 124 093a af9f 08c0          call   wait_for_ep2_out_fired
 125 093e 09c0 0950          mov    r0, w[usbrecv_len]
 126 0942 57c0 0000          cmp    r0, 0x0000
 127 0946 c172               jne    usb_rx
 128 0948 cf97               ret
 129 094a                receiver_done:
 130                         ;; mov    b[rx_spin_lock], 0
 131                         ;; mov    r0, w[usbrecv_len]	; bytes failed (0 if all were received.)
 132 094a cf97               ret
 133                     ;*****************************************************************************
 134                     ;; Receiver data structure
 135 094c 0000           usbrecv_link			dw 0x0000
 136 094e 0000           usbrecv_addr			dw 0x0000
 137 0950 0000           usbrecv_len			dw 0x0000
 138 0952 0000           usbrecv_call			dw 0x0000
 139           0000      align 2
 140                     ;*****************************************************************************
 141                     
 142                     
 143                     ;*****************************************************************************
 144                     ; zap send buffer
 145                     ;*****************************************************************************
 146 0954                zap_send_buffer:
 147 0954 07c1 0100          mov    r1, 0x0100
 148 0958 07c9 14ea          mov    r9, send_buffer
 149 095c                @@:
 150 095c 07e1 0000          mov    w[r9++], 0x0000
 151 0960 da01               dec    r1
 152 0962 c17c               jnz    @b
 153 0964 cf97               ret
 154                     ;*****************************************************************************
 155                     
 156                     
 157                     ;*****************************************************************************
 158                     ; zap send buffer from r0 to r0+r1 (words)
 159                     ;*****************************************************************************
 160                     ;; zap_send_buffer_from_to:
 161                     ;;     mov    r9, send_buffer
 162                     ;;     add    r9, r0
 163                     ;; @@:
 164                     ;;     mov    w[r9++], 0x0000
 165                     ;;     dec    r1
 166                     ;;     jnz    @b
 167                     ;;     ret
 168                     ;*****************************************************************************

 131                     include msc.asm

   0                      ;; /*************************************************************************
   1                      ;; *                     This file is part of Stierlitz:                    *
   2                      ;; *               https://github.com/asciilifeform/Stierlitz               *
   3                      ;; *************************************************************************/
   4                     
   5                      ;; /*************************************************************************
   6                      ;; *                (c) Copyright 2012 Stanislav Datskovskiy                *
   7                      ;; *                         http://www.loper-os.org                        *
   8                      ;; **************************************************************************
   9                      ;; *                                                                        *
  10                      ;; *  This program is free software: you can redistribute it and/or modify  *
  11                      ;; *  it under the terms of the GNU General Public License as published by  *
  12                      ;; *  the Free Software Foundation, either version 3 of the License, or     *
  13                      ;; *  (at your option) any later version.                                   *
  14                      ;; *                                                                        *
  15                      ;; *  This program is distributed in the hope that it will be useful,       *
  16                      ;; *  but WITHOUT ANY WARRANTY; without even the implied warranty of        *
  17                      ;; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
  18                      ;; *  GNU General Public License for more details.                          *
  19                      ;; *                                                                        *
  20                      ;; *  You should have received a copy of the GNU General Public License     *
  21                      ;; *  along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  22                      ;; *                                                                        *
  23                      ;; *************************************************************************/
  24                     
  25                     ;;  /*************************************************************************
  26                     ;;  *     "We are what we pretend to be, so we must be careful about what    *
  27                     ;;  *      we pretend to be." (K. Vonnegut, "Mother Night")                  *
  28                     ;;  *************************************************************************/
  29                      
  30                     ;*****************************************************************************
  31                     ; Variables to keep track of bulk I/O
  32                     ;*****************************************************************************
  33 0966                dwTransferSize:			; Total size of data transfer
  34 0966 0000           dwTransferSize_lw		dw 0x0000
  35 0968 0000           dwTransferSize_uw		dw 0x0000
  36                     
  37 096a                dwOffset:			; Offset in current data transfer
  38 096a 0000           dwOffset_lw			dw 0x0000
  39 096c 0000           dwOffset_uw			dw 0x0000
  40                     ;*****************************************************************************
  41                     
  42                     ;*****************************************************************************
  43                     ;; Process data received from bulk OUT endpoint.
  44                     ;; Received packet is in receive_buffer.
  45                     ;; Response (if not stall) will be built in send_buffer.
  46                     ;*****************************************************************************
  47 096e 00             host_in_flag			db 0x00
  48           0001      align 2
  49                     ;*****************************************************************************
  50 0970                usb_host_to_dev_handler:
  51                         ;; Determine what the response should be.
  52                         ;; This depends first on the SCSI state machine's state.
  53 0970 9249               xor    r9, r9
  54 0972 0bc9 1460          mov    r9, b[scsi_state]
  55 0976 57c9 0004          cmp    r9, 4
  56 097a cd05               jle    scsi_rx_state_0_to_4	; make sure state is 0..4
  57                         ;; recover from weird state - should never get here:
  58 097c 07ef 0000 1460     mov    b[scsi_state], SCSI_state_CBW
  59 0982 0bc9 1460          mov    r9, b[scsi_state]
  60 0986                scsi_rx_state_0_to_4:
  61 0986 d209               shl    r9, 1		; table offset times two (addresses are words.)
  62 0988 cfb1 098c          jmpl   [r9 + scsi_rx_state_jmp_table]
  63                         ;; SCSI State Machine Table
  64 098c                scsi_rx_state_jmp_table:
  65 098c 0996               dw     do_rx_state_CBW
  66 098e 0ab4               dw     do_rx_state_data_out
  67 0990 0aba               dw     do_rx_state_data_in
  68 0992 0aba               dw     do_rx_state_CSW
  69 0994 0abc               dw     do_rx_state_stalled
  70                         ;; ------------------------
  71 0996                do_rx_state_CBW:
  72 0996 07e7 16ea 094e     mov    w[usbrecv_addr], receive_buffer
  73 099c 07e7 001f 0950     mov    w[usbrecv_len], CBW_Size	; how many bytes to receive
  74 09a2 af9f 0920          call   usb_receive_data	; read CBW from host Bulk OUT endpoint
  75                         
  76                         ;; Check for valid CBW:
  77 09a6 57c0 0000          cmp    r0, 0		; how many bytes (of 31) failed to read?
  78 09aa c118               jne    invalid_cbw		; if any unread bytes, invalid.
  79 09ac 57e7 5355 16ea     cmp    w[MSC_CBW_Signature_lw], CBW_Signature_lw_expected
  80 09b2 c114               jne    invalid_cbw		; lower word of signature is invalid
  81 09b4 57e7 4342 16ec     cmp    w[MSC_CBW_Signature_uw], CBW_Signature_uw_expected
  82 09ba c110               jne    invalid_cbw		; upper word of signature is invalid
  83 09bc 0bc0 16f7          mov    r0, b[CBW_lun]
  84 09c0 67c0 000f          and    r0, 0x0F
  85 09c4 57c0 0000          cmp    r0, 0		; LUN == 0?
  86 09c8 c109               jne    invalid_cbw		; if not, then CBW is 'not meaningful.'
  87 09ca 57ef 0001 16f8     cmp    b[CBW_cb_length], 1	; if bCBWCBLength < 1:
  88 09d0 c205               jb     invalid_cbw		; then invalid
  89 09d2 57ef 0010 16f8     cmp    b[CBW_cb_length], 16	; if bCBWCBLength > 16:
  90 09d8 ca01               jg     invalid_cbw		; then invalid
  91 09da cf08               jmp    valid_cbw ;; CBW is Valid and Meaningful
  92 09dc                invalid_cbw: ;; Or not:
  93 09dc af9f 0b3c          call   stall_bulk_in_ep
  94 09e0 af9f 0b36          call   stall_bulk_out_ep
  95 09e4 07ef 0004 1460     mov    b[scsi_state], SCSI_state_stalled
  96 09ea cf97               ret
  97 09ec                valid_cbw:
  98                         ;; clear dwOffset and dwTransferSize:
  99 09ec 9000               xor    r0, r0
 100 09ee 0027 096a          mov    w[dwOffset_lw], r0
 101 09f2 0027 096c          mov    w[dwOffset_uw], r0
 102 09f6 0027 0966          mov    w[dwTransferSize_lw], r0
 103 09fa 0027 0968          mov    w[dwTransferSize_uw], r0
 104                         ;; fHostIN = ((CBW.bmCBWFlags & 0x80) != 0);
 105 09fe 07ef 0000 096e     mov    b[host_in_flag], 0x00
 106 0a04 0bc0 16f6          mov    r0, b[CBW_flags] ; Whether to stall IN endpoint:
 107 0a08 77c0 0080          test   r0, 0x80         ; Bit 7 = 0 for an OUT (host-to-device) transfer.
 108 0a0c c003               jz	   @f               ; Bit 7 = 1 for an IN (device-to-host) transfer.
 109 0a0e 07ef 0001 096e     mov    b[host_in_flag], 0x01
 110 0a14                @@:
 111 0a14 af9f 0cfa          call   SCSI_handle_cmd  ; pbData = SCSIHandleCmd(CBW.CBWCB, CBW.bCBWCBLength, &iLen, &fDevIn);
 112 0a18 57ef 0001 0cf0     cmp    b[cmd_must_stall_flag], 0x01
 113 0a1e c107               jne    @f
 114                         ;; if (pbData == NULL)
 115 0a20 af9f 0b0e          call   stall_transfer
 116 0a24 07c0 0001          mov    r0, CSW_CMD_FAILED
 117 0a28 af9f 0b4e          call   send_csw
 118 0a2c cf97               ret
 119 0a2e                @@:
 120                         ;; if device and host disagree on direction, send Phase Error status.
 121 0a2e 57e7 0000 0cec     cmp    w[response_length_uw], 0
 122 0a34 c104               jne    yes_response
 123 0a36 57e7 0000 0cea     cmp    w[response_length_lw], 0
 124 0a3c c00c               je     no_disagree
 125 0a3e                yes_response:
 126                         ;; if (response length > 0)
 127                         ;; xor    r0, r0
 128 0a3e 0bc0 096e          mov    r0, b[host_in_flag]
 129 0a42 9bc0 0cee          xor    r0, b[dev_in_flag]
 130 0a46 c007               jz     no_disagree
 131                         ;; && ((fHostIn && !fDevIn) || (!fHostIn && fDevIn)) then:
 132 0a48 af9f 0b0e          call   stall_transfer
 133 0a4c 07c0 0002          mov    r0, CSW_PHASE_ERROR
 134 0a50 af9f 0b4e          call   send_csw
 135 0a54 cf97               ret
 136 0a56                no_disagree:
 137                         ;; if D > H, send Phase Error status.
 138 0a56 09c2 0cea          mov    r2, w[response_length_lw] ; R3:R2 = dwTransferSize
 139 0a5a 09c3 0cec          mov    r3, w[response_length_uw] ; upper word of response length
 140 0a5e 09c0 16f2          mov    r0, w[CBW_data_transfer_length_lw]
 141 0a62 09c1 16f4          mov    r1, w[CBW_data_transfer_length_uw] ; R1:R0 = dwCBWDataTransferLength
 142                         ;; R1:R0 - R3:R2
 143 0a66 af9f 0bb2          call   subtract_16
 144 0a6a c307               jnc    @f	  ; If result < 0?
 145                         ;; if (iLen > CBW.dwCBWDataTransferLength) then: negative residue
 146 0a6c af9f 0b0e          call   stall_transfer
 147 0a70 07c0 0002          mov    r0, CSW_PHASE_ERROR
 148 0a74 af9f 0b4e          call   send_csw
 149 0a78 cf97               ret
 150 0a7a                @@:
 151                         ;; dwTransferSize = iLen
 152 0a7a 09e7 0cea 0966     mov    w[dwTransferSize_lw], w[response_length_lw]
 153 0a80 09e7 0cec 0968     mov    w[dwTransferSize_uw], w[response_length_uw]
 154                         ;; if ((dwTransferSize == 0) || fDevIn)
 155 0a86 57e7 0000 0966     cmp    w[dwTransferSize_lw], 0x0000
 156 0a8c c105               jne    @f
 157 0a8e 57e7 0000 0968     cmp    w[dwTransferSize_uw], 0x0000
 158 0a94 c101               jne    @f
 159 0a96 cf08               jmp    device_to_host
 160 0a98                @@: ;; else, host to device:
 161 0a98 77ef 0001 0cee     test   b[dev_in_flag], 1
 162 0a9e c104               jnz    device_to_host
 163                         ;; otherwise, data from host to device:
 164 0aa0 07ef 0001 1460     mov    b[scsi_state], SCSI_state_data_out
 165 0aa6 cf97               ret
 166 0aa8                device_to_host:
 167 0aa8 07ef 0002 1460     mov    b[scsi_state], SCSI_state_data_in
 168 0aae af9f 0c5e          call   handle_data_in
 169 0ab2 cf97               ret
 170 0ab4                do_rx_state_data_out:
 171 0ab4 af9f 0bba          call   handle_data_out
 172 0ab8 cf97               ret
 173 0aba                do_rx_state_data_in:
 174 0aba                do_rx_state_CSW:
 175                         ;; iChunk = USBHwEPRead(bEP, NULL, 0); (for debug only?)
 176                         ;; phrase error:
 177                         ;; mov    b[scsi_state], SCSI_state_CBW
 178 0aba cf97               ret
 179 0abc                do_rx_state_stalled:
 180 0abc af9f 0b36          call   stall_bulk_out_ep ; if stalled, keep stalling:
 181 0ac0 cf97               ret
 182                     ;*****************************************************************************
 183                     
 184                     ;*****************************************************************************
 185                     ;; Process data sent to bulk IN endpoint.
 186                     ;*****************************************************************************
 187 0ac2                usb_dev_to_host_handler:
 188                         ;; Determine what the response should be.
 189                         ;; This depends first on the SCSI state machine's state.
 190 0ac2 9249               xor    r9, r9
 191 0ac4 0bc9 1460          mov    r9, b[scsi_state]
 192 0ac8 57c9 0004          cmp    r9, 4
 193 0acc cd05               jle    scsi_tx_state_0_to_4	; make sure state is 0..4
 194                         ;; recover from weird state - should never get here:
 195 0ace 07ef 0000 1460     mov    b[scsi_state], SCSI_state_CBW
 196 0ad4 0bc9 1460          mov    r9, b[scsi_state]
 197 0ad8                scsi_tx_state_0_to_4:
 198 0ad8 d209               shl    r9, 1		; table offset times two (addresses are words.)
 199 0ada cfb1 0ade          jmpl   [r9 + scsi_tx_state_jmp_table]
 200                         ;; SCSI State Machine Table
 201 0ade                scsi_tx_state_jmp_table:
 202 0ade 0ae8               dw     do_tx_state_CBW
 203 0ae0 0ae8               dw     do_tx_state_data_out
 204 0ae2 0aea               dw     do_tx_state_data_in
 205 0ae4 0af0               dw     do_tx_state_CSW
 206 0ae6 0b08               dw     do_tx_state_stalled
 207                         ;; ------------------------
 208 0ae8                do_tx_state_CBW:
 209 0ae8                do_tx_state_data_out:
 210 0ae8 cf97               ret
 211 0aea                do_tx_state_data_in:
 212 0aea af9f 0c5e          call   handle_data_in
 213 0aee cf97               ret
 214 0af0                do_tx_state_CSW:
 215 0af0 07e7 000d 0912     mov	   w[usbsend_len], CSW_Size
 216 0af6 07e7 0000 08d4     mov    w[send_buffer_offset], 0x0000
 217 0afc af9f 0916          call   bulk_send  ;; send the CSW:
 218 0b00 07ef 0000 1460     mov    b[scsi_state], SCSI_state_CBW
 219 0b06 cf97               ret
 220 0b08                do_tx_state_stalled:
 221 0b08 af9f 0b3c          call   stall_bulk_in_ep ; if stalled, keep stalling:
 222 0b0c cf97               ret
 223                     ;*****************************************************************************
 224                     
 225                     
 226                     ;*****************************************************************************
 227                     ;; Stall ongoing transfer. Determine which endpoint to stall using CBW.
 228                     ;*****************************************************************************
 229 0b0e                stall_transfer:
 230 0b0e 9000               xor    r0,r0
 231 0b10 0bc0 16f6          mov    r0, b[CBW_flags]  ; Whether to stall IN endpoint:
 232 0b14 77c0 0080          test   r0, 0x80         ; Bit 7 = 0 for an OUT (host-to-device) transfer.
 233 0b18 c111               jnz	   stall_bulk_in_ep ; Bit 7 = 1 for an IN (device-to-host) transfer.
 234 0b1a 57e7 0000 16f2     cmp    w[CBW_data_transfer_length_lw], 0x0000 ; if lower word != 0, then stall EP_OUT
 235 0b20 c107               jne    stall_out
 236 0b22 57e7 0000 16f4     cmp    w[CBW_data_transfer_length_uw], 0x0000 ; if upper word != 0, then stall EP_OUT
 237 0b28 c103               jne    stall_out
 238                         ;; otherwise, if CBW_data_transfer_length == 0, stall EP_IN:
 239 0b2a af9f 0b3c          call   stall_bulk_in_ep
 240 0b2e cf97               ret
 241 0b30                stall_out:
 242 0b30 af9f 0b36          call   stall_bulk_out_ep
 243 0b34 cf97               ret
 244                     ;*****************************************************************************
 245                     
 246                     ;*****************************************************************************
 247                     ;; Stall endpoints.
 248                     ;*****************************************************************************
 249 0b36                stall_bulk_out_ep: ; Select endpoint 2 (OUT) control register
 250 0b36 07c9 02a0          mov    r9, DEV2_EP2_CTL_REG
 251 0b3a cf02               jmp    set_stall_bit
 252 0b3c                stall_bulk_in_ep: ; Select endpoint 1 (IN) control register
 253 0b3c 07c9 0290          mov    r9, DEV2_EP1_CTL_REG
 254 0b40                set_stall_bit: ; Stall the endpoint:
 255 0b40 87d1 0020          or     [r9], STALL_EN
 256                     
 257 0b44 07c0 0053          mov	   r0, 0x0053		; S
 258 0b48 af9f 0510          call   dbg_putchar
 259                         
 260 0b4c cf97               ret
 261                     ;*****************************************************************************
 262                     
 263                     ;*****************************************************************************
 264                     ;; Send CSW, on the next bulk-IN transfer.
 265                     ;; argument: r0 = bStatus
 266                     ;*****************************************************************************
 267 0b4e                send_csw:
 268 0b4e 67c0 00ff          and    r0, 0x00FF
 269 0b52 002f 14f6          mov    b[CSW_status], r0
 270 0b56 07e7 5355 14ea     mov    w[MSC_CSW_Signature_lw], CSW_Signature_lw_expected ; signature lower word
 271 0b5c 07e7 5342 14ec     mov    w[MSC_CSW_Signature_uw], CSW_Signature_uw_expected ; signature upper word
 272 0b62 09e7 16ee 14ee     mov    w[CSW_tag_lw], w[CBW_tag_lw]	; copy lower word of tag from last CBW
 273 0b68 09e7 16f0 14f0     mov    w[CSW_tag_uw], w[CBW_tag_uw] ; copy upper word of tag from last CBW
 274                         ;; iResidue = max( 0, (dwCBWDataTransferLength - dwTransferSize) )
 275 0b6e 09c2 0966          mov    r2, w[dwTransferSize_lw]
 276 0b72 09c3 0968          mov    r3, w[dwTransferSize_uw] ; R3:R2 = dwTransferSize
 277 0b76 09c0 16f2          mov    r0, w[CBW_data_transfer_length_lw]
 278 0b7a 09c1 16f4          mov    r1, w[CBW_data_transfer_length_uw] ; R1:R0 = dwCBWDataTransferLength
 279                         ;; R1:R0 - R3:R2
 280 0b7e af9f 0bb2          call   subtract_16
 281 0b82 c302               jnc    @f	  ; If result < 0?
 282 0b84 9000               xor    r0, r0 ; then iResidue = 0.
 283 0b86 9041               xor    r1, r1
 284 0b88                @@: ; iResidue >= 0:
 285 0b88 0027 14f2          mov    w[CSW_data_residue_lw], r0
 286 0b8c 0067 14f4          mov    w[CSW_data_residue_uw], r1
 287 0b90 07ef 0003 1460     mov    b[scsi_state], SCSI_state_CSW ; next SCSI state = CSW
 288 0b96 cf97               ret
 289                     ;*****************************************************************************

 132                     include util.asm

   0                      ;; /*************************************************************************
   1                      ;; *                     This file is part of Stierlitz:                    *
   2                      ;; *               https://github.com/asciilifeform/Stierlitz               *
   3                      ;; *************************************************************************/
   4                     
   5                      ;; /*************************************************************************
   6                      ;; *                (c) Copyright 2012 Stanislav Datskovskiy                *
   7                      ;; *                         http://www.loper-os.org                        *
   8                      ;; **************************************************************************
   9                      ;; *                                                                        *
  10                      ;; *  This program is free software: you can redistribute it and/or modify  *
  11                      ;; *  it under the terms of the GNU General Public License as published by  *
  12                      ;; *  the Free Software Foundation, either version 3 of the License, or     *
  13                      ;; *  (at your option) any later version.                                   *
  14                      ;; *                                                                        *
  15                      ;; *  This program is distributed in the hope that it will be useful,       *
  16                      ;; *  but WITHOUT ANY WARRANTY; without even the implied warranty of        *
  17                      ;; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
  18                      ;; *  GNU General Public License for more details.                          *
  19                      ;; *                                                                        *
  20                      ;; *  You should have received a copy of the GNU General Public License     *
  21                      ;; *  along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  22                      ;; *                                                                        *
  23                      ;; *************************************************************************/
  24                     
  25                     
  26                     ;*****************************************************************************
  27                     ;; Call BIOS idle
  28                     ;*****************************************************************************
  29 0b98                bios_idle:
  30 0b98 af49               int    PUSHALL_INT
  31 0b9a af46               int    IDLE_INT
  32 0b9c af4a               int    POPALL_INT
  33 0b9e cf97               ret
  34                     ;*****************************************************************************
  35                     
  36                     
  37                     ;*****************************************************************************
  38                     ;; Delay - call idle loop R0 times
  39                     ;*****************************************************************************
  40 0ba0                delay:
  41 0ba0 af9f 0b98          call   bios_idle
  42 0ba4 da00               subi   r0, 1
  43 0ba6 c17c               jnz    delay
  44 0ba8 cf97               ret
  45                     ;*****************************************************************************
  46                     
  47                     
  48                     ;*****************************************************************************
  49                     ; mem_move
  50                     ; r9 = dest, r8 = src, r1 = word count
  51                     ;*****************************************************************************
  52 0baa                mem_move:
  53 0baa                @@:
  54 0baa 0821               mov    w[r9++], w[r8++]	; copy data
  55 0bac da01               dec    r1
  56 0bae c17d               jnz    @b
  57 0bb0 cf97               ret
  58                     ;*****************************************************************************
  59                     
  60                     
  61                     ;*****************************************************************************
  62                     ; subtract (16-bit)
  63                     ; R1:R0 - R3:R2
  64                     ;*****************************************************************************
  65 0bb2                subtract_16:
  66 0bb2 3080               sub    r0, r2 ; Subtract the lower halves.  This may "borrow" from the upper half.
  67 0bb4 40c1               subb   r1, r3 ; Subtract the upper halves.
  68 0bb6 cf97               ret
  69                     ;*****************************************************************************

 133                     include scsi-data.asm

   0                      ;; /*************************************************************************
   1                      ;; *                     This file is part of Stierlitz:                    *
   2                      ;; *               https://github.com/asciilifeform/Stierlitz               *
   3                      ;; *************************************************************************/
   4                     
   5                      ;; /*************************************************************************
   6                      ;; *                (c) Copyright 2012 Stanislav Datskovskiy                *
   7                      ;; *                         http://www.loper-os.org                        *
   8                      ;; **************************************************************************
   9                      ;; *                                                                        *
  10                      ;; *  This program is free software: you can redistribute it and/or modify  *
  11                      ;; *  it under the terms of the GNU General Public License as published by  *
  12                      ;; *  the Free Software Foundation, either version 3 of the License, or     *
  13                      ;; *  (at your option) any later version.                                   *
  14                      ;; *                                                                        *
  15                      ;; *  This program is distributed in the hope that it will be useful,       *
  16                      ;; *  but WITHOUT ANY WARRANTY; without even the implied warranty of        *
  17                      ;; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
  18                      ;; *  GNU General Public License for more details.                          *
  19                      ;; *                                                                        *
  20                      ;; *  You should have received a copy of the GNU General Public License     *
  21                      ;; *  along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  22                      ;; *                                                                        *
  23                      ;; *************************************************************************/
  24                     
  25                     ;*****************************************************************************
  26 0bb8 0000           iChunk				dw	0x0000
  27           0000      align 2
  28                     ;*****************************************************************************
  29                     
  30                     ;*****************************************************************************
  31                     ; Handle SCSI Data Out. (Host to Device)
  32                     ;*****************************************************************************
  33 0bba                handle_data_out:
  34 0bba 07e7 0040 0bb8     mov    w[iChunk], USB_PACKET_SIZE ; start with 64
  35                         
  36 0bc0 09c0 0966          mov    r0, w[dwTransferSize_lw]
  37 0bc4 09c1 0968          mov    r1, w[dwTransferSize_uw] ; R1:R0 = dwTransferSize
  38 0bc8 09c2 096a          mov    r2, w[dwOffset_lw]
  39 0bcc 09c3 096c          mov    r3, w[dwOffset_uw] ; R3:R2 = dwOffset
  40                         ;; R1:R0 - R3:R2
  41 0bd0 af9f 0bb2          call   subtract_16
  42                         ;; jc     no_data_out ; if carry, then dwOffset > dwTransferSize
  43                         
  44                         ;; if (dwOffset < dwTransferSize)
  45                         ;; iChunk = USBHwEPRead(bulk_out_ep, pbData, dwTransferSize - dwOffset)
  46                         ;; r0 already = dwTransferSize - dwOffset
  47                         ;; iChunk = MIN(64, dwTransferSize - dwOffset)
  48 0bd4 6041               and    r1, r1
  49 0bd6 c106               jnz    @f ; if upper word of subtraction result is nonzero, then definitely > 64
  50 0bd8 0004               mov    r4, r0
  51 0bda 67c4 ffc0          and    r4, (1 + (0xFFFF - USB_PACKET_SIZE)) ; 64: 0xFFC0
  52 0bde c102               jnz    @f ; if lower word is greater than 64, then keep iChunk == 64.
  53 0be0 0027 0bb8          mov    w[iChunk], r0 ; otherwise, iChunk <- r0 (dwTransferSize - dwOffset).
  54 0be4                @@:
  55 0be4 09c0 0bb8          mov    r0, w[iChunk] ; number of bytes to receive from bulk_out_ep
  56 0be8 0027 0950          mov    w[usbrecv_len], r0 ; how many bytes to receive
  57 0bec 07e7 18ea 094e     mov    w[usbrecv_addr], block_receive_buffer ; into Block buffer!
  58                     
  59 0bf2 09c0 096a          mov    r0, w[dwOffset_lw] ; only need lower word of dwoffset to calculate offset into block
  60 0bf6 67c0 01ff          and    r0, 0x01FF ;; dwBufPos = (dwOffset & (BLOCKSIZE - 1))
  61 0bfa 1027 094e          add    w[usbrecv_addr], r0
  62 0bfe af9f 0920          call   usb_receive_data ; receive data from host
  63 0c02 af9f 0e6e          call   SCSI_handle_data
  64 0c06 57ef 0001 0e6c     cmp    b[dat_must_stall_flag], 0x01
  65 0c0c c107               jne    @f
  66                         ;; if pbData == NULL:
  67 0c0e af9f 0b0e          call   stall_transfer
  68 0c12 07c0 0001          mov    r0, CSW_CMD_FAILED
  69 0c16 af9f 0b4e          call   send_csw
  70 0c1a cf97               ret
  71 0c1c                @@:
  72 0c1c 09c0 0bb8          mov    r0, w[iChunk]
  73 0c20 1027 096a          add    w[dwOffset_lw], r0   ; dwOffset += iChunk
  74 0c24 27e7 0000 096c     addc   w[dwOffset_uw], 0 	; add possible carry
  75 0c2a                no_data_out:
  76 0c2a 59e7 0966 096a     cmp    w[dwOffset_lw], w[dwTransferSize_lw]
  77 0c30 c112               jne    data_out_done
  78 0c32 59e7 0968 096c     cmp    w[dwOffset_uw], w[dwTransferSize_uw]
  79 0c38 c10e               jne    data_out_done
  80                         ;; if (dwOffset == dwTransferSize)
  81 0c3a 09c0 16f2          mov    r0, w[CBW_data_transfer_length_lw]
  82 0c3e 5027 096a          cmp    w[dwOffset_lw], r0
  83 0c42 c10a               jne    data_out_stall
  84 0c44 09c0 16f4          mov    r0, w[CBW_data_transfer_length_uw]
  85 0c48 5027 096c          cmp    w[dwOffset_uw], r0
  86 0c4c c105               jne    data_out_stall
  87 0c4e                data_out_send_csw:
  88 0c4e 07c0 0000          mov    r0, CSW_CMD_PASSED
  89 0c52 af9f 0b4e          call   send_csw
  90 0c56                data_out_done:
  91 0c56 cf97               ret
  92 0c58                data_out_stall:
  93 0c58 af9f 0b0e          call   stall_transfer
  94 0c5c cf78               jmp    data_out_send_csw
  95                     ;*****************************************************************************
  96                     
  97                     ;*****************************************************************************
  98                     ; Handle SCSI Data In. (Device to Host)
  99                     ;*****************************************************************************
 100 0c5e                handle_data_in:
 101 0c5e af9f 0e6e          call   SCSI_handle_data
 102 0c62 57ef 0001 0e6c     cmp    b[dat_must_stall_flag], 0x01
 103 0c68 c107               jne    @f
 104                         ;; pbData == NULL:
 105 0c6a af9f 0b0e          call   stall_transfer
 106 0c6e 07c0 0001          mov    r0, CSW_CMD_FAILED
 107 0c72 af9f 0b4e          call   send_csw
 108 0c76 cf97               ret
 109 0c78                @@:
 110                         ;; send data to host?
 111                         ;; if (dwOffset < dwTransferSize)
 112                         ;; iChunk = MIN(64, dwTransferSize - dwOffset)
 113 0c78 07e7 0040 0bb8     mov    w[iChunk], USB_PACKET_SIZE ; start with 64
 114 0c7e 09c0 0966          mov    r0, w[dwTransferSize_lw]
 115 0c82 09c1 0968          mov    r1, w[dwTransferSize_uw] ; R1:R0 = dwTransferSize
 116 0c86 09c2 096a          mov    r2, w[dwOffset_lw]
 117 0c8a 09c3 096c          mov    r3, w[dwOffset_uw] ; R3:R2 = dwOffset
 118                         ;; R1:R0 - R3:R2
 119 0c8e af9f 0bb2          call   subtract_16
 120 0c92 57c1 0000          cmp    r1, 0
 121 0c96 c106               jne    @f ; if upper word of subtraction result is nonzero, then definitely > 64
 122 0c98 0004               mov    r4, r0
 123 0c9a 67c4 ffc0          and    r4, (1 + (0xFFFF - USB_PACKET_SIZE)) ; 64: 0xFFC0
 124 0c9e c102               jnz    @f ; if lower word is greater than 64, then keep iChunk == 64.
 125 0ca0 0027 0bb8          mov    w[iChunk], r0 ; otherwise, iChunk <- r0 (dwTransferSize - dwOffset).
 126 0ca4                @@:
 127 0ca4 09c0 0bb8          mov    r0, w[iChunk] ; number of bytes to transmit to bulk_in_ep
 128 0ca8 0027 0912          mov	   w[usbsend_len], r0
 129 0cac 09c0 096a          mov    r0, w[dwOffset_lw] ; only need lower word of dwoffset to calculate offset into block
 130 0cb0 67c0 01ff          and    r0, 0x01FF ;; dwBufPos = (dwOffset & (BLOCKSIZE - 1))
 131 0cb4 0027 08d4          mov    w[send_buffer_offset], r0
 132 0cb8 af9f 0916          call   bulk_send	; transmit bytes to host
 133 0cbc 09c0 0bb8          mov    r0, w[iChunk]
 134 0cc0 1027 096a          add    w[dwOffset_lw], r0    ; dwOffset += iChunk
 135 0cc4 27e7 0000 096c     addc   w[dwOffset_uw], 0 	 ; add possible carry
 136                         ;; are we done?
 137 0cca 59e7 0966 096a     cmp    w[dwOffset_lw], w[dwTransferSize_lw]
 138 0cd0 c108               jne    data_in_done
 139 0cd2 59e7 0968 096c     cmp    w[dwOffset_uw], w[dwTransferSize_uw]
 140 0cd8 c104               jne    data_in_done
 141                         ;; if (dwOffset == dwTransferSize)
 142                         ;; mov    r0, w[CBW_data_transfer_length_lw]
 143                         ;; cmp    w[dwOffset_lw], r0
 144                         ;; jne    data_in_stall
 145                         ;; mov    r0, w[CBW_data_transfer_length_uw]
 146                         ;; cmp    w[dwOffset_uw], r0
 147                         ;; jne    data_in_stall
 148 0cda                data_in_send_csw:
 149 0cda 07c0 0000          mov    r0, CSW_CMD_PASSED
 150 0cde af9f 0b4e          call   send_csw
 151 0ce2                data_in_done:
 152 0ce2 cf97               ret
 153 0ce4                data_in_stall:
 154 0ce4 af9f 0b0e          call   stall_transfer
 155 0ce8 cf78               jmp    data_in_send_csw
 156                     ;*****************************************************************************

 134                     include scsi-cmd.asm

   0                      ;; /*************************************************************************
   1                      ;; *                     This file is part of Stierlitz:                    *
   2                      ;; *               https://github.com/asciilifeform/Stierlitz               *
   3                      ;; *************************************************************************/
   4                     
   5                      ;; /*************************************************************************
   6                      ;; *                (c) Copyright 2012 Stanislav Datskovskiy                *
   7                      ;; *                         http://www.loper-os.org                        *
   8                      ;; **************************************************************************
   9                      ;; *                                                                        *
  10                      ;; *  This program is free software: you can redistribute it and/or modify  *
  11                      ;; *  it under the terms of the GNU General Public License as published by  *
  12                      ;; *  the Free Software Foundation, either version 3 of the License, or     *
  13                      ;; *  (at your option) any later version.                                   *
  14                      ;; *                                                                        *
  15                      ;; *  This program is distributed in the hope that it will be useful,       *
  16                      ;; *  but WITHOUT ANY WARRANTY; without even the implied warranty of        *
  17                      ;; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
  18                      ;; *  GNU General Public License for more details.                          *
  19                      ;; *                                                                        *
  20                      ;; *  You should have received a copy of the GNU General Public License     *
  21                      ;; *  along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  22                      ;; *                                                                        *
  23                      ;; *************************************************************************/
  24                     
  25                     
  26                     ;*****************************************************************************
  27                     ;; SCSI command handler
  28                     ;*****************************************************************************
  29 0cea 0000           response_length_lw		dw 0x0000 ; Length of intended response data
  30 0cec 0000           response_length_uw		dw 0x0000 ; Length of intended response data - Upper Word
  31 0cee 0000           dev_in_flag			dw 0x0000 ; TRUE if data moving device -> host
  32 0cf0 0000           cmd_must_stall_flag		dw 0x0000 ; TRUE if bad command and must stall
  33           0000      align 2
  34                     ;*****************************************************************************
  35                     ; CDB length table:
  36 0cf2                aiCDBLen_table:
  37 0cf2 06                 db				6
  38 0cf3 0a                 db			       10
  39 0cf4 0a                 db			       10
  40 0cf5 00                 db				0
  41 0cf6 10                 db			       16
  42 0cf7 0c                 db			       12
  43 0cf8 00                 db				0
  44 0cf9 00                 db			        0
  45           0000      align 2
  46                     ;*****************************************************************************
  47 0cfa                SCSI_handle_cmd:
  48 0cfa 07e7 0000 0cea     mov    w[response_length_lw], 0x0000 ; default - no data
  49 0d00 07e7 0000 0cec     mov    w[response_length_uw], 0x0000 ; default - no data
  50 0d06 07ef 0000 0cf0     mov    b[cmd_must_stall_flag], 0x00	 ; default - no stall
  51 0d0c 07ef 0001 0cee     mov    b[dev_in_flag], 0x01	; default direction is device -> host
  52 0d12 9000               xor    r0, r0
  53 0d14 0bc0 16f9          mov    r0, b[Common_SCSI_CDB_op_code]
  54 0d18 dfc3               clc
  55 0d1a d100               shr    r0, 5
  56 0d1c 67c0 0007          and    r0, 0x7		       ; bGroupCode
  57 0d20 000b               mov    r11, r0	               ; table offset
  58 0d22 17cb 0cf2          add    r11, aiCDBLen_table	       ; table origin
  59 0d26 9041               xor    r1, r1
  60 0d28 06c1               mov    r1, b[r11]                  ; aiCDBLen[bGroupCode]
  61 0d2a 506f 16f8          cmp    b[CBW_cb_length], r1	       ; if (CDBLen < aiCDBLen[bGroupCode])
  62 0d2e c23b               jb     bad_scsi_cmd		       ; return NULL (bad cmd)
  63 0d30 9000               xor    r0, r0
  64 0d32 0bc0 16f9          mov    r0, b[Common_SCSI_CDB_op_code]
  65 0d36 57c0 0000          cmp    r0, SCSI_CMD_TEST_UNIT_READY
  66 0d3a c039               je     SCSI_command_test_unit_ready
  67 0d3c 57c0 0003          cmp    r0, SCSI_CMD_REQUEST_SENSE
  68 0d40 c037               je     SCSI_command_request_sense
  69 0d42 57c0 0004          cmp    r0, SCSI_CMD_FORMAT_UNIT
  70 0d46 c09f 0dce          je     SCSI_command_format_unit
  71 0d4a 57c0 0012          cmp    r0, SCSI_CMD_INQUIRY
  72 0d4e c09f 0dd0          je     SCSI_command_inquiry
  73 0d52 57c0 001a          cmp    r0, SCSI_CMD_MODE_SENSE6
  74 0d56 c09f 0dee          je     SCSI_command_mode_sense_6
  75 0d5a 57c0 001e          cmp    r0, SCSI_CMD_P_OR_A_MEDIUM_RMVL
  76 0d5e c09f 0dfc          je     SCSI_command_p_or_a_medium_rmvl
  77 0d62 57c0 0025          cmp    r0, SCSI_CMD_READ_CAPACITY
  78 0d66 c09f 0dfe          je     SCSI_command_read_capacity
  79 0d6a 57c0 0008          cmp    r0, SCSI_CMD_READ_6
  80 0d6e c09f 0e0c          je     SCSI_command_read_6
  81 0d72 57c0 0028          cmp    r0, SCSI_CMD_READ_10
  82 0d76 c09f 0e10          je     SCSI_command_read_10
  83 0d7a 57c0 000a          cmp    r0, SCSI_CMD_WRITE_6
  84 0d7e c09f 0e32          je     SCSI_command_write_6
  85 0d82 57c0 002a          cmp    r0, SCSI_CMD_WRITE_10
  86 0d86 c09f 0e38          je     SCSI_command_write_10
  87 0d8a 57c0 002f          cmp    r0, SCSI_CMD_VERIFY_10
  88 0d8e c09f 0e60          je     SCSI_command_verify_10
  89 0d92 57c0 00a0          cmp    r0, SCSI_CMD_REPORT_LUNS
  90 0d96 c09f 0e66          je     SCSI_command_report_luns
  91 0d9a                scsi_cmd_not_implemented: ;; None of these (unhandled / bad):
  92 0d9a 07e7 2000 145c     mov    w[SCSI_dw_sense_lw], SENSE_INVALID_CMD_OPCODE_lw
  93 0da0 07e7 0005 145e     mov    w[SCSI_dw_sense_uw], SENSE_INVALID_CMD_OPCODE_uw ;; dwSense = INVALID_CMD_OPCODE;
  94 0da6                bad_scsi_cmd:
  95 0da6 07ef 0001 0cf0     mov    b[cmd_must_stall_flag], 0x01 ; Must stall
  96 0dac cf97               ret
  97                     ;; bad_field:
  98                     ;;     mov    w[SCSI_dw_sense_lw], SENSE_INVALID_FIELD_IN_CDB_lw
  99                     ;;     mov    w[SCSI_dw_sense_uw], SENSE_INVALID_FIELD_IN_CDB_uw
 100                     ;;     jmp    bad_scsi_cmd
 101                     ;; SCSI Command Handlers
 102 0dae                SCSI_command_test_unit_ready:
 103 0dae cf97               ret
 104 0db0                SCSI_command_request_sense:
 105                         ;; rsplen = min(18, pCDB->bLength)
 106 0db0 07e7 0000 0cec     mov    w[response_length_uw], 0x0000
 107 0db6 07e7 0012 0cea     mov    w[response_length_lw], 18
 108 0dbc 9000               xor    r0, r0
 109 0dbe 0bc0 16fd          mov    r0, b[Request_Sense_SCSI_CDB_bLength]
 110 0dc2 5027 0cea          cmp    w[response_length_lw], r0
 111 0dc6 c902               jbe    @f
 112 0dc8 0027 0cea          mov    w[response_length_lw], r0
 113 0dcc                @@:
 114 0dcc cf97               ret
 115 0dce                SCSI_command_format_unit:
 116 0dce cf97               ret
 117 0dd0                SCSI_command_inquiry:
 118                         ;; rsplen = min(36, pCDB->bLength)
 119 0dd0 07e7 0000 0cec     mov    w[response_length_uw], 0x0000
 120 0dd6 07e7 0024 0cea     mov    w[response_length_lw], 36
 121 0ddc 9000               xor    r0, r0
 122 0dde 0bc0 16fd          mov    r0, b[Inquiry_SCSI_CDB_bLength]
 123 0de2 5027 0cea          cmp    w[response_length_lw], r0
 124 0de6 c902               jbe    @f
 125 0de8 0027 0cea          mov    w[response_length_lw], r0
 126 0dec                @@:
 127 0dec cf97               ret
 128 0dee                SCSI_command_mode_sense_6:
 129 0dee 07e7 0000 0cec     mov    w[response_length_uw], 0x0000
 130 0df4 07e7 00c0 0cea     mov    w[response_length_lw], 0xC0
 131 0dfa cf97               ret
 132 0dfc                SCSI_command_p_or_a_medium_rmvl:
 133 0dfc cf97               ret
 134 0dfe                SCSI_command_read_capacity:
 135 0dfe 07e7 0000 0cec     mov    w[response_length_uw], 0x0000
 136 0e04 07e7 0008 0cea     mov    w[response_length_lw], 8
 137 0e0a cf97               ret
 138 0e0c                SCSI_command_read_6:
 139 0e0c cf46               jmp    scsi_cmd_not_implemented ;;;;;; NOT IMPLEMENTED YET ;;;;;;
 140 0e0e cf97               ret
 141 0e10                SCSI_command_read_10:
 142                         ;; Calculate response length: BLOCKSIZE will always be 512
 143 0e10 9000               xor    r0, r0 ; will be lower word of rsplen
 144 0e12 9041               xor    r1, r1 ; will be upper word of rsplen
 145 0e14 0bc1 1700          mov    r1, b[Read10_SCSI_CDB_Transfer_Len_1] ; upper byte of transfer length
 146 0e18 d201               shl    r1, 1				 ; shift by 1 (already shifted by 8)
 147 0e1a 0bc0 1701          mov    r0, b[Read10_SCSI_CDB_Transfer_Len_0] ; lower byte of transfer length
 148 0e1e d3c0               shl    r0, 8
 149 0e20 dfc3               clc
 150 0e22 d200               shl    r0, 1
 151 0e24 27c1 0000          addc   r1, 0 ; if carry, set low bit of upper word of result
 152                         ;; now, rsplen = dwLen * 512
 153 0e28 0027 0cea          mov    w[response_length_lw], r0
 154 0e2c 0067 0cec          mov    w[response_length_uw], r1
 155 0e30 cf97               ret
 156 0e32                SCSI_command_write_6:
 157 0e32 cf9f 0d9a          jmp    scsi_cmd_not_implemented ;;;;;; NOT IMPLEMENTED YET ;;;;;;
 158 0e36 cf97               ret
 159 0e38                SCSI_command_write_10:
 160                         ;; Calculate response length: BLOCKSIZE will always be 512
 161 0e38 9000               xor    r0, r0 ; will be lower word of rsplen
 162 0e3a 9041               xor    r1, r1 ; will be upper word of rsplen
 163 0e3c 0bc1 1700          mov    r1, b[Write10_SCSI_CDB_Transfer_Len_1] ; upper byte of transfer length
 164 0e40 d201               shl    r1, 1				 ; shift by 1 (already shifted by 8)
 165 0e42 0bc0 1701          mov    r0, b[Write10_SCSI_CDB_Transfer_Len_0] ; lower byte of transfer length
 166 0e46 d3c0               shl    r0, 8
 167 0e48 dfc3               clc
 168 0e4a d200               shl    r0, 1
 169 0e4c 27c1 0000          addc   r1, 0 ; if carry, set low bit of upper word of result
 170                         ;; now, rsplen = dwLen * 512
 171 0e50 0027 0cea          mov    w[response_length_lw], r0
 172 0e54 0067 0cec          mov    w[response_length_uw], r1
 173 0e58 07ef 0000 0cee     mov    b[dev_in_flag], 0x00	; switch comm. direction
 174 0e5e cf97               ret
 175 0e60                SCSI_command_verify_10:
 176 0e60 cf9f 0d9a          jmp    scsi_cmd_not_implemented ;;;;;; NOT IMPLEMENTED YET ;;;;;;
 177 0e64 cf97               ret
 178 0e66                SCSI_command_report_luns:
 179 0e66 cf9f 0d9a          jmp    scsi_cmd_not_implemented ;;;;;; NOT IMPLEMENTED YET ;;;;;;
 180 0e6a cf97               ret
 181                     ;*****************************************************************************
 182                     
 183                     
 184                     
 185                     ;*****************************************************************************
 186                     ;; SCSI data handler
 187                     ;*****************************************************************************
 188 0e6c 00             dat_must_stall_flag		db 0x00 ; TRUE if bad command and must stall
 189           0001      align 2
 190                     ;*****************************************************************************
 191 0e6e                SCSI_handle_data:
 192 0e6e 07ef 0000 0e6c     mov    b[dat_must_stall_flag], 0x00
 193 0e74 9000               xor    r0, r0
 194 0e76 0bc0 16f9          mov    r0, b[Common_SCSI_CDB_op_code]
 195 0e7a 57c0 0000          cmp    r0, SCSI_CMD_TEST_UNIT_READY
 196 0e7e c09f 0f12          je     SCSI_data_cmd_test_unit_ready
 197 0e82 57c0 0003          cmp    r0, SCSI_CMD_REQUEST_SENSE
 198 0e86 c09f 0f2a          je     SCSI_data_cmd_request_sense
 199 0e8a 57c0 0004          cmp    r0, SCSI_CMD_FORMAT_UNIT
 200 0e8e c09f 0fa2          je     SCSI_data_cmd_format_unit
 201 0e92 57c0 0012          cmp    r0, SCSI_CMD_INQUIRY
 202 0e96 c09f 0fa4          je     SCSI_data_cmd_inquiry
 203 0e9a 57c0 001a          cmp    r0, SCSI_CMD_MODE_SENSE6
 204 0e9e c09f 0fb8          je     SCSI_data_cmd_mode_sense_6
 205 0ea2 57c0 001e          cmp    r0, SCSI_CMD_P_OR_A_MEDIUM_RMVL
 206 0ea6 c09f 0fee          je     SCSI_data_cmd_p_or_a_medium_rmvl
 207 0eaa 57c0 0025          cmp    r0, SCSI_CMD_READ_CAPACITY
 208 0eae c09f 0ff0          je     SCSI_data_cmd_read_capacity
 209 0eb2 57c0 0008          cmp    r0, SCSI_CMD_READ_6
 210 0eb6 c09f 1022          je     SCSI_data_cmd_read_6
 211 0eba 57c0 0028          cmp    r0, SCSI_CMD_READ_10
 212 0ebe c09f 1028          je     SCSI_data_cmd_read_10
 213 0ec2 57c0 000a          cmp    r0, SCSI_CMD_WRITE_6
 214 0ec6 c09f 105c          je     SCSI_data_cmd_write_6
 215 0eca 57c0 002a          cmp    r0, SCSI_CMD_WRITE_10
 216 0ece c09f 1062          je     SCSI_data_cmd_write_10
 217 0ed2 57c0 002f          cmp    r0, SCSI_CMD_VERIFY_10
 218 0ed6 c09f 109e          je     SCSI_data_cmd_verify_10
 219 0eda 57c0 00a0          cmp    r0, SCSI_CMD_REPORT_LUNS
 220 0ede c09f 10a0          je     SCSI_data_cmd_report_luns
 221 0ee2                scsi_data_cmd_not_implemented: ;; None of these (unhandled / bad):
 222 0ee2 07e7 2000 145c     mov    w[SCSI_dw_sense_lw], SENSE_INVALID_CMD_OPCODE_lw
 223 0ee8 07e7 0005 145e     mov    w[SCSI_dw_sense_uw], SENSE_INVALID_CMD_OPCODE_uw ;; dwSense = INVALID_CMD_OPCODE;
 224 0eee                bad_scsi_dat_cmd:
 225 0eee 07ef 0001 0e6c     mov    b[dat_must_stall_flag], 0x01 ; Must stall
 226 0ef4 cf97               ret
 227 0ef6                scsi_read_error:
 228 0ef6 07e7 1100 145c     mov    w[SCSI_dw_sense_lw], SENSE_READ_ERROR_lw
 229 0efc 07e7 0003 145e     mov    w[SCSI_dw_sense_uw], SENSE_READ_ERROR_uw
 230 0f02 cf75               jmp    bad_scsi_dat_cmd
 231 0f04                scsi_write_error:
 232 0f04 07e7 0c00 145c     mov    w[SCSI_dw_sense_lw], SENSE_WRITE_ERROR_lw
 233 0f0a 07e7 0003 145e     mov    w[SCSI_dw_sense_uw], SENSE_WRITE_ERROR_uw
 234 0f10 cf6e               jmp    bad_scsi_dat_cmd
 235                     ;; SCSI data command handlers:
 236 0f12                SCSI_data_cmd_test_unit_ready:
 237 0f12 57e7 0000 145c     cmp    w[SCSI_dw_sense_lw], 0
 238 0f18 c007               je     @f
 239 0f1a 57e7 0000 145e     cmp    w[SCSI_dw_sense_uw], 0
 240 0f20 c003               je     @f
 241 0f22 07ef 0001 0e6c     mov    b[dat_must_stall_flag], 0x01 ;; if (dwSense !=0) return NULL;
 242 0f28                @@:
 243 0f28 cf97               ret
 244 0f2a                SCSI_data_cmd_request_sense:
 245                         ;; Build reply to request_sense command:
 246 0f2a 07ef 0070 14ea     mov    b[(send_buffer)], 0x70
 247 0f30 07ef 0000 14eb     mov    b[(send_buffer + 1)], 0x00
 248 0f36 0bef 145d 14ec     mov    b[(send_buffer + 2)], b[dwSense_KEY]
 249 0f3c 07ef 0000 14ed     mov    b[(send_buffer + 3)], 0x00
 250 0f42 07ef 0000 14ee     mov    b[(send_buffer + 4)], 0x00
 251 0f48 07ef 0000 14ef     mov    b[(send_buffer + 5)], 0x00
 252 0f4e 07ef 0000 14f0     mov    b[(send_buffer + 6)], 0x00
 253 0f54 07ef 000a 14f1     mov    b[(send_buffer + 7)], 0x0A
 254 0f5a 07ef 0000 14f2     mov    b[(send_buffer + 8)], 0x00
 255 0f60 07ef 0000 14f3     mov    b[(send_buffer + 9)], 0x00
 256 0f66 07ef 0000 14f4     mov    b[(send_buffer + 10)], 0x00
 257 0f6c 07ef 0000 14f5     mov    b[(send_buffer + 11)], 0x00
 258 0f72 0bef 145e 14f6     mov    b[(send_buffer + 12)], b[dwSense_ASC]
 259 0f78 0bef 145f 14f7     mov    b[(send_buffer + 13)], b[dwSense_ASCQ]
 260 0f7e 07ef 0000 14f8     mov    b[(send_buffer + 14)], 0x00
 261 0f84 07ef 0000 14f9     mov    b[(send_buffer + 15)], 0x00
 262 0f8a 07ef 0000 14fa     mov    b[(send_buffer + 16)], 0x00
 263 0f90 07ef 0000 14fb     mov    b[(send_buffer + 17)], 0x00
 264                         ;; reset dwSense
 265 0f96 9000               xor    r0, r0
 266 0f98 0027 145c          mov    w[SCSI_dw_sense_lw], r0
 267 0f9c 0027 145e          mov    w[SCSI_dw_sense_uw], r0
 268 0fa0 cf97               ret
 269 0fa2                SCSI_data_cmd_format_unit: ;; nothing happens
 270 0fa2 cf97               ret
 271 0fa4                SCSI_data_cmd_inquiry:
 272 0fa4 07c9 14ea          mov    r9, send_buffer
 273 0fa8 07c8 1462          mov    r8, SCSI_inquiry_response
 274 0fac 9041               xor    r1, r1
 275 0fae 07c1 0012          mov    r1, (INQ_ADD_LEN >> 1) ; number of WORDS to mem_move
 276 0fb2 af9f 0baa          call   mem_move
 277 0fb6 cf97               ret
 278 0fb8                SCSI_data_cmd_mode_sense_6:
 279 0fb8 af9f 0954          call   zap_send_buffer
 280 0fbc 07ef 0003 14ea     mov    b[(send_buffer)], 0x03 ; Number of bytes which follow
 281 0fc2 07ef 0000 14eb     mov    b[(send_buffer + 1)], 0x00 ; Medium Type: 00h for SBC devices.
 282 0fc8 07ef 0000 14ec     mov    b[(send_buffer + 2)], 0x00 ; Device-Specific Parameter - no WP, no cache
 283 0fce 07ef 0000 14ed     mov    b[(send_buffer + 3)], 0x00 ; No mode-parameter block descriptors.
 284 0fd4 07ef 0000 14ee     mov    b[(send_buffer + 4)], 0x00 ; No blocks
 285 0fda 07ef 0000 14ef     mov    b[(send_buffer + 5)], 0x00 ; No blocks
 286 0fe0 07ef 0000 14f0     mov    b[(send_buffer + 6)], 0x00 ; No blocks
 287 0fe6 07ef 0000 14f1     mov    b[(send_buffer + 7)], 0x00 ; No blocks
 288 0fec cf97               ret
 289 0fee                SCSI_data_cmd_p_or_a_medium_rmvl: ;; nothing happens
 290 0fee cf97               ret
 291 0ff0                SCSI_data_cmd_read_capacity:
 292                         ;; maximal block:
 293 0ff0 07ef 0000 14ea     mov    b[(send_buffer)], MAXBLOCK_3
 294 0ff6 07ef 003f 14eb     mov    b[(send_buffer + 1)], MAXBLOCK_2
 295 0ffc 07ef 00ff 14ec     mov    b[(send_buffer + 2)], MAXBLOCK_1
 296 1002 07ef 00ff 14ed     mov    b[(send_buffer + 3)], MAXBLOCK_0
 297                         ;; block size: (always 512)
 298 1008 07ef 0000 14ee     mov    b[(send_buffer + 4)], ((BLOCKSIZE >> 24) && 0xFF)
 299 100e 07ef 0000 14ef     mov    b[(send_buffer + 5)], ((BLOCKSIZE >> 16) && 0xFF)
 300 1014 07ef 0002 14f0     mov    b[(send_buffer + 6)], ((BLOCKSIZE >> 8) && 0xFF)
 301 101a 07ef 0000 14f1     mov    b[(send_buffer + 7)], (BLOCKSIZE && 0xFF)
 302 1020 cf97               ret
 303 1022                SCSI_data_cmd_read_6:
 304 1022 cf9f 0ee2          jmp    scsi_data_cmd_not_implemented  ;;;;;; NOT IMPLEMENTED YET ;;;;;;
 305 1026 cf97               ret
 306 1028                SCSI_data_cmd_read_10:
 307                         ;; Calculate current offset into buffer:
 308 1028 09c0 096a          mov    r0, w[dwOffset_lw]
 309 102c 67c0 01ff          and    r0, 0x01FF ;; dwBufPos = (dwOffset & (BLOCKSIZE - 1))
 310 1030 c114               jnz    @f
 311                         ;; load given LBA block index:
 312 1032 90c3               xor    r3, r3
 313 1034 9104               xor    r4, r4
 314 1036 0bc4 16fb          mov    r4, b[Read10_SCSI_CDB_LBA_3]
 315 103a d3c4               shl    r4, 8
 316 103c 8bc4 16fc          or     r4, b[Read10_SCSI_CDB_LBA_2] ;; r4 = old lba high word
 317 1040 0bc3 16fd          mov    r3, b[Read10_SCSI_CDB_LBA_1]
 318 1044 d3c3               shl    r3, 8
 319 1046 8bc3 16fe          or     r3, b[Read10_SCSI_CDB_LBA_0] ;; r3 = old lba low word
 320 104a 00e7 10a6          mov    w[given_lba_lw], r3
 321 104e 0127 10a8          mov    w[given_lba_uw], r4
 322 1052 af9f 10ae          call   compute_actual_block_index	; compute corrected index
 323                         ;; now load:
 324                         ;; TODO: error condition if the blocks to be read extend past end of "disk"
 325 1056 af9f 1184          call   load_lba_block ;; if (dwBufPos == 0) then read new block:
 326 105a                @@: ; not new block: offset into block is calculated in handle_data_in
 327 105a cf97               ret
 328 105c                SCSI_data_cmd_write_6:
 329 105c cf9f 0ee2          jmp    scsi_data_cmd_not_implemented  ;;;;;; NOT IMPLEMENTED YET ;;;;;;
 330 1060 cf97               ret
 331 1062                SCSI_data_cmd_write_10:
 332                         ;; Find out if we just started receiving a block:
 333 1062 09c0 096a          mov    r0, w[dwOffset_lw]
 334 1066 67c0 01ff          and    r0, 0x01FF
 335 106a c112               jnz    @f
 336                         ;; load given LBA block index:
 337 106c 90c3               xor    r3, r3
 338 106e 9104               xor    r4, r4
 339 1070 0bc4 16fb          mov    r4, b[Write10_SCSI_CDB_LBA_3]
 340 1074 d3c4               shl    r4, 8
 341 1076 8bc4 16fc          or     r4, b[Write10_SCSI_CDB_LBA_2] ;; r4 = old lba high word
 342 107a 0bc3 16fd          mov    r3, b[Write10_SCSI_CDB_LBA_1]
 343 107e d3c3               shl    r3, 8
 344 1080 8bc3 16fe          or     r3, b[Write10_SCSI_CDB_LBA_0] ;; r3 = old lba low word
 345 1084 00e7 10a6          mov    w[given_lba_lw], r3
 346 1088 0127 10a8          mov    w[given_lba_uw], r4
 347 108c af9f 10ae          call   compute_actual_block_index	; compute corrected index
 348 1090                @@:
 349                         ;; Did we just finish receiving a block?
 350 1090 57e7 1aea 094e     cmp    w[usbrecv_addr], (block_receive_buffer + BLOCKSIZE)
 351 1096 c102               jne    @f ; no. we're in mid-block.
 352                         ;; Yes, we did:
 353 1098 af9f 121c          call   save_lba_block
 354 109c                @@:
 355 109c cf97               ret
 356 109e                SCSI_data_cmd_verify_10: ;; nothing happens
 357 109e cf97               ret
 358 10a0                SCSI_data_cmd_report_luns:
 359 10a0 cf9f 0ee2          jmp    scsi_data_cmd_not_implemented  ;;;;;; NOT IMPLEMENTED YET ;;;;;;
 360 10a4 cf97               ret
 361                     ;*****************************************************************************
 362                     
 363                     
 364                     ;*****************************************************************************
 365                     ;; Correct LBA block index for current offset
 366                     ;; Low word is in 
 367                     ;*****************************************************************************
 368                     ;; input
 369 10a6 0000           given_lba_lw			dw 0x0000
 370 10a8 0000           given_lba_uw			dw 0x0000
 371                     ;; computed offset
 372 10aa 0000           blocks_offset_lw		dw 0x0000
 373 10ac 0000           blocks_offset_uw		dw 0x0000
 374                     ;*****************************************************************************
 375 10ae                compute_actual_block_index:
 376                         ;; find out if offset extends one or more block forward:
 377 10ae 09c1 096c          mov    r1, w[dwOffset_uw]
 378 10b2 d3c1               shl    r1, 8
 379 10b4 67c1 ff00          and    r1, 0xFF00
 380 10b8 0040               mov    r0, r1  ;; upper byte of r0 == lower byte of uw
 381 10ba 09c1 096a          mov    r1, w[dwOffset_lw]
 382 10be dfc3               clc
 383 10c0 d1c1               shr    r1, 8
 384 10c2 67c1 00ff          and    r1, 0x00FF
 385 10c6 8040               or     r0, r1 ;; r0 == {low{uw}, high{lw}}
 386 10c8 9104               xor    r4, r4
 387 10ca 09c1 096c          mov    r1, w[dwOffset_uw]
 388 10ce dfc3               clc
 389 10d0 d1c1               shr    r1, 8
 390 10d2 77c1 0001          test   r1, 1
 391 10d6 c001               jz     @f
 392 10d8 d804               addi   r4, 1 ; bit 0 of uw
 393 10da                @@:
 394 10da dfc3               clc
 395 10dc d000               shr    r0, 1
 396 10de 6104               and    r4, r4
 397 10e0 c002               jz     @f
 398 10e2 87c0 0080          or     r0, 0x0080 ; set bit 7 of result to equal low bit of uw
 399 10e6                @@:
 400 10e6 dfc3               clc
 401 10e8 d001               shr    r1, 1 ;; now {r1:r0} = {dwOffset_uw:dwOffset_lw} / 512
 402 10ea 0027 10aa          mov    w[blocks_offset_lw], r0
 403 10ee 0067 10ac          mov    w[blocks_offset_uw], r1
 404                         ;; skip block correction if correction factor is zero:
 405 10f2 6000               and    r0, r0
 406 10f4 c103               jnz    @f
 407 10f6 6041               and    r1, r1
 408 10f8 c101               jnz    @f
 409 10fa cf0e               jmp    no_block_correction ;; no need to correct for offset
 410 10fc                @@:
 411                         ;; need to correct for offset:
 412                         ;; load original LBA:
 413 10fc 09c3 10a6          mov    r3, w[given_lba_lw]
 414 1100 09c4 10a8          mov    r4, w[given_lba_uw]
 415                         ;; add correction factor:
 416 1104 dfc3               clc
 417 1106 19c3 10aa          add    r3, w[blocks_offset_lw] ; add lw of corrector to low word of LBA
 418 110a 29c4 10ac          addc   r4, w[blocks_offset_uw] ; add possible carry to high word of LBA
 419                         ;; write actual LBA to access:
 420 110e 00e7 1126          mov    w[actual_lba_lw], r3
 421 1112 0127 1128          mov    w[actual_lba_uw], r4
 422 1116 cf97               ret
 423 1118                no_block_correction:
 424 1118 09e7 10a6 1126     mov    w[actual_lba_lw], w[given_lba_lw]
 425 111e 09e7 10a8 1128     mov    w[actual_lba_uw], w[given_lba_uw]
 426 1124 cf97               ret
 427                     ;*****************************************************************************

 135                     include block.asm

   0                      ;; /*************************************************************************
   1                      ;; *                     This file is part of Stierlitz:                    *
   2                      ;; *               https://github.com/asciilifeform/Stierlitz               *
   3                      ;; *************************************************************************/
   4                     
   5                      ;; /*************************************************************************
   6                      ;; *                (c) Copyright 2012 Stanislav Datskovskiy                *
   7                      ;; *                         http://www.loper-os.org                        *
   8                      ;; **************************************************************************
   9                      ;; *                                                                        *
  10                      ;; *  This program is free software: you can redistribute it and/or modify  *
  11                      ;; *  it under the terms of the GNU General Public License as published by  *
  12                      ;; *  the Free Software Foundation, either version 3 of the License, or     *
  13                      ;; *  (at your option) any later version.                                   *
  14                      ;; *                                                                        *
  15                      ;; *  This program is distributed in the hope that it will be useful,       *
  16                      ;; *  but WITHOUT ANY WARRANTY; without even the implied warranty of        *
  17                      ;; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
  18                      ;; *  GNU General Public License for more details.                          *
  19                      ;; *                                                                        *
  20                      ;; *  You should have received a copy of the GNU General Public License     *
  21                      ;; *  along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  22                      ;; *                                                                        *
  23                      ;; *************************************************************************/
  24                     
  25                     ;*****************************************************************************
  26                     ;; Actual index of LBA block to read/write
  27                     ;*****************************************************************************
  28 1126 0000           actual_lba_lw			dw 0x0000
  29 1128 0000           actual_lba_uw			dw 0x0000
  30                     ;*****************************************************************************
  31                     
  32                     
  33                     ;*****************************************************************************
  34                     ;; Test if LBA block is within the given range.
  35                     ;; block is in actual_lba; range is r3:r2 to r4:r5.
  36                     ;; results: r2 is true or false.
  37                     ;;          r1:r0 is index into range (0...N)
  38                     ;*****************************************************************************
  39 112a                test_lba_block_in_range:
  40 112a 09c1 1128          mov    r1, w[actual_lba_uw]
  41 112e 09c0 1126          mov    r0, w[actual_lba_lw]
  42 1132 af9f 0bb2          call   subtract_16 ;; R1:R0 - R3:R2
  43 1136 c20e               jc     out_of_range	; below range?
  44                         ;; r1:r0 is now index into range, save it
  45 1138 0046               mov    r6, r1
  46 113a 0007               mov    r7, r0
  47 113c 09c1 1128          mov    r1, w[actual_lba_uw]
  48 1140 09c0 1126          mov    r0, w[actual_lba_lw]
  49 1144 0103               mov    r3, r4 ; uw of upper bound
  50 1146 0142               mov    r2, r5 ; lw of upper bound
  51 1148 af9f 0bb2          call   subtract_16 ;; R1:R0 - R3:R2
  52 114c c303               jnc    out_of_range
  53                         ;; is in range:
  54 114e 07c2 0001          mov    r2, 0x0001 ; True
  55 1152 cf02               jmp    blk_range_done
  56 1154                out_of_range:
  57 1154 07c2 0000          mov    r2, 0x0000 ; False
  58 1158                blk_range_done:
  59 1158 0181               mov    r1, r6
  60 115a 01c0               mov    r0, r7
  61 115c cf97               ret
  62                     ;*****************************************************************************
  63                     
  64                     
  65                     ;*****************************************************************************
  66                     ;; Test if LBA block is within the payload range.
  67                     ;*****************************************************************************
  68                     ;; watch out for carry (unhandled because QTASM is RETARDED ...)
  69                     ;; TODO: there's none right now. but check here again when we up the virtual file size.
  70           0000490f  FILE_TOP_LW	equ	(FAT16_DATA_AREA_LBA_LW_EFFECTIVE_BOTTOM + FILE_SIZE_IN_BLKS_LW)
  71           00000000  FILE_TOP_UW	equ	(FAT16_DATA_AREA_LBA_UW_EFFECTIVE_BOTTOM + FILE_SIZE_IN_BLKS_UW)
  72                     ;*****************************************************************************
  73 115e                test_lba_block_in_payload_range:
  74 115e 07c3 0000          mov    r3, FAT16_DATA_AREA_LBA_UW_EFFECTIVE_BOTTOM
  75 1162 07c2 029e          mov    r2, FAT16_DATA_AREA_LBA_LW_EFFECTIVE_BOTTOM
  76 1166 07c4 0000          mov    r4, FILE_TOP_UW
  77 116a 07c5 490f          mov    r5, FILE_TOP_LW
  78 116e af9f 112a          call   test_lba_block_in_range
  79 1172 77c2 0001          test   r2, 1
  80 1176 c004               jz     @f
  81 1178 0067 13a4          mov    w[physical_lba_uw], r1
  82 117c 0027 13a2          mov    w[physical_lba_lw], r0
  83 1180                @@:
  84 1180 0080               mov    r0, r2
  85 1182 cf97               ret
  86                     ;*****************************************************************************
  87                     
  88                     
  89                     ;*****************************************************************************
  90                     ;; Load LBA block
  91                     ;*****************************************************************************
  92 1184                load_lba_block:
  93 1184 af9f 115e          call   test_lba_block_in_payload_range
  94 1188 77c0 0001          test   r0, 1
  95 118c c003               jz     @f
  96 118e af9f 13a6          call   load_physical_lba_block ; this was a payload block
  97 1192 cf97               ret	; and so we're done here.
  98 1194                @@: ; Or, well, not:
  99                     
 100                         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 101                         ;; call   dbg_print_read_block_index
 102                         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 103                     
 104                         ;; What is it then?
 105                         ;; Primary FAT:
 106 1194 07c3 0000          mov    r3, FAT16_FAT_TABLES_BLOCK_LBA_UW
 107 1198 07c2 0040          mov    r2, FAT16_FAT_TABLES_BLOCK_LBA_LW
 108 119c 07c4 0000          mov    r4, FAT16_FAT_TABLES_BLOCK_LBA_UW ; should work, since we are the 1st partition
 109 11a0 07c5 013f          mov    r5, (FAT16_FAT_TABLES_BLOCK_LBA_LW + FAT16_PART0_SECTORS_PER_FAT)
 110 11a4 af9f 112a          call   test_lba_block_in_range
 111 11a8 77c2 0001          test   r2, 1
 112 11ac c003               jz     @f
 113 11ae af9f 125a          call   build_fat16_fat ;; Build FAT
 114 11b2 cf97               ret
 115 11b4                @@:
 116                         ;; Secondary FAT:
 117 11b4 07c3 0000          mov    r3, FAT16_FAT_TABLES_COPY_BLOCK_LBA_UW
 118 11b8 07c2 013f          mov    r2, FAT16_FAT_TABLES_COPY_BLOCK_LBA_LW
 119 11bc 07c4 0000          mov    r4, FAT16_FAT_TABLES_COPY_BLOCK_LBA_UW ; should work, since we are the 1st partition
 120 11c0 07c5 023e          mov    r5, (FAT16_FAT_TABLES_COPY_BLOCK_LBA_LW + FAT16_PART0_SECTORS_PER_FAT)
 121 11c4 af9f 112a          call   test_lba_block_in_range
 122 11c8 77c2 0001          test   r2, 1
 123 11cc c003               jz     @f
 124 11ce af9f 125a          call   build_fat16_fat ;; Build FAT
 125 11d2 cf97               ret
 126 11d4                @@:
 127                         ;; MBR:
 128 11d4 57e7 0000 1126     cmp    w[actual_lba_lw], MBR_BLOCK_LBA_LW
 129 11da c107               jne    @f
 130 11dc 57e7 0000 1128     cmp    w[actual_lba_uw], MBR_BLOCK_LBA_UW
 131 11e2 c103               jne    @f
 132                         ;; Build MBR
 133 11e4 af9f 123e          call   build_fat16_mbr
 134 11e8 cf97               ret
 135                         ;; Boot Block - start of partition:
 136 11ea 57e7 003f 1126 @@: cmp    w[actual_lba_lw], FAT16_BOOT_BLOCK_LBA_LW
 137 11f0 c107               jne    @f
 138 11f2 57e7 0000 1128     cmp    w[actual_lba_uw], FAT16_BOOT_BLOCK_LBA_UW
 139 11f8 c103               jne    @f
 140 11fa af9f 1346          call   build_fat16_boot_block
 141 11fe cf97               ret
 142                         ;; Root Directory Entries:
 143 1200 57e7 023e 1126 @@: cmp    w[actual_lba_lw], FAT16_ROOT_DIRECTORY_ENTRY_LBA_LW
 144 1206 c107               jne    @f
 145 1208 57e7 0000 1128     cmp    w[actual_lba_uw], FAT16_ROOT_DIRECTORY_ENTRY_LBA_UW
 146 120e c103               jne    @f
 147                         ;; Build Root Dir
 148 1210 af9f 12f2          call   build_fat16_root_dir
 149 1214 cf97               ret
 150 1216                zero_block: ; default - null block:
 151 1216 af9f 0954      @@: call   zap_send_buffer
 152 121a cf97               ret
 153                     ;*****************************************************************************
 154                     
 155                     
 156                     ;*****************************************************************************
 157                     ;; Save LBA block
 158                     ;*****************************************************************************
 159 121c                save_lba_block:
 160 121c af9f 115e          call   test_lba_block_in_payload_range
 161 1220 77c0 0001          test   r0, 1
 162 1224 c003               jz     @f
 163                         ;; this was a payload block:
 164 1226 af9f 13e0          call   save_physical_lba_block
 165 122a cf97               ret	; and so we're done here.
 166 122c                @@: ;; don't do anything for non-payload blocks...
 167 122c cf97               ret
 168                     ;*****************************************************************************
 169                     
 170                     
 171                     ;*****************************************************************************
 172                     ;; FAT16 MBR
 173                     ;*****************************************************************************
 174           0000      align 2
 175 122e                part0_mbr_record_data:
 176 122e 00             	db	PART0_STATUS
 177 122f 01             	db	PART0_START_HEAD
 178 1230 01             	db	PART0_START_SECT_76CYLHIGH
 179 1231 00             	db	PART0_START_CYL
 180 1232 0e             	db	PART0_PARTITION_TYPE
 181 1233 7f             	db	PART0_END_HEAD
 182 1234 bf             	db	PART0_END_SECT_76CYLHIGH
 183 1235 05             	db	PART0_END_CYL
 184 1236 003f           	dw	PART0_START_LBA_LW
 185 1238 0000           	dw	PART0_START_LBA_UW
 186 123a bcc1           	dw	PART0_SECTORS_LW
 187 123c 003f           	dw	PART0_SECTORS_UW
 188           00000010  	PART0_MBR_RECORD_DATA_LEN equ ($-part0_mbr_record_data)
 189                     ;*****************************************************************************
 190           0000      align 2
 191 123e                build_fat16_mbr:
 192 123e af9f 0954          call   zap_send_buffer
 193 1242 07c8 122e          mov    r8, part0_mbr_record_data
 194 1246 07c9 16a8          mov    r9, PART0_MBR_RECORD_OFFSET
 195 124a 07c1 0008          mov    r1, (PART0_MBR_RECORD_DATA_LEN >> 1) ; word count
 196 124e af9f 0baa          call   mem_move
 197 1252 07e7 aa55 16e8     mov    w[BOOT_SIGNATURE_OFFSET], BOOT_SIGNATURE
 198 1258 cf97               ret
 199                     ;*****************************************************************************
 200                     
 201                     
 202                     ;*****************************************************************************
 203                     ;; FAT16 FAT
 204                     ;*****************************************************************************
 205                     ;; ! QTASM IS RETARDED ! QTASM IS RETARDED ! QTASM IS RETARDED ! QTASM IS RETARDED
 206                     ;*****************************************************************************
 207                     ;; FAT16_PART0_SECTORS_PER_CLUSTER == 0x040
 208                     ;; FAKE_FILE_BYTES		equ	0x100000 ; 1 MB
 209                     ;; FAT16_CLUSTER_SIZE		equ	(0x040 * BLOCKSIZE)
 210                     ;; FAKE_FILE_CLUSTERS		equ	(FAKE_FILE_BYTES / FAT16_CLUSTER_SIZE)
 211                     ;*****************************************************************************
 212                     ;; ! QTASM IS RETARDED ! QTASM IS RETARDED ! QTASM IS RETARDED ! QTASM IS RETARDED
 213                     ;*****************************************************************************
 214                     
 215           0000      align 2
 216 125a                build_fat16_fat:
 217                         ;; r0 contains index of FAT page to load (0...FF)
 218 125a 07c9 14ea          mov    r9, send_buffer
 219 125e 6000               and    r0, r0
 220 1260 c109               jnz    @f
 221                         ;; If we were asked for the first page of the FAT:
 222 1262 07e1 fff8          mov    w[r9++], 0xfff8 ; Partition Type = HDD (0xf8);
 223 1266 07e1 ffff          mov    w[r9++], 0xffff ; State = Good (0xff) - TODO: Might need to be writable for mount! <---- Should we make this dirty?
 224 126a 07e1 0000          mov    w[r9++], 0x0000 ; Cluster 0 is reserved, and its address is 2.
 225 126e 07c0 0004          mov    r0, FIRST_CLUSTER_INDEX ; Number of first cluster of file
 226 1272 cf0d               jmp    build_fat
 227 1274                @@: ;; Not the first page:
 228 1274 0001               mov    r1, r0
 229 1276 9000               xor    r0, r0
 230 1278                @@:
 231 1278 17c0 0100          add    r0, 0x0100
 232 127c da01               subi   r1, 1
 233 127e c17c               jnz    @b
 234                         ;; if we're past the last page?
 235 1280 57c0 011a          cmp    r0, FAKE_FILE_CLUSTERS
 236 1284 c903               jbe    @f
 237 1286 af9f 0954          call   zap_send_buffer
 238 128a cf12               jmp    fat_build_done
 239 128c                @@: ;; now, r0 is either 3 (page 0) or 0xFF * page-index.
 240 128c d800               addi   r0, 1
 241 128e                build_fat:
 242 128e                @@:
 243                         ;; block full?
 244 128e 57c9 16ea          cmp    r9, (send_buffer + BLOCKSIZE) ; stop if the block is full
 245 1292 c00e               je     fat_build_done
 246                         ;; There is room:
 247 1294 57c0 011d          cmp    r0, (FIRST_CLUSTER_INDEX + FAKE_FILE_CLUSTERS - 1)
 248 1298 c003               je     penult_cluster ; this was the penultimate cluster
 249 129a 0021               mov    w[r9++], r0
 250 129c d800               addi   r0, 1
 251 129e cf77               jmp    @b ; keep adding cluster records.
 252 12a0                penult_cluster:
 253 12a0 07e1 ffff          mov    w[r9++], 0xFFFF ; Now write the last cluster of file.
 254 12a4 9000               xor    r0, r0
 255 12a6                @@:
 256 12a6 57c9 16ea          cmp    r9, (send_buffer + BLOCKSIZE) ; stop if the block is full
 257 12aa c002               je     fat_build_done
 258 12ac 0021               mov    w[r9++], r0
 259 12ae cf7b               jmp    @b
 260 12b0                fat_build_done:
 261 12b0 cf97               ret
 262                     ;*****************************************************************************
 263                     
 264                     
 265                     ;*****************************************************************************
 266                     ;; FAT16 Root Directory
 267                     ;*****************************************************************************
 268                     ;; Note: Linux actually tries to write access dates here, upon sync.
 269                     ;; But we don't care. There is no good reason to waste EEPROM write cycles
 270                     ;; only to store such garbage. The FAT16 bookkeeping will be kept constant.
 271                     ;*****************************************************************************
 272           0000      align 2
 273 12b2                fat16_root_dir_data:
 274                             ;; *****************************************************************
 275                             ;; Volume Label
 276                             ;; *****************************************************************
 277 12b2 53 54 49 52 4c 	db      'STIRLITZ   ' ; Volume Label (8 chars body + 3 chars ext)
          49 54 5a 20 20 
          20 
 278 12bd 08             	db	0x08   ; Attrib = 0x08 (Volume Label)
 279 12be 0000           	dw	0x0000 ; b. 12 - n/a; b. 13 - creation time (10th of secs)
 280 12c0 0000           	dw	0x0000 ; 14, 15: creation time (hours, minutes, seconds)
 281 12c2 0000           	dw	0x0000 ; creation date
 282 12c4 0000           	dw	0x0000 ; access date
 283 12c6 0000           	dw	0x0000 ; high word of 1st cluster address
 284 12c8 0000           	dw	0x0000 ; modified time (hours, minutes, seconds)
 285 12ca 0000           	dw	0x0000 ; modified date
 286 12cc 0000           	dw	0x0000 ; low word of 1st cluster address
 287 12ce 0000           	dw	0x0000 ; lower word of size (0 for directories)
 288 12d0 0000           	dw	0x0000 ; upper word of size (0 for directories)
 289                             ;; *****************************************************************
 290                     	;; If we wanted long file name, it would live here...
 291                     	;; *****************************************************************
 292                             ;; The File itself
 293                             ;; *****************************************************************
 294 12d2 4c 4f 50 45 52     	db      'LOPERIMGBIN' ; Volume Label (8 chars body + 3 chars ext)
          49 4d 47 42 49 
          4e 
 295 12dd 20             	db	0x20   ; Attrib = 0x20 ("Archive")
 296 12de 0000           	dw	0x0000 ; b. 12 - n/a; b. 13 - creation time (10th of secs)
 297 12e0 0000           	dw	0x0000 ; 14, 15: creation time (hours, minutes, seconds)
 298 12e2 0000           	dw	0x0000 ; creation date
 299 12e4 0000           	dw	0x0000 ; access date
 300 12e6 0000           	dw	0x0000 ; high word of 1st cluster address
 301 12e8 0000           	dw	0x0000 ; modified time (hours, minutes, seconds)
 302 12ea 0000           	dw	0x0000 ; modified date
 303 12ec 0003           	dw	0x0003 ; low word of 1st cluster address
 304 12ee e03c           	dw	FILE_SIZE_LW ; lower word of size (0 for directories)
 305 12f0 008c           	dw	FILE_SIZE_UW ; upper word of size (0 for directories)	
 306                             ;; *****************************************************************
 307           00000040  	FAT16_ROOT_DIR_DATA_LEN equ ($-fat16_root_dir_data)
 308                     ;*****************************************************************************
 309           0000      align 2
 310 12f2                build_fat16_root_dir:
 311 12f2 af9f 0954          call   zap_send_buffer
 312 12f6 07c8 12b2          mov    r8, fat16_root_dir_data
 313 12fa 07c9 14ea          mov    r9, send_buffer
 314 12fe 07c1 0020          mov    r1, (FAT16_ROOT_DIR_DATA_LEN >> 1) ; word count
 315 1302 af9f 0baa          call   mem_move
 316 1306 cf97               ret
 317                     ;*****************************************************************************
 318                     
 319                     
 320                     ;*****************************************************************************
 321                     ;; FAT16 Boot Block
 322                     ;*****************************************************************************
 323           0000      align 2
 324 1308                boot_block_data:
 325 1308 eb                 	db	0xeb ; jmp
 326 1309 3c             	db	0x3c ; jmp
 327 130a 90             	db	0x90 ; nop
 328 130b 4d 53 57 49 4e 	db      'MSWIN4.0' ; OEM name (8 chars)
          34 2e 30 
 329 1313 0200           	dw      FAT16_PART0_BYTES_PER_SECTOR
 330 1315 40             	db      FAT16_PART0_SECTORS_PER_CLUSTER
 331 1316 0001           	dw      FAT16_PART0_RESERVED_SECTORS
 332 1318 02             	db      FAT16_PART0_COPIES_OF_FAT
 333 1319 0200           	dw      FAT16_PART0_MAX_ROOT_DIR_ENTRIES
 334 131b 0000           	dw      FAT16_PART0_MAX_SECTS_IF_UNDR_32M
 335 131d f8             	db      FAT16_PART0_MEDIA_DESCRIPTOR
 336 131e 00ff           	dw      FAT16_PART0_SECTORS_PER_FAT
 337 1320 003f           	dw      FAT16_PART0_SECTORS_PER_TRACK
 338 1322 0080           	dw      FAT16_PART0_HEADS
 339 1324 003f           	dw      PART0_START_LBA_LW ; # of hidden sectors (LW) from MBR
 340 1326 0000           	dw      PART0_START_LBA_UW ; # of hidden sectors (UW) from MBR
 341 1328 bcc1           	dw      PART0_SECTORS_LW ; # of sectors (LW) from MBR
 342 132a 003f           	dw      PART0_SECTORS_UW ; # of sectors (UW) from MBR
 343 132c 0080           	dw      FAT16_PART0_LOGICAL_DRIVE_NUMBER
 344 132e 29             	db      FAT16_PART0_EXTENDED_SIGNATURE
 345 132f 5f7b           	dw      FAT16_PART0_PARTITION_SERIAL_NUM_LW
 346 1331 4f30           	dw      FAT16_PART0_PARTITION_SERIAL_NUM_UW
 347 1333 53 54 49 45 52 	db	'STIERLITZ  ' ; Volume name of partition (11 chars)
          4c 49 54 5a 20 
          20 
 348 133e 46 41 54 31 36 	db      'FAT16   ' ; FAT Name (must equal "FAT16   ")
          20 20 20 
 349           0000003e  	BOOT_BLOCK_DATA_LEN equ ($-boot_block_data)
 350                     ;*****************************************************************************
 351           0000      align 2
 352 1346                build_fat16_boot_block:
 353 1346 07c8 1308          mov    r8, boot_block_data
 354 134a 07c9 14ea          mov    r9, send_buffer
 355 134e 07c1 001f          mov    r1, (BOOT_BLOCK_DATA_LEN >> 1) ; word count
 356 1352 af9f 0baa          call   mem_move
 357                         ;; fill remainder:
 358 1356 07c9 1528          mov    r9, (send_buffer + BOOT_BLOCK_DATA_LEN) ; redundant?
 359 135a 07c1 00e0          mov    r1, (((BLOCKSIZE - BOOT_BLOCK_DATA_LEN) >> 1) - 1)
 360 135e                @@:
 361 135e 07e1 f6f6          mov    w[r9++], FAT16_BOOT_BLOCK_FILLER
 362 1362 da01               dec    r1
 363 1364 c17c               jnz    @b
 364 1366 07e7 aa55 16e8     mov    w[BOOT_SIGNATURE_OFFSET], BOOT_SIGNATURE
 365 136c cf97               ret
 366                     ;*****************************************************************************

 136                     include hpi.asm

   0                      ;; /*************************************************************************
   1                      ;; *                     This file is part of Stierlitz:                    *
   2                      ;; *               https://github.com/asciilifeform/Stierlitz               *
   3                      ;; *************************************************************************/
   4                     
   5                      ;; /*************************************************************************
   6                      ;; *                (c) Copyright 2012 Stanislav Datskovskiy                *
   7                      ;; *                         http://www.loper-os.org                        *
   8                      ;; **************************************************************************
   9                      ;; *                                                                        *
  10                      ;; *  This program is free software: you can redistribute it and/or modify  *
  11                      ;; *  it under the terms of the GNU General Public License as published by  *
  12                      ;; *  the Free Software Foundation, either version 3 of the License, or     *
  13                      ;; *  (at your option) any later version.                                   *
  14                      ;; *                                                                        *
  15                      ;; *  This program is distributed in the hope that it will be useful,       *
  16                      ;; *  but WITHOUT ANY WARRANTY; without even the implied warranty of        *
  17                      ;; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
  18                      ;; *  GNU General Public License for more details.                          *
  19                      ;; *                                                                        *
  20                      ;; *  You should have received a copy of the GNU General Public License     *
  21                      ;; *  along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  22                      ;; *                                                                        *
  23                      ;; *************************************************************************/
  24                     
  25                     
  26                     ;*****************************************************************************
  27                     ;; Spin until host reads HPI
  28                     ;*****************************************************************************
  29                     ;; TODO: timeouts
  30 136e                wait_for_hpi_read:
  31 136e                @@:
  32 136e 57ef 0001 079a     cmp    b[hpi_was_read], 0x01
  33 1374 c17c               jne    @b
  34 1376 07ef 0000 079a     mov    b[hpi_was_read], 0x00
  35 137c cf97               ret
  36                     ;*****************************************************************************
  37                     
  38                     
  39                     ;*****************************************************************************
  40                     ;; Spin until host writes HPI
  41                     ;*****************************************************************************
  42                     ;; TODO: timeouts
  43 137e                wait_for_hpi_written:
  44 137e                @@:
  45 137e 57ef 0001 07a8     cmp    b[hpi_was_written], 0x01
  46 1384 c17c               jne    @b
  47 1386 07ef 0000 07a8     mov    b[hpi_was_written], 0x00
  48 138c cf97               ret
  49                     ;*****************************************************************************
  50                     
  51                     
  52                     ;*****************************************************************************
  53                     ;; Send r0 to HPI port, synchronously
  54                     ;*****************************************************************************
  55 138e                hpi_mb_tx:
  56 138e 0027 c0c6          mov    w[HPI_MAILBOX_REG], r0
  57 1392 af9f 136e          call   wait_for_hpi_read
  58 1396 cf97               ret
  59                     ;*****************************************************************************
  60                     
  61                     
  62                     ;*****************************************************************************
  63                     ;; Receive r0 from HPI port, synchronously
  64                     ;*****************************************************************************
  65 1398                hpi_mb_rx:
  66 1398 af9f 137e          call   wait_for_hpi_written
  67 139c 09c0 c0c6          mov    r0, w[HPI_MAILBOX_REG]
  68 13a0 cf97               ret
  69                     ;*****************************************************************************

 137                     include payload.asm

   0                      ;; /*************************************************************************
   1                      ;; *                     This file is part of Stierlitz:                    *
   2                      ;; *               https://github.com/asciilifeform/Stierlitz               *
   3                      ;; *************************************************************************/
   4                     
   5                      ;; /*************************************************************************
   6                      ;; *                (c) Copyright 2012 Stanislav Datskovskiy                *
   7                      ;; *                         http://www.loper-os.org                        *
   8                      ;; **************************************************************************
   9                      ;; *                                                                        *
  10                      ;; *  This program is free software: you can redistribute it and/or modify  *
  11                      ;; *  it under the terms of the GNU General Public License as published by  *
  12                      ;; *  the Free Software Foundation, either version 3 of the License, or     *
  13                      ;; *  (at your option) any later version.                                   *
  14                      ;; *                                                                        *
  15                      ;; *  This program is distributed in the hope that it will be useful,       *
  16                      ;; *  but WITHOUT ANY WARRANTY; without even the implied warranty of        *
  17                      ;; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
  18                      ;; *  GNU General Public License for more details.                          *
  19                      ;; *                                                                        *
  20                      ;; *  You should have received a copy of the GNU General Public License     *
  21                      ;; *  along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  22                      ;; *                                                                        *
  23                      ;; *************************************************************************/
  24                     
  25                      
  26                     ;*****************************************************************************
  27 13a2 0000           physical_lba_lw			dw 0x0000
  28 13a4 0000           physical_lba_uw			dw 0x0000
  29                     ;*****************************************************************************
  30                     
  31                     ;*****************************************************************************
  32                     ;; Load physical LBA block.
  33                     ;*****************************************************************************
  34 13a6                load_physical_lba_block:
  35 13a6 af9f 141a          call   send_host_physical_lba
  36                     
  37 13aa 07c1 0100          mov    r1, 0x0100
  38 13ae 07c9 14ea          mov    r9, send_buffer
  39 13b2                @@:
  40 13b2 07c0 4000          mov    r0, 0x4000 ; Read byte from bus
  41 13b6 af9f 138e          call   hpi_mb_tx  ; Send read command
  42 13ba af9f 1398          call   hpi_mb_rx  ; Receive result
  43 13be 67c0 00ff          and    r0, 0x00FF
  44                     
  45 13c2 0002               mov    r2, r0
  46                         
  47 13c4 07c0 4000          mov    r0, 0x4000 ; Read byte from bus
  48 13c8 af9f 138e          call   hpi_mb_tx  ; Send read command
  49 13cc af9f 1398          call   hpi_mb_rx  ; Receive result
  50 13d0 67c0 00ff          and    r0, 0x00FF
  51 13d4 d3c0               shl    r0, 8
  52                     
  53 13d6 8002               or     r2, r0
  54                         
  55 13d8 00a1               mov    w[r9++], r2
  56 13da da01               dec    r1
  57 13dc c16a               jnz    @b
  58                     
  59 13de cf97               ret
  60                     ;*****************************************************************************
  61                     
  62                     
  63                     ;*****************************************************************************
  64                     ;; Save physical LBA block.
  65                     ;*****************************************************************************
  66 13e0                save_physical_lba_block:
  67 13e0 af9f 141a          call   send_host_physical_lba
  68                     
  69 13e4 07c1 0100          mov    r1, 0x0100
  70 13e8 07c9 18ea          mov    r9, block_receive_buffer
  71 13ec                @@:
  72 13ec 0842               mov    r2, w[r9++]
  73                     
  74 13ee 0080               mov    r0, r2
  75 13f0 67c0 00ff          and    r0, 0x00FF
  76 13f4 87c0 8000          or     r0, 0x8000 ; Write byte to bus
  77 13f8 af9f 138e          call   hpi_mb_tx  ; Send write command
  78 13fc af9f 1398          call   hpi_mb_rx  ; Receive confirmation
  79                     
  80 1400 0080               mov    r0, r2
  81 1402 d1c0               shr    r0, 8
  82 1404 67c0 00ff          and    r0, 0x00FF
  83 1408 87c0 8000          or     r0, 0x8000 ; Write byte to bus
  84 140c af9f 138e          call   hpi_mb_tx  ; Send write command
  85 1410 af9f 1398          call   hpi_mb_rx  ; Receive confirmation
  86                         
  87 1414 da01               dec    r1
  88 1416 c16a               jnz    @b
  89 1418 cf97               ret    
  90                     ;*****************************************************************************
  91                     
  92                     
  93                     ;*****************************************************************************
  94                     ;; Set host's LBA registers.
  95                     ;*****************************************************************************
  96 141a                send_host_physical_lba:
  97                         ;; Send LBA[0]:
  98 141a 09c0 13a2          mov    r0, w[physical_lba_lw]
  99 141e 67c0 00ff          and    r0, 0xFF
 100 1422 af9f 138e          call   hpi_mb_tx
 101                         ;; Send LBA[1]:
 102 1426 09c0 13a2          mov    r0, w[physical_lba_lw]
 103 142a d1c0               shr    r0, 8
 104 142c 67c0 00ff          and    r0, 0xFF
 105 1430 87c0 0100          or     r0, 0x100
 106 1434 af9f 138e          call   hpi_mb_tx
 107                         ;; Send LBA[2]:
 108 1438 09c0 13a4          mov    r0, w[physical_lba_uw]
 109 143c d1c0               shr    r0, 8
 110 143e 67c0 00ff          and    r0, 0xFF
 111 1442 87c0 0200          or     r0, 0x200
 112 1446 af9f 138e          call   hpi_mb_tx
 113                         ;; Send LBA[3]:
 114 144a 09c0 13a4          mov    r0, w[physical_lba_uw]
 115 144e 67c0 00ff          and    r0, 0xFF
 116 1452 87c0 0300          or     r0, 0x300
 117 1456 af9f 138e          call   hpi_mb_tx
 118 145a cf97               ret
 119                     ;*****************************************************************************
 120                     
 121                     
 122                     ;; ;*****************************************************************************
 123                     ;; ;; Load physical LBA block.
 124                     ;; ;*****************************************************************************
 125                     ;; load_physical_lba_block:
 126                     ;;     call   send_host_physical_lba
 127                     
 128                     ;;     ;; right now, just a lame test.
 129                     ;;     mov    r1, 0x0080
 130                     ;;     mov    r9, send_buffer
 131                     ;; @@:
 132                     ;;     mov    w[r9++], w[physical_lba_lw]
 133                     ;;     mov    w[r9++], w[physical_lba_uw]
 134                     ;;     dec    r1
 135                     ;;     jnz    @b
 136                     ;;     ret
 137                     ;; ;*****************************************************************************
 138                     
 139                     ;; ;*****************************************************************************
 140                     ;; ;; Save physical LBA block.
 141                     ;; ;*****************************************************************************
 142                     ;; save_physical_lba_block:
 143                     ;;     call   send_host_physical_lba
 144                     
 145                     ;;     ;; right now, a test.
 146                     ;;     int    PUSHALL_INT
 147                     ;;     ;;-------------------------------------------
 148                     ;;     ;; See if expected values match:
 149                     ;;     mov    r1, 0x0080
 150                     ;;     mov    r9, block_receive_buffer
 151                     ;; @@:
 152                     ;;     mov    r0, w[r9++]
 153                     ;;     cmp    r0, w[physical_lba_lw]
 154                     ;;     jne    sad_block
 155                     ;;     mov    r2, w[r9++]
 156                     ;;     cmp    r2, w[physical_lba_uw]
 157                     ;;     jne    sad_block
 158                     ;;     dec    r1
 159                     ;;     jnz    @b
 160                     ;;     ;; all ok:
 161                     ;;     jmp    happy_block
 162                     ;; sad_block:
 163                     ;;     mov    w[Debug_LW], r0
 164                     ;;     mov    w[Debug_UW], r2
 165                     ;;     mov	   r0, 0x004E		; N
 166                     ;;     call   dbg_putchar
 167                     ;;     mov    w[Debug_Title], 0x42 ; B
 168                     ;;     call   dbg_print_32bit
 169                     ;;     mov	   r0, 0x0020		; [space]
 170                     ;;     call   dbg_putchar
 171                     ;;     mov	   r0, 0x004E		; N
 172                     ;;     call   dbg_putchar
 173                     ;;     mov	   r0, 0x004F		; O
 174                     ;;     call   dbg_putchar
 175                     ;;     ;; test
 176                     ;;     call   print_newline
 177                     ;;     mov    w[Debug_LW], w[physical_lba_lw]
 178                     ;;     mov    w[Debug_UW], 0x0000
 179                     ;;     mov    w[Debug_Title], 0x49 ; I
 180                     ;;     call   dbg_print_32bit
 181                     ;;     call   print_newline
 182                     ;;     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 183                     ;; happy_block:
 184                     ;;     ;; mov	   r0, 0x004F		; O
 185                     ;;     ;; call   dbg_putchar
 186                     ;;     ;; mov	   r0, 0x004B		; K
 187                     ;;     ;; call   dbg_putchar
 188                     ;; done_block:
 189                     ;;     ;;-------------------------------------------
 190                     ;;     int    POPALL_INT
 191                     ;;     ret
 192                     ;; ;*****************************************************************************
 193                     
 194                     

 138                     include scsi-state.asm

   0                      ;; /*************************************************************************
   1                      ;; *                     This file is part of Stierlitz:                    *
   2                      ;; *               https://github.com/asciilifeform/Stierlitz               *
   3                      ;; *************************************************************************/
   4                     
   5                      ;; /*************************************************************************
   6                      ;; *                (c) Copyright 2012 Stanislav Datskovskiy                *
   7                      ;; *                         http://www.loper-os.org                        *
   8                      ;; **************************************************************************
   9                      ;; *                                                                        *
  10                      ;; *  This program is free software: you can redistribute it and/or modify  *
  11                      ;; *  it under the terms of the GNU General Public License as published by  *
  12                      ;; *  the Free Software Foundation, either version 3 of the License, or     *
  13                      ;; *  (at your option) any later version.                                   *
  14                      ;; *                                                                        *
  15                      ;; *  This program is distributed in the hope that it will be useful,       *
  16                      ;; *  but WITHOUT ANY WARRANTY; without even the implied warranty of        *
  17                      ;; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
  18                      ;; *  GNU General Public License for more details.                          *
  19                      ;; *                                                                        *
  20                      ;; *  You should have received a copy of the GNU General Public License     *
  21                      ;; *  along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  22                      ;; *                                                                        *
  23                      ;; *************************************************************************/
  24                     
  25                     
  26                     ;*****************************************************************************
  27                     ;; SCSI State
  28                     ;*****************************************************************************
  29                     ;; sense key
  30 145c                SCSI_dw_sense:
  31 145c 0000           SCSI_dw_sense_lw		dw 0x0000
  32 145e 0000           SCSI_dw_sense_uw		dw 0x0000
  33                     
  34                     ;; hex: 00aabbcc, where aa=KEY, bb=ASC, cc=ASCQ
  35           0000145d  dwSense_KEY			EQU	(SCSI_dw_sense + 1)
  36           0000145e  dwSense_ASC			EQU	(SCSI_dw_sense + 2)
  37           0000145f  dwSense_ASCQ			EQU	(SCSI_dw_sense + 3)
  38                     
  39                     ;; state machine state
  40 1460                scsi_state:
  41 1460 00                 db				0x00
  42                     ;; Possible states:
  43           00000000  SCSI_state_CBW		EQU	0x00
  44           00000001  SCSI_state_data_out	EQU	0x01
  45           00000002  SCSI_state_data_in	EQU	0x02
  46           00000003  SCSI_state_CSW		EQU	0x03
  47           00000004  SCSI_state_stalled	EQU	0x04
  48                     ;*****************************************************************************
  49                     
  50                     ;*****************************************************************************
  51                     ;; SCSI Command Block Wrapper (received)
  52                     ;*****************************************************************************
  53           0000001f  CBW_Size			EQU	0x1F
  54           000016ea  MSC_CBW_Signature_lw		EQU	(receive_buffer)
  55           000016ec  MSC_CBW_Signature_uw		EQU	(receive_buffer + 2)
  56           000016ee  CBW_tag_lw			EQU	(receive_buffer + 4)
  57           000016f0  CBW_tag_uw			EQU	(receive_buffer + 6)
  58           000016f2  CBW_data_transfer_length_lw	EQU	(receive_buffer + 8)
  59           000016f4  CBW_data_transfer_length_uw	EQU	(receive_buffer + 10)
  60           000016f6  CBW_flags			EQU	(receive_buffer + 12)
  61           000016f7  CBW_lun				EQU	(receive_buffer + 13)
  62           000016f8  CBW_cb_length			EQU	(receive_buffer + 14)
  63           000016f9  CBW_cb				EQU	(receive_buffer + 15)
  64                     ;*****************************************************************************
  65                     
  66                     ;*****************************************************************************
  67                     ;; All SCSI Command CDBs
  68                     ;*****************************************************************************
  69           000016f9  Common_SCSI_CDB_op_code		EQU	(CBW_cb)
  70                     ;*****************************************************************************
  71                     
  72                     ;*****************************************************************************
  73                     ;; 'Inquiry' SCSI Command
  74                     ;*****************************************************************************
  75           000016fd  Inquiry_SCSI_CDB_bLength	EQU	(CBW_cb + 4)
  76                     ;*****************************************************************************
  77                     
  78                     ;*****************************************************************************
  79                     ;; 'Request Sense' SCSI Command
  80                     ;*****************************************************************************
  81           000016fd  Request_Sense_SCSI_CDB_bLength	EQU	(CBW_cb + 4)
  82                     ;*****************************************************************************
  83                     
  84                     ;*****************************************************************************
  85                     ;; 'Read-10' SCSI Command
  86                     ;*****************************************************************************
  87           000016fa  Read10_SCSI_CDB_LUN_etc		EQU	(CBW_cb + 1)
  88           000016fb  Read10_SCSI_CDB_LBA_3		EQU	(CBW_cb + 2)
  89           000016fc  Read10_SCSI_CDB_LBA_2		EQU	(CBW_cb + 3)
  90           000016fd  Read10_SCSI_CDB_LBA_1		EQU	(CBW_cb + 4)
  91           000016fe  Read10_SCSI_CDB_LBA_0		EQU	(CBW_cb + 5)
  92           00001700  Read10_SCSI_CDB_Transfer_Len_1	EQU	(CBW_cb + 7)
  93           00001701  Read10_SCSI_CDB_Transfer_Len_0	EQU	(CBW_cb + 8)
  94                     ;*****************************************************************************
  95                     
  96                     ;*****************************************************************************
  97                     ;; 'Write-10' SCSI Command
  98                     ;*****************************************************************************
  99           000016fa  Write10_SCSI_CDB_LUN_etc	EQU	(CBW_cb + 1)
 100           000016fb  Write10_SCSI_CDB_LBA_3		EQU	(CBW_cb + 2)
 101           000016fc  Write10_SCSI_CDB_LBA_2		EQU	(CBW_cb + 3)
 102           000016fd  Write10_SCSI_CDB_LBA_1		EQU	(CBW_cb + 4)
 103           000016fe  Write10_SCSI_CDB_LBA_0		EQU	(CBW_cb + 5)
 104           00001700  Write10_SCSI_CDB_Transfer_Len_1	EQU	(CBW_cb + 7)
 105           00001701  Write10_SCSI_CDB_Transfer_Len_0	EQU	(CBW_cb + 8)
 106                     ;*****************************************************************************
 107                     
 108                     ;*****************************************************************************
 109                     ;; SCSI Command Status Wrapper (to send to host)
 110                     ;*****************************************************************************
 111           0000000d  CSW_Size			EQU	13
 112           000014ea  MSC_CSW_Signature_lw		EQU	(send_buffer)
 113           000014ec  MSC_CSW_Signature_uw		EQU	(send_buffer + 2)
 114           000014ee  CSW_tag_lw			EQU	(send_buffer + 4)
 115           000014f0  CSW_tag_uw			EQU	(send_buffer + 6)
 116           000014f2  CSW_data_residue_lw		EQU	(send_buffer + 8)
 117           000014f4  CSW_data_residue_uw		EQU	(send_buffer + 10)
 118           000014f6  CSW_status			EQU	(send_buffer + 12)
 119                     ;*****************************************************************************
 120                     
 121                     ;*****************************************************************************
 122                     ;; Inquiry Response
 123                     ;*****************************************************************************
 124           0001      align 2
 125 1462                SCSI_inquiry_response:
 126 1462 00                 db		0x00		; Device = Direct Access
 127 1463 80                 db		0x80		; RMB = 1: Removable Medium
 128 1464 00                 db		0x00		; Standard Version = None
 129 1465 01                 db		0x01		; Data Format = unknown
 130 1466 20                 db		(INQ_ADD_LEN-4)	; Additional Length
 131 1467 00                 db		0x00		; Flags: nothing special
 132 1468 00                 db		0x00		; Flags: normal device, no extra features
 133 1469 00                 db		0x00		; Flags: no rel. addressing, sync. xmit, linked commands, or queuing
 134 146a 4c 6f 70 65 72     db          'Loper OS'	; Manufacturer ID (bytes 8..15)
          20 4f 53 
 135 1472 42 75 73 20 74     db		'Bus to Thumb Drv' ; Product ID (bytes 16..31)
          6f 20 54 68 75 
          6d 62 20 44 72 
          76 
 136 1482 31 2e 30 30        db		'1.00'		; Product Revision Level (Bytes 32..35)
 137           00000024      INQ_ADD_LEN equ ($-SCSI_inquiry_response)
 138                     ;*****************************************************************************

 139                     include descriptor.asm

   0                      ;; /*************************************************************************
   1                      ;; *                     This file is part of Stierlitz:                    *
   2                      ;; *               https://github.com/asciilifeform/Stierlitz               *
   3                      ;; *************************************************************************/
   4                     
   5                      ;; /*************************************************************************
   6                      ;; *                (c) Copyright 2012 Stanislav Datskovskiy                *
   7                      ;; *                         http://www.loper-os.org                        *
   8                      ;; **************************************************************************
   9                      ;; *                                                                        *
  10                      ;; *  This program is free software: you can redistribute it and/or modify  *
  11                      ;; *  it under the terms of the GNU General Public License as published by  *
  12                      ;; *  the Free Software Foundation, either version 3 of the License, or     *
  13                      ;; *  (at your option) any later version.                                   *
  14                      ;; *                                                                        *
  15                      ;; *  This program is distributed in the hope that it will be useful,       *
  16                      ;; *  but WITHOUT ANY WARRANTY; without even the implied warranty of        *
  17                      ;; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
  18                      ;; *  GNU General Public License for more details.                          *
  19                      ;; *                                                                        *
  20                      ;; *  You should have received a copy of the GNU General Public License     *
  21                      ;; *  along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  22                      ;; *                                                                        *
  23                      ;; *************************************************************************/
  24                     
  25                     
  26                     ;*****************************************************************************
  27                     ; EZ-Host/EZ-OTG device descriptor
  28                     ;*****************************************************************************
  29 1486                dev_desc:
  30 1486 12                   db 0x12       ; bLength
  31 1487 01                   db 0x01       ; bDescriptorType
  32 1488 0110                 dw USB_VER    ; bcdUSB
  33 148a 00                   db 0x00       ; bDeviceClass
  34 148b 00                   db 0x00       ; bDeviceSubClass
  35 148c 00                   db 0x00       ; bDeviceProtocol
  36 148d 40                   db 0x40       ; bMaxPacketSize0
  37 148e 08ec                 dw VENDOR_ID  ; idVendor
  38 1490 0020                 dw PRODUCT_ID ; idProduct
  39 1492 0001                 dw FW_REV     ; bcdDevice
  40 1494 01                   db 1          ; iManufacturer (index of manufacture string)
  41 1495 02                   db 2          ; iProduct (index of product string)
  42 1496 03                   db 3          ; iSerialNumber (index of serial number string)
  43 1497 01                   db 1          ; bNumConfigurations (number of configurations)
  44                     ;****************************************************************
  45                     ; EZ-Host/EZ-OTG configuration descriptor
  46                     ;****************************************************************
  47 1498                conf_desc:
  48           00000000  bLength             equ ($-conf_desc)
  49 1498 09                   db 9          ; len of config
  50           00000001  bDescriptorType     equ ($-conf_desc)
  51 1499 02                   db 2          ; type of config
  52           00000002  wTotalLength        equ ($-conf_desc)
  53 149a 0020                 dw (end_all-conf_desc)
  54           00000004  bNumInterfaces      equ ($-conf_desc)
  55 149c 01                   db 1          ; one interface
  56           00000005  bConfigurationValue equ ($-conf_desc)
  57 149d 01                   db 1          ; config #1
  58           00000006  iConfiguration      equ ($-conf_desc)
  59 149e 00                   db 0          ; index of string describing config
  60           00000007  bmAttributes        equ ($-conf_desc)
  61 149f 80                   db 0x80       ; attributes (self powered)
  62           00000008  MaxPower            equ ($-conf_desc)
  63 14a0 32                   db 50
  64                     ;****************************************************************
  65                     ; Interface Descriptor
  66                     ;****************************************************************
  67 14a1                interface_desc:
  68 14a1 09                   db 9
  69 14a2 04                   db 4
  70           00000002  bInterfaceNumber    equ ($-interface_desc)
  71 14a3 00                   db 0          ; base #
  72           00000003  bAlternateSetting   equ ($-interface_desc)
  73 14a4 00                   db 0          ; alt
  74           00000004  bNumEndpoints       equ ($-interface_desc)
  75 14a5 02                   db 2          ; 2 endpoints
  76           00000005  bInterfaceClass     equ ($-interface_desc)
  77 14a6 08                   db 0x08       ; interface class (Mass Storage)
  78           00000006  bInterfaceSubClass  equ ($-interface_desc)
  79 14a7 06                   db 0x06       ; subclass (SCSI)
  80           00000007  bInterfaceProtocol  equ ($-interface_desc)
  81 14a8 50                   db 0x50       ; interface proto (Bulk-Only Transport)
  82           00000008  iInterface          equ ($-interface_desc)
  83 14a9 00                   db 0          ; index of string describing interface
  84           00000009  INTERFACE_DESC_LEN equ ($-interface_desc)
  85                     ;****************************************************************
  86                     ; EZ-Host/EZ-OTG endpoints descriptor
  87                     ;****************************************************************
  88                     ;; --------------------------------------------------
  89 14aa 07             ep1:  db 0x07       ; len
  90 14ab 05                   db 0x05       ; type (endpoint)
  91 14ac 81                   db EP_IN_ADDR ; bEndpointAddress (EP 1 IN)
  92 14ad 02                   db 0x02	    ; bmAttributes = Bulk
  93 14ae 0040                 dw USB_PACKET_SIZE ; packet size = 64 bytes
  94 14b0 00                   db EP_IN_BINTERVAL ; bInterval
  95                     ;; --------------------------------------------------
  96 14b1 07             ep2:  db 0x07       ; len
  97 14b2 05                   db 0x05       ; type (endpoint)
  98 14b3 02                   db EP_OUT_ADDR ; bEndpointAddress (EP 2 OUT)
  99 14b4 02                   db 0x02       ; bmAttributes = Bulk
 100 14b5 0040                 dw USB_PACKET_SIZE ; packet size = 64 bytes
 101 14b7 00                   db EP_OUT_BINTERVAL ; bInterval
 102                     ;; --------------------------------------------------
 103 14b8                end_all:
 104           0000            align 2
 105                     ;================================================
 106                     ; String: Require the string must be align 2
 107                     ;================================================
 108                     ;;-----------------------------------------------
 109 14b8                string_desc:
 110 14b8 04                   db STR0_LEN
 111 14b9 03                   db 3
 112 14ba 0409                 dw 0x409     ; language id = English
 113           00000004  STR0_LEN equ ($-string_desc)
 114                     ;;-----------------------------------------------
 115 14bc                str1:
 116 14bc 12                   db STR1_LEN
 117 14bd 03                   db 3
 118 14be 004c 006f 0070       dw 'Loper OS'
          0065 0072 0020 
          004f 0053 
 119           00000012  STR1_LEN equ ($-str1)
 120                     ;;-----------------------------------------------
 121 14ce 14             str2: db STR2_LEN
 122 14cf 03                   db 3
 123 14d0 0053 0074 0069       dw 'Stierlitz'
          0065 0072 006c 
          0069 0074 007a 

 124           00000014  STR2_LEN equ ($-str2)
 125                     ;;-----------------------------------------------
 126 14e2 08             str3: db STR3_LEN
 127 14e3 03                   db 3
 128 14e4 0033 0030 0030       dw '300'
 129           00000008  STR3_LEN equ ($-str3)
 130                     ;;-----------------------------------------------
 131           0000            align 2

 140                     include fat16.asm

   0                      ;; /*************************************************************************
   1                      ;; *                     This file is part of Stierlitz:                    *
   2                      ;; *               https://github.com/asciilifeform/Stierlitz               *
   3                      ;; *************************************************************************/
   4                     
   5                      ;; /*************************************************************************
   6                      ;; *                (c) Copyright 2012 Stanislav Datskovskiy                *
   7                      ;; *                         http://www.loper-os.org                        *
   8                      ;; **************************************************************************
   9                      ;; *                                                                        *
  10                      ;; *  This program is free software: you can redistribute it and/or modify  *
  11                      ;; *  it under the terms of the GNU General Public License as published by  *
  12                      ;; *  the Free Software Foundation, either version 3 of the License, or     *
  13                      ;; *  (at your option) any later version.                                   *
  14                      ;; *                                                                        *
  15                      ;; *  This program is distributed in the hope that it will be useful,       *
  16                      ;; *  but WITHOUT ANY WARRANTY; without even the implied warranty of        *
  17                      ;; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
  18                      ;; *  GNU General Public License for more details.                          *
  19                      ;; *                                                                        *
  20                      ;; *  You should have received a copy of the GNU General Public License     *
  21                      ;; *  along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  22                      ;; *                                                                        *
  23                      ;; *************************************************************************/
  24                     
  25                     
  26                     ;*****************************************************************************
  27                     ;; Derived partition constants
  28                     ;*****************************************************************************
  29           00000000  MBR_BLOCK_LBA_UW			equ     0x0000
  30           00000000  MBR_BLOCK_LBA_LW			equ     0x0000
  31           00000000  FAT16_BOOT_BLOCK_LBA_UW			equ	PART0_START_LBA_UW
  32           0000003f  FAT16_BOOT_BLOCK_LBA_LW			equ	PART0_START_LBA_LW
  33           00000000  FAT16_FAT_TABLES_BLOCK_LBA_UW		equ	0x0000 ; Forget about upper word... Because QTASM is retarded.
  34           00000040  FAT16_FAT_TABLES_BLOCK_LBA_LW		equ	((FAT16_BOOT_BLOCK_LBA_LW) + 1)
  35           00000000  FAT16_FAT_TABLES_COPY_BLOCK_LBA_UW	equ     0x0000
  36           0000013f  FAT16_FAT_TABLES_COPY_BLOCK_LBA_LW	equ     (FAT16_FAT_TABLES_BLOCK_LBA_LW + FAT16_PART0_SECTORS_PER_FAT)
  37           00000000  FAT16_ROOT_DIRECTORY_ENTRY_LBA_UW	equ     0x0000
  38           0000023e  FAT16_ROOT_DIRECTORY_ENTRY_LBA_LW	equ     (FAT16_FAT_TABLES_BLOCK_LBA_LW + ((FAT16_PART0_SECTORS_PER_FAT) * 2))
  39                     
  40           00000000  FAT16_DATA_AREA_LBA_UW			equ	0x0000
  41           0000025e  FAT16_DATA_AREA_LBA_LW			equ	(FAT16_ROOT_DIRECTORY_ENTRY_LBA_LW + ((FAT16_PART0_MAX_ROOT_DIR_ENTRIES * 32) / BLOCKSIZE))
  42                     
  43                     ;; Now, this is because 64 blocks are taken up by Cluster 0 (reserved)
  44           00000000  FAT16_DATA_AREA_LBA_UW_EFFECTIVE_BOTTOM	equ	0x0000
  45           0000029e  FAT16_DATA_AREA_LBA_LW_EFFECTIVE_BOTTOM equ	(FAT16_DATA_AREA_LBA_LW + 64)
  46                     
  47           00000004  FIRST_CLUSTER_INDEX			equ	0x0004
  48                     ;*****************************************************************************
  49                     
  50                     
  51                     ;*****************************************************************************
  52                     ;; Partition Format
  53                     ;*****************************************************************************
  54           ffffaa55  BOOT_SIGNATURE				equ	0xaa55 ; for both boot block and MBA
  55                     ;; Partition Record in MBR
  56           000016a8  PART0_MBR_RECORD_OFFSET			equ     (send_buffer + 0x01BE)
  57           000016e8  BOOT_SIGNATURE_OFFSET			equ	(send_buffer + 0x01fe)
  58           fffff6f6  FAT16_BOOT_BLOCK_FILLER			equ	0xf6f6  ; how MSDOS did it
  59                     ;*****************************************************************************
  60                     
  61                     
  62                     ;*****************************************************************************
  63                     ;; Partition Data (2GB - maximum for FAT16.)
  64                     ;*****************************************************************************
  65                     ;; Fields:
  66           00000000  PART0_STATUS				equ	  0x00 ;  0:  P0 status (0x00 = non-bootable, 0x80 = bootable)
  67           00000001  PART0_START_HEAD			equ	  0x01 ;  1: Start CHS: Head
  68           00000001  PART0_START_SECT_76CYLHIGH		equ	  0x01 ;  2: Start CHS: Sector in bits 5..0; bits 7..6 are high bits of Cylinder
  69           00000000  PART0_START_CYL				equ	  0x00 ;  3: Start CHS: Bits 7..0 of Cylinder
  70           0000000e  PART0_PARTITION_TYPE			equ	  0x0e ;  4: Partition Type
  71           0000007f  PART0_END_HEAD				equ	  0x7f ;  5: Ending CHS: Head
  72           000000bf  PART0_END_SECT_76CYLHIGH		equ	  0xbf ;  6: Ending CHS: Sector in bits 5..0; bits 7..6 are high bits of Cylinder
  73           00000005  PART0_END_CYL				equ	  0x05 ;  7: Ending CHS: Bits 7..0 of Cylinder
  74           00000000  PART0_START_LBA_UW			equ	0x0000 ; 11: Starting LBA: Upper Word
  75           0000003f  PART0_START_LBA_LW			equ	0x003f ;  8: Starting LBA: Lower Word
  76           0000003f  PART0_SECTORS_UW			equ	0x003f ; 14: Size in sectors
  77           ffffbcc1  PART0_SECTORS_LW			equ	0xbcc1 ; 12: Size in sectors
  78                     
  79                     ;; Our partition parameters
  80           00000200  FAT16_PART0_BYTES_PER_SECTOR		equ	0x0200 ; Bytes per sector
  81           00000040  FAT16_PART0_SECTORS_PER_CLUSTER		equ	  0x40 ; Sectors per cluster
  82           00000001  FAT16_PART0_RESERVED_SECTORS		equ	0x0001 ; Reserved sectors
  83           00000002  FAT16_PART0_COPIES_OF_FAT		equ	  0x02 ; # of copies of FAT
  84           00000200  FAT16_PART0_MAX_ROOT_DIR_ENTRIES	equ	0x0200 ; Max root dir entries
  85           00000000  FAT16_PART0_MAX_SECTS_IF_UNDR_32M	equ	0x0000 ; # of sectors in part < 32MB
  86           000000f8  FAT16_PART0_MEDIA_DESCRIPTOR		equ	  0xf8 ; media descriptor
  87           000000ff  FAT16_PART0_SECTORS_PER_FAT		equ	0x00FF ; sectors per FAT
  88           0000003f  FAT16_PART0_SECTORS_PER_TRACK		equ	0x003f ; sectors per track
  89           00000080  FAT16_PART0_HEADS			equ	0x0080 ; # of heads
  90           00000080  FAT16_PART0_LOGICAL_DRIVE_NUMBER	equ	0x0080 ; Logical drive number of partition
  91           00000029  FAT16_PART0_EXTENDED_SIGNATURE		equ	  0x29 ; Extended signature - must equal 0x29
  92           00004f30  FAT16_PART0_PARTITION_SERIAL_NUM_UW	equ	0x4f30 ; Serial number of partition (B1)
  93           00005f7b  FAT16_PART0_PARTITION_SERIAL_NUM_LW	equ	0x5f7b ; Serial number of partition (B0)
  94                     
  95                     ;*****************************************************************************

 141                     ;*****************************************************************************
 142                     ;; Buffers
 143           0000      align 2
 144                     
 145 14ea                send_buffer			dup 512
 146 16ea                receive_buffer			dup 512
 147 18ea                block_receive_buffer		dup 512
 148                     ;*****************************************************************************
 149                     
 150                     ;*****************************************************************************
 151 1aea                rom_end:
 152 1aea c3b6               dw     SCAN_SIGNATURE       ; signature 
 153 1aec 0002               dw	   2                    ; length
 154 1aee 05                 db     5                    ; jump opcode
 155 1aef 0500               dw     ORIGIN               ; Jump to BIOS Start in RAM
 156 1af1 00                 db 	   0                    ; end scan
 157                     ;*****************************************************************************
 158                     ;*****************************************************************************
 159                     ;*****************************************************************************
 160                     ;*****************************************************************************
Total Passes = 6
