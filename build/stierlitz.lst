QTASM rev 1.18x
   0                     ;; /**************************************************************************
   1                     ;;  *                                                                        *
   2                     ;;  *                               "Stierlitz"                              *
   3                     ;;  *                     Bus Munger as USB Mass Storage                     *
   4                     ;;  *                                                                        *
   5                     ;;  *************************************************************************/
   6                     
   7                     ;;  /*************************************************************************
   8                     ;;  *                (c) Copyright 2012 Stanislav Datskovskiy                *
   9                     ;;  *                         http://www.loper-os.org                        *
  10                     ;;  **************************************************************************
  11                     ;;  *                                                                        *
  12                     ;;  *  This program is free software: you can redistribute it and/or modify  *
  13                     ;;  *  it under the terms of the GNU General Public License as published by  *
  14                     ;;  *  the Free Software Foundation, either version 3 of the License, or     *
  15                     ;;  *  (at your option) any later version.                                   *
  16                     ;;  *                                                                        *
  17                     ;;  *  This program is distributed in the hope that it will be useful,       *
  18                     ;;  *  but WITHOUT ANY WARRANTY; without even the implied warranty of        *
  19                     ;;  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
  20                     ;;  *  GNU General Public License for more details.                          *
  21                     ;;  *                                                                        *
  22                     ;;  *  You should have received a copy of the GNU General Public License     *
  23                     ;;  *  along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  24                     ;;  *                                                                        *
  25                     ;;  *************************************************************************/
  26                     
  27                     ;*****************************************************************************
  28                     include knobs.asm

   0                      ;; /*************************************************************************
   1                      ;; *                     This file is part of Stierlitz:                    *
   2                      ;; *               https://github.com/asciilifeform/Stierlitz               *
   3                      ;; *************************************************************************/
   4                     
   5                      ;; /*************************************************************************
   6                      ;; *                (c) Copyright 2012 Stanislav Datskovskiy                *
   7                      ;; *                         http://www.loper-os.org                        *
   8                      ;; **************************************************************************
   9                      ;; *                                                                        *
  10                      ;; *  This program is free software: you can redistribute it and/or modify  *
  11                      ;; *  it under the terms of the GNU General Public License as published by  *
  12                      ;; *  the Free Software Foundation, either version 3 of the License, or     *
  13                      ;; *  (at your option) any later version.                                   *
  14                      ;; *                                                                        *
  15                      ;; *  This program is distributed in the hope that it will be useful,       *
  16                      ;; *  but WITHOUT ANY WARRANTY; without even the implied warranty of        *
  17                      ;; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
  18                      ;; *  GNU General Public License for more details.                          *
  19                      ;; *                                                                        *
  20                      ;; *  You should have received a copy of the GNU General Public License     *
  21                      ;; *  along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  22                      ;; *                                                                        *
  23                      ;; *************************************************************************/
  24                     
  25                     ;*****************************************************************************
  26                     ;; Knobs
  27                     ;*****************************************************************************
  28                     
  29                     ;*****************************************************************************
  30                     ;; The Payload (Virtual File)
  31                     ;*****************************************************************************
  32                     ;; QTASM is Retarded...:
  33                     ;*****************************************************************************
  34                     
  35                     ;;;;;;;;;;;;; 1024 meg
  36                     ;; FILE_SIZE_LW		equ	0x0000
  37                     ;; FILE_SIZE_UW		equ	0x4000
  38                     ;; FILE_SIZE_IN_BLKS_LW	equ	0x0000
  39                     ;; FILE_SIZE_IN_BLKS_UW	equ	0x0020
  40                     ;; FAKE_FILE_CLUSTERS	equ	32768
  41                     
  42                     ;;;;;;;;;;;;; 256 meg
  43                     ;; FILE_SIZE_LW		equ	0x0000
  44                     ;; FILE_SIZE_UW		equ	0x1000
  45                     ;; FILE_SIZE_IN_BLKS_LW	equ	0x0000
  46                     ;; FILE_SIZE_IN_BLKS_UW	equ	0x0008
  47                     ;; FAKE_FILE_CLUSTERS	equ	8192
  48                     
  49                     ;;;;;;;;;;;;; 1 meg
  50                     ;; FILE_SIZE_LW		equ	0x0000
  51                     ;; FILE_SIZE_UW		equ	0x0010
  52                     ;; FILE_SIZE_IN_BLKS_LW	equ	0x0800
  53                     ;; FILE_SIZE_IN_BLKS_UW	equ	0x0000
  54                     ;; FAKE_FILE_CLUSTERS	equ	32
  55                     
  56                     ;;;;;;;;;;;;; 128K
  57                     ;; FILE_SIZE_LW		equ	0x0000
  58                     ;; FILE_SIZE_UW		equ	0x0002
  59                     ;; FILE_SIZE_IN_BLKS_LW	equ	0x0100
  60                     ;; FILE_SIZE_IN_BLKS_UW	equ	0x0000
  61                     ;; FAKE_FILE_CLUSTERS	equ	4
  62                     
  63                     ;;;;;;;;;;;; BPI 8.9 meg (9232444)
  64           ffffe03c  FILE_SIZE_LW		equ	0xE03C
  65           0000008c  FILE_SIZE_UW		equ	0x008C
  66           00004671  FILE_SIZE_IN_BLKS_LW	equ	0x4671
  67           00000000  FILE_SIZE_IN_BLKS_UW	equ	0x0000
  68           0000011a  FAKE_FILE_CLUSTERS	equ	282
  69                     
  70                     ;;;;;;;;;;;; I2C 16 k (16384)
  71           00004000  FILE2_SIZE_LW		equ	0x4000
  72           00000000  FILE2_SIZE_UW		equ	0x0000
  73           00000020  FILE2_SIZE_IN_BLKS_LW	equ	0x0020
  74           00000000  FILE2_SIZE_IN_BLKS_UW	equ	0x0000
  75           00000001  FAKE_FILE2_CLUSTERS	equ	1
  76           0000011d  FILE2_CLUSTER_START_LW  equ     (3+FAKE_FILE_CLUSTERS)
  77                     
  78                     ;;;;;;;;;;;; CY16 512 (512)
  79           00000200  FILE3_SIZE_LW		equ	0x0200
  80           00000000  FILE3_SIZE_UW		equ	0x0000
  81           00000001  FILE3_SIZE_IN_BLKS_LW	equ	0x0001
  82           00000000  FILE3_SIZE_IN_BLKS_UW	equ	0x0000
  83           00000001  FAKE_FILE3_CLUSTERS	equ	1
  84           0000011e  FILE3_CLUSTER_START_LW  equ     (3+FAKE_FILE_CLUSTERS+FAKE_FILE2_CLUSTERS)
  85                     
  86                     ;;;;;;;;;;;; ICAP 512 (512)
  87           00000200  FILE4_SIZE_LW		equ	0x0200
  88           00000000  FILE4_SIZE_UW		equ	0x0000
  89           00000001  FILE4_SIZE_IN_BLKS_LW	equ	0x0001
  90           00000000  FILE4_SIZE_IN_BLKS_UW	equ	0x0000
  91           00000001  FAKE_FILE4_CLUSTERS	equ	1
  92           0000011f  FILE4_CLUSTER_START_LW  equ     (3+FAKE_FILE_CLUSTERS+FAKE_FILE2_CLUSTERS+FAKE_FILE4_CLUSTERS)
  93                     
  94                     ;*****************************************************************************
  95                     
  96                     
  97                     ;*****************************************************************************
  98                     ;; Other: no need to change these much
  99                     ;*****************************************************************************
 100           00000001  FW_REV      		equ 	0x1       ; Firmware revision
 101           000008ec  VENDOR_ID   		equ 	0x08EC    ; "M-Systems Flash Disk"
 102           00000020  PRODUCT_ID  		equ 	0x0020    ; "TravelDrive"
 103                     
 104           ffffffff  MAXBLOCK		equ	4194303 ; Index of last block (NOT block count!)
 105                     
 106                     ;; Because QTASM is braindead:
 107           00000000  MAXBLOCK_3		equ	0x00
 108           0000003f  MAXBLOCK_2		equ	0x3F
 109           000000ff  MAXBLOCK_1		equ	0xFF
 110           000000ff  MAXBLOCK_0		equ	0xFF
 111                     ;*****************************************************************************
 112                     
 113                     
 114                     ;*****************************************************************************
 115                     ;; Really shouldn't change this
 116                     ;*****************************************************************************
 117           00000110  USB_VER			equ     0x0110 ; 0x0110 for USB 1.1; 0x0200 for USB 2.0
 118                     ;; Endpoints:
 119           00000001  EP_IN			equ	0x01 ; 0x81 (ep1)
 120           00000002  EP_OUT			equ	0x02 ; 0x02 (ep2)
 121                     
 122           00000081  EP_IN_ADDR		equ	0x81
 123           00000002  EP_OUT_ADDR		equ	0x02
 124           00000040  USB_PACKET_SIZE		equ     0x0040 ; 64 bytes
 125           00000000  EP_IN_BINTERVAL		equ	0x00
 126           00000000  EP_OUT_BINTERVAL	equ	0x00
 127                     ;*****************************************************************************

  29                     ;*****************************************************************************
  30                     
  31           00000500  ORIGIN equ 0x500
  32                     
  33                     .xlist
  36                     .list
  37                     
  38                     ;*****************************************************************************
  39                     .code
  40 04f0                    org    (ORIGIN - 16)
  41 04f0 c3b6               dw     SCAN_SIGNATURE    ; dummy signature to align the structure
  42 04f2 0004               dw	   4                 ; length
  43 04f4 00                 db     0                 ; COPY opcode
  44 04f5 e000               dw     IROM_BEGIN        ; mov [0xe000],0 - dummy write for alignment
  45 04f7 0000               dw     0
  46 04f9 c3b6               dw     SCAN_SIGNATURE    ; copy data to ORIGIN
  47 04fb 18aa               dw     ((rom_end-rom_start)+2) ; length
  48 04fd 00                 db     0
  49 04fe 0500               dw     ORIGIN            ; Copy Destination
  50           00000000      reloc  ORIGIN            ; Relocate to this symbol
  51                     ;*****************************************************************************
  52 0500                rom_start:
  53 0500 cf9f 06a2          jmp	   init_code
  54                     ;*****************************************************************************
  55                     
  56                     
  57                     
  58                     include debug.asm ;; RS-232 Debugger

   0                      ;; /*************************************************************************
   1                      ;; *                     This file is part of Stierlitz:                    *
   2                      ;; *               https://github.com/asciilifeform/Stierlitz               *
   3                      ;; *************************************************************************/
   4                     
   5                      ;; /*************************************************************************
   6                      ;; *                (c) Copyright 2012 Stanislav Datskovskiy                *
   7                      ;; *                         http://www.loper-os.org                        *
   8                      ;; **************************************************************************
   9                      ;; *                                                                        *
  10                      ;; *  This program is free software: you can redistribute it and/or modify  *
  11                      ;; *  it under the terms of the GNU General Public License as published by  *
  12                      ;; *  the Free Software Foundation, either version 3 of the License, or     *
  13                      ;; *  (at your option) any later version.                                   *
  14                      ;; *                                                                        *
  15                      ;; *  This program is distributed in the hope that it will be useful,       *
  16                      ;; *  but WITHOUT ANY WARRANTY; without even the implied warranty of        *
  17                      ;; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
  18                      ;; *  GNU General Public License for more details.                          *
  19                      ;; *                                                                        *
  20                      ;; *  You should have received a copy of the GNU General Public License     *
  21                      ;; *  along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  22                      ;; *                                                                        *
  23                      ;; *************************************************************************/
  24                     
  25                     
  26                     ;*****************************************************************************
  27                     ;; RS-232 debugger
  28                     ;*****************************************************************************
  29 0504                dbg_enable:
  30 0504 0017               push   r0
  31 0506 07c0 000d          mov    r0, 13		; 9600 baud
  32 050a af75               int    KBHIT_INT
  33 050c 05c0               pop    r0
  34 050e cf97               ret
  35                     ;*****************************************************************************
  36 0510                dbg_putchar:
  37 0510 0097               push   r2
  38 0512 0017               push   r0
  39 0514 67c0 00ff          and    r0, 0xFF
  40 0518 0002               mov    r2, r0
  41 051a 07c0 0001          mov    r0, 1      ; write to the UART
  42 051e af42               int    UART_INT   ; call UART_INT
  43 0520 05c0               pop    r0
  44 0522 05c2               pop    r2
  45 0524 cf97               ret
  46                     ;*****************************************************************************
  47 0526                dbg_getchar:
  48 0526 9000               xor    r0, r0     ;R0 = read data from the keyboard
  49 0528 af42               int    UART_INT   ;call UART_INT
  50 052a cf97               ret    	      ;return character in R0
  51                     ;*****************************************************************************
  52 052c                dbg_dump_tx_buffer:
  53 052c af49               int    PUSHALL_INT
  54 052e af9f 05d4          call   print_newline
  55 0532 07c0 0054          mov    r0, 0x0054		; 'T'
  56 0536 af9f 0510          call   dbg_putchar
  57 053a 07c0 0058          mov    r0, 0x0058		; 'X'
  58 053e af9f 0510          call   dbg_putchar
  59 0542 af9f 05d4          call   print_newline
  60 0546 07c8 17a8          mov    r8, send_buffer	; address of buffer
  61 054a 07c9 0040          mov    r9, 64		; number of bytes to print
  62 054e af9f 0580          call   dbg_dump_buffer
  63 0552 af4a               int    POPALL_INT
  64 0554 cf97               ret
  65                     ;*****************************************************************************
  66 0556                dbg_dump_rx_buffer:
  67 0556 af49               int    PUSHALL_INT
  68 0558 af9f 05d4          call   print_newline
  69 055c 07c0 0052          mov    r0, 0x0052		; 'R'
  70 0560 af9f 0510          call   dbg_putchar
  71 0564 07c0 0058          mov    r0, 0x0058		; 'X'
  72 0568 af9f 0510          call   dbg_putchar
  73 056c af9f 05d4          call   print_newline
  74 0570 07c8 19a8          mov    r8, receive_buffer	; address of buffer
  75 0574 07c9 0040          mov    r9, 64		; number of bytes to print
  76 0578 af9f 0580          call   dbg_dump_buffer
  77 057c af4a               int    POPALL_INT
  78 057e cf97               ret
  79                     ;*****************************************************************************
  80 0580                dbg_dump_buffer:
  81 0580 90c3               xor    r3, r3
  82 0582                print_byte:
  83 0582 9041               xor    r1, r1
  84 0584 d803               addi   r3, 1
  85 0586 0601               mov    r1, b[r8] 		; get byte from buffer
  86 0588 af9f 05a8          call   print_hex_byte	; print byte as hex
  87 058c d808               addi   r8, 1
  88 058e 07c0 0020          mov    r0, 0x0020
  89 0592 af9f 0510          call   dbg_putchar 		; print space between byte values:
  90 0596 00c4               mov    r4, r3
  91 0598 67c4 000f          and    r4, 0x0F		; every 16 bytes
  92 059c c102               jnz    @f
  93 059e af9f 05d4          call   print_newline 	; print possible EOL
  94 05a2                @@:
  95 05a2 da09               dec    r9
  96 05a4 c16e               jnz    print_byte
  97 05a6 cf97               ret
  98                     ;*****************************************************************************
  99 05a8                print_hex_byte:			; in r1
 100 05a8 67c1 00ff          and    r1, 0xFF
 101 05ac 0040               mov    r0, r1
 102 05ae d0c0               shr    r0, 4
 103 05b0 af9f 05bc          call   print_hex_digit 	; print upper nibble:
 104 05b4 0040               mov    r0, r1
 105 05b6 af9f 05bc          call   print_hex_digit	; print lower nibble:
 106 05ba cf97               ret
 107 05bc                print_hex_digit:
 108 05bc 67c0 000f          and    r0, 0x000F
 109 05c0 57c0 0009          cmp    r0, 0x0009
 110 05c4 c902               jbe    @f
 111 05c6 17c0 0007          add    r0, 0x07
 112 05ca                @@:
 113 05ca 17c0 0030          add    r0, 0x30
 114 05ce af9f 0510          call   dbg_putchar
 115 05d2 cf97               ret
 116                     ;*****************************************************************************
 117 05d4                print_newline:
 118 05d4 0017               push   r0
 119 05d6 07c0 000d          mov    r0, 0x0D
 120 05da af9f 0510          call   dbg_putchar
 121 05de 07c0 000a          mov    r0, 0x0A
 122 05e2 af9f 0510          call   dbg_putchar
 123 05e6 05c0               pop    r0
 124 05e8 cf97               ret
 125                     ;*****************************************************************************
 126                     ;; Title char in Debug_Title; Word in {Debug_UW, Debug_LW}
 127 05ea 0000           Debug_Title	dw	0x0000
 128 05ec 0000           Debug_LW	dw	0x0000
 129 05ee 0000           Debug_UW	dw	0x0000
 130                     ;*****************************************************************************
 131 05f0                dbg_print_32bit:
 132 05f0 af49               int    PUSHALL_INT
 133 05f2 09c0 05ea          mov	   r0, w[Debug_Title]
 134 05f6 af9f 0510          call   dbg_putchar
 135 05fa 07c0 003d          mov	   r0, 0x003D		; =
 136 05fe af9f 0510          call   dbg_putchar
 137 0602 09c1 05ee          mov    r1, w[Debug_UW]
 138 0606 d1c1               shr    r1, 8
 139 0608 67c1 00ff          and    r1, 0xFF
 140 060c af9f 05a8          call   print_hex_byte
 141 0610 09c1 05ee          mov    r1, w[Debug_UW]
 142 0614 67c1 00ff          and    r1, 0xFF
 143 0618 af9f 05a8          call   print_hex_byte
 144 061c 09c1 05ec          mov    r1, w[Debug_LW]
 145 0620 d1c1               shr    r1, 8
 146 0622 67c1 00ff          and    r1, 0xFF
 147 0626 af9f 05a8          call   print_hex_byte
 148 062a 09c1 05ec          mov    r1, w[Debug_LW]
 149 062e 67c1 00ff          and    r1, 0xFF
 150 0632 af9f 05a8          call   print_hex_byte
 151 0636 af4a               int    POPALL_INT
 152 0638 cf97               ret
 153                     ;*****************************************************************************
 154 063a                dbg_printspace:
 155 063a 07c0 0020          mov    r0, 0x0020
 156 063e af9f 0510          call   dbg_putchar 		; print space between byte values:
 157 0642 cf97               ret
 158                     ;*****************************************************************************
 159                     ;; Print current block index:
 160                     ;*****************************************************************************
 161 0644                dbg_print_read_block_index:
 162 0644 af49               int    PUSHALL_INT
 163 0646 07c0 0052          mov	   r0, 0x0052		; R
 164 064a cf03               jmp    @f
 165 064c                dbg_print_write_block_index:
 166 064c af49               int    PUSHALL_INT
 167 064e 07c0 0057          mov	   r0, 0x0057		; W
 168 0652                @@:
 169 0652 af9f 0510          call   dbg_putchar
 170 0656 07c0 0042          mov	   r0, 0x0042		; B
 171 065a af9f 0510          call   dbg_putchar   
 172 065e 07c0 003d          mov	   r0, 0x003D		; =
 173 0662 af9f 0510          call   dbg_putchar
 174                         ;; print actual LBA index:
 175 0666 09c1 1280          mov    r1, w[actual_lba_uw]
 176 066a d1c1               shr    r1, 8
 177 066c 67c1 00ff          and    r1, 0xFF
 178 0670 af9f 05a8          call   print_hex_byte
 179 0674 09c1 1280          mov    r1, w[actual_lba_uw]
 180 0678 67c1 00ff          and    r1, 0xFF
 181 067c af9f 05a8          call   print_hex_byte
 182 0680 09c1 127e          mov    r1, w[actual_lba_lw]
 183 0684 d1c1               shr    r1, 8
 184 0686 67c1 00ff          and    r1, 0xFF
 185 068a af9f 05a8          call   print_hex_byte
 186 068e 09c1 127e          mov    r1, w[actual_lba_lw]
 187 0692 67c1 00ff          and    r1, 0xFF
 188 0696 af9f 05a8          call   print_hex_byte
 189 069a af9f 05d4          call   print_newline
 190 069e af4a               int    POPALL_INT
 191 06a0 cf97               ret
 192                     ;*****************************************************************************

  59                     
  60                     
  61                     ;; TODO: enable watchdog timer?
  62                     
  63                     ;*****************************************************************************
  64                     ;*****************************************************************************
  65                     
  66                     ;*****************************************************************************
  67                     ;; Set up BIOS hooks.
  68                     ;*****************************************************************************
  69 06a2                init_code:
  70 06a2 af9f 0504          call   dbg_enable ; Enable RS-232 Debug Port.
  71                     
  72 06a6 af9f 0726          call   insert_vectors ; Overwrite stock ISRs
  73                     
  74                         ;; HPI
  75 06aa 07e7 0500 c01c     mov    w[GPIO_CNTRL], GIO_IntCtl_Mode_HPIbm ; Enable HPI pins
  76 06b0 87e7 0020 c00e     or     w[INT_EN_REG], bmINT_EN_MBX_OUT ; enable Mailbox OUT IRQ
  77 06b6 87e7 0040 c00e     or     w[INT_EN_REG], bmINT_EN_MBX_IN ; enable Mailbox IN IRQ
  78                         
  79                         ;;DEBUG;;
  80 06bc af9f 05d4          call   print_newline
  81 06c0 07c0 002a          mov	   r0, 0x002A		; *
  82 06c4 af9f 0510          call   dbg_putchar
  83                         ;;DEBUG;;
  84                         
  85                         ;; init:
  86 06c8 9041               xor    r1, r1		; full speed
  87 06ca 07c2 0002          mov    r2, 2		; SIE2
  88 06ce af71               int    SUSB_INIT_INT
  89                     
  90                         ;; enable idler:
  91 06d0 07ef 0000 06fa     mov    b[main_enable], 0x00 ; we want to enable self when configured
  92 06d6 07e7 06de 008e     mov    [(IDLER_INT*2)], aux_idler
  93 06dc cf97               ret
  94                     ;*****************************************************************************
  95                     
  96                     
  97                     ;*****************************************************************************
  98                     ;; Main Loop
  99                     ;*****************************************************************************
 100 06de                aux_idler:
 101 06de d84f               addi   r15, 2
 102 06e0 57ef 0000 06fc     cmp    b[main_lock], 0x00
 103 06e6 c108               jne    @f
 104 06e8 07ef 0001 06fc     mov    b[main_lock], 1
 105 06ee af9f 06fe          call   main_idler
 106 06f2 07ef 0000 06fc     mov    b[main_lock], 0
 107 06f8                @@:
 108 06f8 af47               int    IDLER_INT
 109                     ;*****************************************************************************
 110                     
 111                     
 112                     ;*****************************************************************************
 113 06fa 0000           main_enable			dw 0x0000
 114 06fc 0000           main_lock			dw 0x0000
 115           0000      align 2
 116                     ;*****************************************************************************
 117 06fe                main_idler:
 118 06fe af9f 0b98          call   bios_idle
 119 0702 57ef 0000 06fa     cmp    b[main_enable], 0 	; global enable toggled by delta_config
 120 0708 c07a               je     main_idler		; if disabled, skip MSC routines
 121 070a af9f 0970          call   usb_host_to_dev_handler ; handle any input from host
 122 070e af9f 0ac2          call   usb_dev_to_host_handler ; handle any output to host
 123 0712 cf75               jmp    main_idler
 124                     ;*****************************************************************************
 125                     
 126                     
 127           0000      align 2
 128                     ;*****************************************************************************
 129                     include usbstd.asm

   0                      ;; /*************************************************************************
   1                      ;; *                     This file is part of Stierlitz:                    *
   2                      ;; *               https://github.com/asciilifeform/Stierlitz               *
   3                      ;; *************************************************************************/
   4                     
   5                      ;; /*************************************************************************
   6                      ;; *                (c) Copyright 2012 Stanislav Datskovskiy                *
   7                      ;; *                         http://www.loper-os.org                        *
   8                      ;; **************************************************************************
   9                      ;; *                                                                        *
  10                      ;; *  This program is free software: you can redistribute it and/or modify  *
  11                      ;; *  it under the terms of the GNU General Public License as published by  *
  12                      ;; *  the Free Software Foundation, either version 3 of the License, or     *
  13                      ;; *  (at your option) any later version.                                   *
  14                      ;; *                                                                        *
  15                      ;; *  This program is distributed in the hope that it will be useful,       *
  16                      ;; *  but WITHOUT ANY WARRANTY; without even the implied warranty of        *
  17                      ;; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
  18                      ;; *  GNU General Public License for more details.                          *
  19                      ;; *                                                                        *
  20                      ;; *  You should have received a copy of the GNU General Public License     *
  21                      ;; *  along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  22                      ;; *                                                                        *
  23                      ;; *************************************************************************/
  24                     
  25                     ;*****************************************************************************
  26                     ;;;;;; Intercepts
  27                     ;*****************************************************************************
  28                     
  29                     ;;  /*************************************************************************
  30                     ;;  *     "We are what we pretend to be, so we must be careful about what    *
  31                     ;;  *      we pretend to be." (K. Vonnegut, "Mother Night")                  *
  32                     ;;  *************************************************************************/
  33                     
  34                     ;*****************************************************************************
  35                     ;; Replace stock vectors
  36                     ;*****************************************************************************
  37                     ;; save bios handlers here:
  38 0714 dead           bios_standard_usb_reset_handler dw	0xDEAD
  39 0716 dead           bios_standard_request_handler:	dw	0xDEAD
  40 0718 dead           bios_class_request_handler: 	dw	0xDEAD
  41 071a dead           bios_configuration_change:  	dw	0xDEAD
  42 071c dead           bios_idle_chain:  		dw	0xDEAD
  43 071e dead           bios_ep1_in_isr:    		dw	0xDEAD
  44 0720 dead           bios_ep2_out_isr:   		dw	0xDEAD
  45 0722 dead           bios_hpi_tx_isr:    		dw	0xDEAD
  46 0724 dead           bios_hpi_rx_isr:    		dw	0xDEAD
  47                     ;*****************************************************************************
  48 0726                insert_vectors:
  49                         ; Update USB reset handler.
  50 0726 09e7 0038 0714     mov    [bios_standard_usb_reset_handler], [SIE2_SLAVE_RESET_VEC]
  51 072c 07e7 07b6 0038     mov    [SIE2_SLAVE_RESET_VEC], my_standard_usb_reset_handler
  52                         ; Update BIOS SIE2 descriptor pointers.
  53 0732 07e7 1744 00d4     mov    [SUSB2_DEV_DESC_VEC], dev_desc
  54 0738 07e7 1756 00d6     mov    [SUSB2_CONFIG_DESC_VEC], conf_desc
  55 073e 07e7 1776 00d8     mov    [SUSB2_STRING_DESC_VEC], string_desc
  56                         ;; Back up BIOS handler locations
  57 0744 09e7 00c6 0716     mov    [bios_standard_request_handler], [(SUSB2_STANDARD_INT*2)]
  58 074a 09e7 00ce 0718     mov    [bios_class_request_handler], [(SUSB2_CLASS_INT*2)]
  59 0750 09e7 00de 071a     mov    [bios_configuration_change], [(SUSB2_DELTA_CONFIG_INT*2)]
  60                         ;; Overwrite BIOS handler locations with ours
  61 0756 07e7 0866 00c6     mov    [(SUSB2_STANDARD_INT*2)], my_standard_request_handler
  62 075c 07e7 0810 00ce     mov    [(SUSB2_CLASS_INT*2)], my_class_request_handler
  63 0762 07e7 086e 00de     mov    [(SUSB2_DELTA_CONFIG_INT*2)], my_configuration_change
  64                         ;; Overwrite EP ISRs
  65 0768 09e7 0052 071e     mov    w[bios_ep1_in_isr], w[SIE2_EP1_VEC]
  66 076e 09e7 0054 0720     mov    w[bios_ep2_out_isr], w[SIE2_EP2_VEC]
  67 0774 07e7 07e1 0052     mov    w[SIE2_EP1_VEC], my_ep1_in_vec
  68 077a 07e7 07f9 0054     mov    w[SIE2_EP2_VEC], my_ep2_out_vec
  69                         ;; HPI Mailbox ISRs
  70 0780 09e7 0016 0722     mov    w[bios_hpi_tx_isr], w[HPI_MBOX_TX_EMPTY_VEC]
  71 0786 07e7 079b 0016     mov    w[HPI_MBOX_TX_EMPTY_VEC], my_hpi_tx_empty_vec
  72 078c 09e7 0014 0724     mov    w[bios_hpi_rx_isr], w[HPI_MBOX_RX_FULL_VEC]
  73 0792 07e7 07a9 0014     mov    w[HPI_MBOX_RX_FULL_VEC], my_hpi_rx_full_vec
  74 0798 cf97               ret
  75                     ;*****************************************************************************
  76                     
  77                     
  78                     ;*****************************************************************************
  79                     ;; HPI mailbox was read by host
  80                     ;*****************************************************************************
  81 079a 00             hpi_was_read		db	0x00
  82                     ;*****************************************************************************
  83 079b                my_hpi_tx_empty_vec:
  84 079c afa7 0722          call   [bios_hpi_tx_isr]
  85 07a0 07ef 0001 079a     mov    b[hpi_was_read], 0x01
  86 07a6 cf97               ret
  87                     ;*****************************************************************************
  88                     
  89                     
  90                     ;*****************************************************************************
  91                     ;; HPI mailbox was written by host
  92                     ;*****************************************************************************
  93 07a8 00             hpi_was_written		db	0x00
  94                     ;*****************************************************************************
  95 07a9                my_hpi_rx_full_vec:
  96 07aa afa7 0724          call   [bios_hpi_rx_isr]
  97 07ae 07ef 0001 07a8     mov    b[hpi_was_written], 0x01
  98 07b4 cf97               ret
  99                     ;*****************************************************************************
 100                     
 101                     
 102                     ;*****************************************************************************
 103                     ;; USB reset handler.
 104                     ;*****************************************************************************
 105 07b6                my_standard_usb_reset_handler:
 106 07b6 77ef 0001 06fa     test   b[main_enable], 1
 107 07bc c002               jz     @f
 108 07be af9f 07c8          call   warm_boot
 109 07c2                @@:
 110 07c2 afa7 0714          call   [bios_standard_usb_reset_handler]
 111 07c6 cf97               ret
 112                     ;*****************************************************************************    
 113                     
 114                     
 115                     ;*****************************************************************************
 116                     ;; Warm reboot.
 117                     ;*****************************************************************************
 118 07c8                warm_boot:
 119                         ;; mov	   r0, 0x0021		; !
 120                         ;; call   dbg_putchar
 121 07c8 07ef 0000 06fa     mov    b[main_enable], 0x00
 122 07ce 07ef 0000 086c     mov    b[conf_count], 0x00
 123 07d4 07ef 0000 06fc     mov    b[main_lock], 0
 124                         ;; reset hack
 125 07da cf9f e000          jmpl   0xE000
 126 07de                wd_hang:
 127 07de cf7f               jmp    wd_hang
 128                         ; should never get here...
 129                     ;*****************************************************************************    
 130                     
 131                     
 132                     ;*****************************************************************************
 133 07e0 00             ep1_in_fired		db	0x00
 134                     ;*****************************************************************************
 135 07e1                my_ep1_in_vec:			; fires on packet SENDING
 136 07e2 afa7 071e          call   [bios_ep1_in_isr]
 137 07e6 09d7 c000          push   [CPU_FLAGS_REG]	; push flags register
 138 07ea af49               int    PUSHALL_INT
 139 07ec d82f 07e0          addi   b[ep1_in_fired], 1
 140 07f0 af4a               int    POPALL_INT
 141 07f2 05e7 c000          pop    [CPU_FLAGS_REG]	; push flags register
 142 07f6 cf97               ret
 143                     ;*****************************************************************************
 144                     
 145                     
 146                     ;*****************************************************************************
 147 07f8 00             ep2_out_fired		db	0x00
 148                     ;*****************************************************************************
 149 07f9                my_ep2_out_vec:			; fires on packet RECEIVING
 150 07fa afa7 0720          call   [bios_ep2_out_isr]
 151 07fe 09d7 c000          push   [CPU_FLAGS_REG]	; push flags register
 152 0802 af49               int    PUSHALL_INT
 153 0804 d82f 07f8          addi   b[ep2_out_fired], 1
 154 0808 af4a               int    POPALL_INT
 155 080a 05e7 c000          pop    [CPU_FLAGS_REG]	; push flags register
 156 080e cf97               ret
 157                     ;*****************************************************************************
 158                     
 159                     
 160                     ;*****************************************************************************
 161                     ;; Device request offsets
 162           00000000  bmRequest	equ	0
 163           00000001  bRequest	equ	1
 164           00000002  wValue		equ	2
 165           00000004  wIndex		equ	4
 166           00000006  wLength		equ	6
 167                     ;*****************************************************************************
 168                     
 169                     ;*****************************************************************************
 170                     ;; CLASS_INT vector
 171                     ;*****************************************************************************
 172 0810                my_class_request_handler: ;; Handle MSC class requests.
 173 0810 0e00 0001          mov	   r0, b[r8 + bRequest] ; save request value
 174 0814 57c0 00ff          cmp	   r0, MSC_REQUEST_RESET
 175 0818 c017               je	   class_req_eq_request_reset
 176 081a 57c0 00fe          cmp	   r0, MSC_REQUEST_GET_MAX_LUN
 177 081e c002               je	   class_req_eq_request_get_max_lun
 178 0820 af69               int	   SUSB2_FINISH_INT	; replace BIOS's handler: call STATUS phrase
 179 0822 cf97               ret
 180                         ;;; ----------------------
 181 0824                class_req_eq_request_get_max_lun:
 182                         ;; No LUNs on this device, so send back a zero:
 183 0824 07e7 0864 085e     mov	   [ctlsend_addr], ctlsend_buffer ; address of buffer
 184 082a 07e7 0000 0864     mov	   [ctlsend_buffer], 0x0000 ; EP0Buf[0] = 0
 185 0830 07e7 0001 0860     mov	   [ctlsend_len], 0x0001 ; send 1 byte
 186 0836 07e7 0000 0862     mov    [ctlsend_call], 0x0000 ; no callback
 187 083c 07c8 085c          mov    r8, ctlsend_link	; pointer to linker
 188 0840 07c1 0000          mov    r1, 0x0000 		; which endpoint to send to
 189 0844 af60               int    SUSB2_SEND_INT	; call interrupt
 190 0846 cf09               jmp	   end_class_request_handler
 191 0848                class_req_eq_request_reset:
 192                         ;; TODO: implement genuine reset of EVERYTHING...
 193 0848 07ef 0000 171e     mov    b[scsi_state], SCSI_state_CBW
 194 084e 07e7 0000 171a     mov    [SCSI_dw_sense_lw], 0x0000
 195 0854 07e7 0000 171c     mov    [SCSI_dw_sense_uw], 0x0000 ; dwSense = 0
 196                         ;; int	   SUSB2_FINISH_INT
 197                         ;; ----------------------------------
 198                         ;; Done with class request handler
 199 085a                end_class_request_handler:
 200 085a cf97               ret
 201                     ;*****************************************************************************
 202                     ;; CTL Send data structure
 203           0000      align 2
 204 085c 0000           ctlsend_link			dw 0x0000
 205 085e 0000           ctlsend_addr			dw 0x0000
 206 0860 0000           ctlsend_len			dw 0x0000
 207 0862 0000           ctlsend_call			dw 0x0000
 208 0864 0000           ctlsend_buffer			dw 0x0000
 209                     ;*****************************************************************************
 210                     
 211                     ;*****************************************************************************
 212                     ;; STANDARD_INT vector
 213                     ;*****************************************************************************
 214 0866                my_standard_request_handler:
 215 0866 cfa7 0716          jmp    [bios_standard_request_handler]
 216                     ;*****************************************************************************
 217                     
 218                     ;*****************************************************************************
 219                     ;; DELTA_CONFIG_INT vector
 220                     ;*****************************************************************************
 221 086a 0000           req_wvalue		dw 0x0000
 222 086c 0000           conf_count		dw 0x0000
 223                     ;*****************************************************************************
 224 086e                my_configuration_change:
 225 086e 09d7 c000          push   [CPU_FLAGS_REG]	; push flags register
 226 0872 af49               int    PUSHALL_INT
 227                     
 228 0874 d827 086c          addi   [conf_count], 1
 229                         
 230 0878 07c8 0308          mov    r8, SIE2_DEV_REQ
 231 087c 0c00 0002          mov	   r0, w[r8 + wValue]
 232 0880 0027 086a          mov    [req_wvalue], r0
 233 0884 afa7 071a          call   [bios_configuration_change] ; let BIOS configure endpoints...
 234 0888 09c0 086a          mov	   r0, [req_wvalue]
 235 088c 67c0 00ff          and    r0, 0xFF
 236 0890 57c0 0001          cmp    r0, 1 ; [bConfigurationValue]
 237 0894 c107               jne    @f ; it isn't time yet
 238                     
 239 0896 57ef 0004 086c     cmp    b[conf_count], 4
 240 089c c203               jb     @f
 241                         
 242 089e 07e7 0001 06fa     mov    [main_enable], 1 ; we want to enable self when configured
 243                     
 244                         ;; mov	   r0, 0x002B		; +
 245                         ;; call   dbg_putchar
 246                         
 247 08a4                @@:
 248 08a4 af4a               int    POPALL_INT
 249 08a6 05e7 c000          pop    [CPU_FLAGS_REG]	; push flags register
 250 08aa cf97               ret
 251                     ;*****************************************************************************

 130                     include usb-bulk.asm

   0                      ;; /*************************************************************************
   1                      ;; *                     This file is part of Stierlitz:                    *
   2                      ;; *               https://github.com/asciilifeform/Stierlitz               *
   3                      ;; *************************************************************************/
   4                     
   5                      ;; /*************************************************************************
   6                      ;; *                (c) Copyright 2012 Stanislav Datskovskiy                *
   7                      ;; *                         http://www.loper-os.org                        *
   8                      ;; **************************************************************************
   9                      ;; *                                                                        *
  10                      ;; *  This program is free software: you can redistribute it and/or modify  *
  11                      ;; *  it under the terms of the GNU General Public License as published by  *
  12                      ;; *  the Free Software Foundation, either version 3 of the License, or     *
  13                      ;; *  (at your option) any later version.                                   *
  14                      ;; *                                                                        *
  15                      ;; *  This program is distributed in the hope that it will be useful,       *
  16                      ;; *  but WITHOUT ANY WARRANTY; without even the implied warranty of        *
  17                      ;; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
  18                      ;; *  GNU General Public License for more details.                          *
  19                      ;; *                                                                        *
  20                      ;; *  You should have received a copy of the GNU General Public License     *
  21                      ;; *  along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  22                      ;; *                                                                        *
  23                      ;; *************************************************************************/
  24                     
  25                     
  26                     ;*****************************************************************************
  27                     ;*****************************************************************************
  28                     ; Bulk Endpoint I/O
  29                     ;*****************************************************************************
  30                     ;*****************************************************************************
  31                     
  32                     ;*****************************************************************************
  33                     ;; wait for event on EP1
  34                     ;*****************************************************************************
  35 08ac                wait_for_ep1_in_fired:
  36 08ac                @@:
  37 08ac af9f 0b98          call   bios_idle
  38 08b0 57ef 0001 07e0     cmp    b[ep1_in_fired], 0x01
  39 08b6 c17a               jne    @b
  40 08b8 07ef 0000 07e0     mov    b[ep1_in_fired], 0x00
  41 08be cf97               ret
  42                     ;*****************************************************************************
  43                     
  44                     
  45                     ;*****************************************************************************
  46                     ;; wait for event on EP2
  47                     ;*****************************************************************************
  48 08c0                wait_for_ep2_out_fired:
  49 08c0                @@:
  50 08c0 af9f 0b98          call   bios_idle
  51 08c4 57ef 0001 07f8     cmp    b[ep2_out_fired], 0x01
  52 08ca c17a               jne    @b
  53 08cc 07ef 0000 07f8     mov    b[ep2_out_fired], 0x00
  54 08d2 cf97               ret
  55                     ;*****************************************************************************
  56                     
  57                     
  58                     ;*****************************************************************************
  59                     ; Transmit usbsend_len bytes to endpoint send_endpoint from send_buffer.
  60                     ;*****************************************************************************
  61                     ;; tx_spin_lock			db 0x00
  62 08d4 0000           send_buffer_offset		dw 0x0000
  63           0000      align 2
  64                     ;*****************************************************************************
  65 08d6                usb_send_data:
  66 08d6 07e7 0000 090e     mov    w[usbsend_link], 0	; must be 0x0000 for send routine
  67 08dc 07e7 17a8 0910     mov    w[usbsend_addr], send_buffer
  68 08e2 09c0 08d4          mov    r0, w[send_buffer_offset]
  69 08e6 1027 0910          add    w[usbsend_addr], r0
  70 08ea 07e7 090c 0914     mov    w[usbsend_call], usb_send_done ;; set up callback
  71                         ;; mov    b[tx_spin_lock], 1
  72 08f0                usb_tx:
  73 08f0 07c8 090e          mov    r8, usbsend_link	; pointer to linker
  74 08f4 9041               xor    r1, r1
  75 08f6 07c1 0001          mov    r1, EP_IN ; which endpoint to send to
  76 08fa af60               int    SUSB2_SEND_INT	; call interrupt
  77 08fc af9f 08ac          call   wait_for_ep1_in_fired
  78 0900 09c0 0912          mov    r0, w[usbsend_len]
  79 0904 57c0 0000          cmp    r0, 0x0000
  80 0908 c173               jne    usb_tx
  81                         ;; mov    b[tx_spin_lock], 0
  82 090a cf97               ret
  83 090c                usb_send_done: ;; Callback
  84                         ;; mov    b[tx_spin_lock], 0
  85 090c cf97               ret
  86                     ;*****************************************************************************
  87                     ;; Send data structure
  88           0000      align 2
  89 090e 0000           usbsend_link			dw 0x0000
  90 0910 0000           usbsend_addr			dw 0x0000
  91 0912 0000           usbsend_len			dw 0x0000
  92 0914 0000           usbsend_call			dw 0x0000
  93                     ;*****************************************************************************
  94                     
  95                     
  96                     ;*****************************************************************************
  97                     ; Transmit [usbsend_len] bytes from send_buffer to host via EP_IN.
  98                     ; r0 will equal number of bytes which were NOT sent.
  99                     ;*****************************************************************************
 100 0916                bulk_send:
 101 0916 af9f 08d6          call   usb_send_data	; transmit answer
 102 091a 09c0 0912          mov    r0, w[usbsend_len]	; bytes failed (0 if all were sent.)
 103 091e cf97               ret
 104                     ;*****************************************************************************
 105                     
 106                     
 107                     ;*****************************************************************************
 108                     ; Receive usbrecv_length bytes of data from Bulk OUT endpoint into usbrecv_addr.
 109                     ; r0 will equal number of bytes NOT received.
 110                     ;*****************************************************************************
 111                     ;; rx_spin_lock			db 0x00
 112           0000      align 2
 113                     ;*****************************************************************************
 114 0920                usb_receive_data:
 115                         ;; mov    b[rx_spin_lock], 1
 116 0920 07e7 0000 094c     mov    w[usbrecv_link], 0
 117                         ;; mov    w[usbrecv_addr], receive_buffer
 118 0926 07e7 094a 0952     mov    w[usbrecv_call], receiver_done
 119 092c                usb_rx:
 120 092c 07c8 094c          mov    r8, usbrecv_link	; pointer to linker
 121 0930 07c1 0002          mov    r1, EP_OUT           ; from which endpoint to receive
 122 0934 67c1 000f          and    r1, 0x0F
 123 0938 af61               int    SUSB2_RECEIVE_INT	; call interrupt
 124 093a af9f 08c0          call   wait_for_ep2_out_fired
 125 093e 09c0 0950          mov    r0, w[usbrecv_len]
 126 0942 57c0 0000          cmp    r0, 0x0000
 127 0946 c172               jne    usb_rx
 128 0948 cf97               ret
 129 094a                receiver_done:
 130                         ;; mov    b[rx_spin_lock], 0
 131                         ;; mov    r0, w[usbrecv_len]	; bytes failed (0 if all were received.)
 132 094a cf97               ret
 133                     ;*****************************************************************************
 134                     ;; Receiver data structure
 135 094c 0000           usbrecv_link			dw 0x0000
 136 094e 0000           usbrecv_addr			dw 0x0000
 137 0950 0000           usbrecv_len			dw 0x0000
 138 0952 0000           usbrecv_call			dw 0x0000
 139           0000      align 2
 140                     ;*****************************************************************************
 141                     
 142                     
 143                     ;*****************************************************************************
 144                     ; zap send buffer
 145                     ;*****************************************************************************
 146 0954                zap_send_buffer:
 147 0954 07c1 0100          mov    r1, 0x0100
 148 0958 07c9 17a8          mov    r9, send_buffer
 149 095c                @@:
 150 095c 07e1 0000          mov    w[r9++], 0x0000
 151 0960 da01               dec    r1
 152 0962 c17c               jnz    @b
 153 0964 cf97               ret
 154                     ;*****************************************************************************
 155                     
 156                     
 157                     ;*****************************************************************************
 158                     ; zap send buffer from r0 to r0+r1 (words)
 159                     ;*****************************************************************************
 160                     ;; zap_send_buffer_from_to:
 161                     ;;     mov    r9, send_buffer
 162                     ;;     add    r9, r0
 163                     ;; @@:
 164                     ;;     mov    w[r9++], 0x0000
 165                     ;;     dec    r1
 166                     ;;     jnz    @b
 167                     ;;     ret
 168                     ;*****************************************************************************

 131                     include msc.asm

   0                      ;; /*************************************************************************
   1                      ;; *                     This file is part of Stierlitz:                    *
   2                      ;; *               https://github.com/asciilifeform/Stierlitz               *
   3                      ;; *************************************************************************/
   4                     
   5                      ;; /*************************************************************************
   6                      ;; *                (c) Copyright 2012 Stanislav Datskovskiy                *
   7                      ;; *                         http://www.loper-os.org                        *
   8                      ;; **************************************************************************
   9                      ;; *                                                                        *
  10                      ;; *  This program is free software: you can redistribute it and/or modify  *
  11                      ;; *  it under the terms of the GNU General Public License as published by  *
  12                      ;; *  the Free Software Foundation, either version 3 of the License, or     *
  13                      ;; *  (at your option) any later version.                                   *
  14                      ;; *                                                                        *
  15                      ;; *  This program is distributed in the hope that it will be useful,       *
  16                      ;; *  but WITHOUT ANY WARRANTY; without even the implied warranty of        *
  17                      ;; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
  18                      ;; *  GNU General Public License for more details.                          *
  19                      ;; *                                                                        *
  20                      ;; *  You should have received a copy of the GNU General Public License     *
  21                      ;; *  along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  22                      ;; *                                                                        *
  23                      ;; *************************************************************************/
  24                     
  25                     ;;  /*************************************************************************
  26                     ;;  *     "We are what we pretend to be, so we must be careful about what    *
  27                     ;;  *      we pretend to be." (K. Vonnegut, "Mother Night")                  *
  28                     ;;  *************************************************************************/
  29                      
  30                     ;*****************************************************************************
  31                     ; Variables to keep track of bulk I/O
  32                     ;*****************************************************************************
  33 0966                dwTransferSize:			; Total size of data transfer
  34 0966 0000           dwTransferSize_lw		dw 0x0000
  35 0968 0000           dwTransferSize_uw		dw 0x0000
  36                     
  37 096a                dwOffset:			; Offset in current data transfer
  38 096a 0000           dwOffset_lw			dw 0x0000
  39 096c 0000           dwOffset_uw			dw 0x0000
  40                     ;*****************************************************************************
  41                     
  42                     ;*****************************************************************************
  43                     ;; Process data received from bulk OUT endpoint.
  44                     ;; Received packet is in receive_buffer.
  45                     ;; Response (if not stall) will be built in send_buffer.
  46                     ;*****************************************************************************
  47 096e 00             host_in_flag			db 0x00
  48           0001      align 2
  49                     ;*****************************************************************************
  50 0970                usb_host_to_dev_handler:
  51                         ;; Determine what the response should be.
  52                         ;; This depends first on the SCSI state machine's state.
  53 0970 9249               xor    r9, r9
  54 0972 0bc9 171e          mov    r9, b[scsi_state]
  55 0976 57c9 0004          cmp    r9, 4
  56 097a cd05               jle    scsi_rx_state_0_to_4	; make sure state is 0..4
  57                         ;; recover from weird state - should never get here:
  58 097c 07ef 0000 171e     mov    b[scsi_state], SCSI_state_CBW
  59 0982 0bc9 171e          mov    r9, b[scsi_state]
  60 0986                scsi_rx_state_0_to_4:
  61 0986 d209               shl    r9, 1		; table offset times two (addresses are words.)
  62 0988 cfb1 098c          jmpl   [r9 + scsi_rx_state_jmp_table]
  63                         ;; SCSI State Machine Table
  64 098c                scsi_rx_state_jmp_table:
  65 098c 0996               dw     do_rx_state_CBW
  66 098e 0ab4               dw     do_rx_state_data_out
  67 0990 0aba               dw     do_rx_state_data_in
  68 0992 0aba               dw     do_rx_state_CSW
  69 0994 0abc               dw     do_rx_state_stalled
  70                         ;; ------------------------
  71 0996                do_rx_state_CBW:
  72 0996 07e7 19a8 094e     mov    w[usbrecv_addr], receive_buffer
  73 099c 07e7 001f 0950     mov    w[usbrecv_len], CBW_Size	; how many bytes to receive
  74 09a2 af9f 0920          call   usb_receive_data	; read CBW from host Bulk OUT endpoint
  75                         
  76                         ;; Check for valid CBW:
  77 09a6 57c0 0000          cmp    r0, 0		; how many bytes (of 31) failed to read?
  78 09aa c118               jne    invalid_cbw		; if any unread bytes, invalid.
  79 09ac 57e7 5355 19a8     cmp    w[MSC_CBW_Signature_lw], CBW_Signature_lw_expected
  80 09b2 c114               jne    invalid_cbw		; lower word of signature is invalid
  81 09b4 57e7 4342 19aa     cmp    w[MSC_CBW_Signature_uw], CBW_Signature_uw_expected
  82 09ba c110               jne    invalid_cbw		; upper word of signature is invalid
  83 09bc 0bc0 19b5          mov    r0, b[CBW_lun]
  84 09c0 67c0 000f          and    r0, 0x0F
  85 09c4 57c0 0000          cmp    r0, 0		; LUN == 0?
  86 09c8 c109               jne    invalid_cbw		; if not, then CBW is 'not meaningful.'
  87 09ca 57ef 0001 19b6     cmp    b[CBW_cb_length], 1	; if bCBWCBLength < 1:
  88 09d0 c205               jb     invalid_cbw		; then invalid
  89 09d2 57ef 0010 19b6     cmp    b[CBW_cb_length], 16	; if bCBWCBLength > 16:
  90 09d8 ca01               jg     invalid_cbw		; then invalid
  91 09da cf08               jmp    valid_cbw ;; CBW is Valid and Meaningful
  92 09dc                invalid_cbw: ;; Or not:
  93 09dc af9f 0b3c          call   stall_bulk_in_ep
  94 09e0 af9f 0b36          call   stall_bulk_out_ep
  95 09e4 07ef 0004 171e     mov    b[scsi_state], SCSI_state_stalled
  96 09ea cf97               ret
  97 09ec                valid_cbw:
  98                         ;; clear dwOffset and dwTransferSize:
  99 09ec 9000               xor    r0, r0
 100 09ee 0027 096a          mov    w[dwOffset_lw], r0
 101 09f2 0027 096c          mov    w[dwOffset_uw], r0
 102 09f6 0027 0966          mov    w[dwTransferSize_lw], r0
 103 09fa 0027 0968          mov    w[dwTransferSize_uw], r0
 104                         ;; fHostIN = ((CBW.bmCBWFlags & 0x80) != 0);
 105 09fe 07ef 0000 096e     mov    b[host_in_flag], 0x00
 106 0a04 0bc0 19b4          mov    r0, b[CBW_flags] ; Whether to stall IN endpoint:
 107 0a08 77c0 0080          test   r0, 0x80         ; Bit 7 = 0 for an OUT (host-to-device) transfer.
 108 0a0c c003               jz	   @f               ; Bit 7 = 1 for an IN (device-to-host) transfer.
 109 0a0e 07ef 0001 096e     mov    b[host_in_flag], 0x01
 110 0a14                @@:
 111 0a14 af9f 0cfa          call   SCSI_handle_cmd  ; pbData = SCSIHandleCmd(CBW.CBWCB, CBW.bCBWCBLength, &iLen, &fDevIn);
 112 0a18 57ef 0001 0cf0     cmp    b[cmd_must_stall_flag], 0x01
 113 0a1e c107               jne    @f
 114                         ;; if (pbData == NULL)
 115 0a20 af9f 0b0e          call   stall_transfer
 116 0a24 07c0 0001          mov    r0, CSW_CMD_FAILED
 117 0a28 af9f 0b4e          call   send_csw
 118 0a2c cf97               ret
 119 0a2e                @@:
 120                         ;; if device and host disagree on direction, send Phase Error status.
 121 0a2e 57e7 0000 0cec     cmp    w[response_length_uw], 0
 122 0a34 c104               jne    yes_response
 123 0a36 57e7 0000 0cea     cmp    w[response_length_lw], 0
 124 0a3c c00c               je     no_disagree
 125 0a3e                yes_response:
 126                         ;; if (response length > 0)
 127                         ;; xor    r0, r0
 128 0a3e 0bc0 096e          mov    r0, b[host_in_flag]
 129 0a42 9bc0 0cee          xor    r0, b[dev_in_flag]
 130 0a46 c007               jz     no_disagree
 131                         ;; && ((fHostIn && !fDevIn) || (!fHostIn && fDevIn)) then:
 132 0a48 af9f 0b0e          call   stall_transfer
 133 0a4c 07c0 0002          mov    r0, CSW_PHASE_ERROR
 134 0a50 af9f 0b4e          call   send_csw
 135 0a54 cf97               ret
 136 0a56                no_disagree:
 137                         ;; if D > H, send Phase Error status.
 138 0a56 09c2 0cea          mov    r2, w[response_length_lw] ; R3:R2 = dwTransferSize
 139 0a5a 09c3 0cec          mov    r3, w[response_length_uw] ; upper word of response length
 140 0a5e 09c0 19b0          mov    r0, w[CBW_data_transfer_length_lw]
 141 0a62 09c1 19b2          mov    r1, w[CBW_data_transfer_length_uw] ; R1:R0 = dwCBWDataTransferLength
 142                         ;; R1:R0 - R3:R2
 143 0a66 af9f 0bb2          call   subtract_16
 144 0a6a c307               jnc    @f	  ; If result < 0?
 145                         ;; if (iLen > CBW.dwCBWDataTransferLength) then: negative residue
 146 0a6c af9f 0b0e          call   stall_transfer
 147 0a70 07c0 0002          mov    r0, CSW_PHASE_ERROR
 148 0a74 af9f 0b4e          call   send_csw
 149 0a78 cf97               ret
 150 0a7a                @@:
 151                         ;; dwTransferSize = iLen
 152 0a7a 09e7 0cea 0966     mov    w[dwTransferSize_lw], w[response_length_lw]
 153 0a80 09e7 0cec 0968     mov    w[dwTransferSize_uw], w[response_length_uw]
 154                         ;; if ((dwTransferSize == 0) || fDevIn)
 155 0a86 57e7 0000 0966     cmp    w[dwTransferSize_lw], 0x0000
 156 0a8c c105               jne    @f
 157 0a8e 57e7 0000 0968     cmp    w[dwTransferSize_uw], 0x0000
 158 0a94 c101               jne    @f
 159 0a96 cf08               jmp    device_to_host
 160 0a98                @@: ;; else, host to device:
 161 0a98 77ef 0001 0cee     test   b[dev_in_flag], 1
 162 0a9e c104               jnz    device_to_host
 163                         ;; otherwise, data from host to device:
 164 0aa0 07ef 0001 171e     mov    b[scsi_state], SCSI_state_data_out
 165 0aa6 cf97               ret
 166 0aa8                device_to_host:
 167 0aa8 07ef 0002 171e     mov    b[scsi_state], SCSI_state_data_in
 168 0aae af9f 0c5e          call   handle_data_in
 169 0ab2 cf97               ret
 170 0ab4                do_rx_state_data_out:
 171 0ab4 af9f 0bba          call   handle_data_out
 172 0ab8 cf97               ret
 173 0aba                do_rx_state_data_in:
 174 0aba                do_rx_state_CSW:
 175                         ;; iChunk = USBHwEPRead(bEP, NULL, 0); (for debug only?)
 176                         ;; phrase error:
 177                         ;; mov    b[scsi_state], SCSI_state_CBW
 178 0aba cf97               ret
 179 0abc                do_rx_state_stalled:
 180 0abc af9f 0b36          call   stall_bulk_out_ep ; if stalled, keep stalling:
 181 0ac0 cf97               ret
 182                     ;*****************************************************************************
 183                     
 184                     ;*****************************************************************************
 185                     ;; Process data sent to bulk IN endpoint.
 186                     ;*****************************************************************************
 187 0ac2                usb_dev_to_host_handler:
 188                         ;; Determine what the response should be.
 189                         ;; This depends first on the SCSI state machine's state.
 190 0ac2 9249               xor    r9, r9
 191 0ac4 0bc9 171e          mov    r9, b[scsi_state]
 192 0ac8 57c9 0004          cmp    r9, 4
 193 0acc cd05               jle    scsi_tx_state_0_to_4	; make sure state is 0..4
 194                         ;; recover from weird state - should never get here:
 195 0ace 07ef 0000 171e     mov    b[scsi_state], SCSI_state_CBW
 196 0ad4 0bc9 171e          mov    r9, b[scsi_state]
 197 0ad8                scsi_tx_state_0_to_4:
 198 0ad8 d209               shl    r9, 1		; table offset times two (addresses are words.)
 199 0ada cfb1 0ade          jmpl   [r9 + scsi_tx_state_jmp_table]
 200                         ;; SCSI State Machine Table
 201 0ade                scsi_tx_state_jmp_table:
 202 0ade 0ae8               dw     do_tx_state_CBW
 203 0ae0 0ae8               dw     do_tx_state_data_out
 204 0ae2 0aea               dw     do_tx_state_data_in
 205 0ae4 0af0               dw     do_tx_state_CSW
 206 0ae6 0b08               dw     do_tx_state_stalled
 207                         ;; ------------------------
 208 0ae8                do_tx_state_CBW:
 209 0ae8                do_tx_state_data_out:
 210 0ae8 cf97               ret
 211 0aea                do_tx_state_data_in:
 212 0aea af9f 0c5e          call   handle_data_in
 213 0aee cf97               ret
 214 0af0                do_tx_state_CSW:
 215 0af0 07e7 000d 0912     mov	   w[usbsend_len], CSW_Size
 216 0af6 07e7 0000 08d4     mov    w[send_buffer_offset], 0x0000
 217 0afc af9f 0916          call   bulk_send  ;; send the CSW:
 218 0b00 07ef 0000 171e     mov    b[scsi_state], SCSI_state_CBW
 219 0b06 cf97               ret
 220 0b08                do_tx_state_stalled:
 221 0b08 af9f 0b3c          call   stall_bulk_in_ep ; if stalled, keep stalling:
 222 0b0c cf97               ret
 223                     ;*****************************************************************************
 224                     
 225                     
 226                     ;*****************************************************************************
 227                     ;; Stall ongoing transfer. Determine which endpoint to stall using CBW.
 228                     ;*****************************************************************************
 229 0b0e                stall_transfer:
 230 0b0e 9000               xor    r0,r0
 231 0b10 0bc0 19b4          mov    r0, b[CBW_flags]  ; Whether to stall IN endpoint:
 232 0b14 77c0 0080          test   r0, 0x80         ; Bit 7 = 0 for an OUT (host-to-device) transfer.
 233 0b18 c111               jnz	   stall_bulk_in_ep ; Bit 7 = 1 for an IN (device-to-host) transfer.
 234 0b1a 57e7 0000 19b0     cmp    w[CBW_data_transfer_length_lw], 0x0000 ; if lower word != 0, then stall EP_OUT
 235 0b20 c107               jne    stall_out
 236 0b22 57e7 0000 19b2     cmp    w[CBW_data_transfer_length_uw], 0x0000 ; if upper word != 0, then stall EP_OUT
 237 0b28 c103               jne    stall_out
 238                         ;; otherwise, if CBW_data_transfer_length == 0, stall EP_IN:
 239 0b2a af9f 0b3c          call   stall_bulk_in_ep
 240 0b2e cf97               ret
 241 0b30                stall_out:
 242 0b30 af9f 0b36          call   stall_bulk_out_ep
 243 0b34 cf97               ret
 244                     ;*****************************************************************************
 245                     
 246                     ;*****************************************************************************
 247                     ;; Stall endpoints.
 248                     ;*****************************************************************************
 249 0b36                stall_bulk_out_ep: ; Select endpoint 2 (OUT) control register
 250 0b36 07c9 02a0          mov    r9, DEV2_EP2_CTL_REG
 251 0b3a cf02               jmp    set_stall_bit
 252 0b3c                stall_bulk_in_ep: ; Select endpoint 1 (IN) control register
 253 0b3c 07c9 0290          mov    r9, DEV2_EP1_CTL_REG
 254 0b40                set_stall_bit: ; Stall the endpoint:
 255 0b40 87d1 0020          or     [r9], STALL_EN
 256                     
 257 0b44 07c0 0053          mov	   r0, 0x0053		; S
 258 0b48 af9f 0510          call   dbg_putchar
 259                         
 260 0b4c cf97               ret
 261                     ;*****************************************************************************
 262                     
 263                     ;*****************************************************************************
 264                     ;; Send CSW, on the next bulk-IN transfer.
 265                     ;; argument: r0 = bStatus
 266                     ;*****************************************************************************
 267 0b4e                send_csw:
 268 0b4e 67c0 00ff          and    r0, 0x00FF
 269 0b52 002f 17b4          mov    b[CSW_status], r0
 270 0b56 07e7 5355 17a8     mov    w[MSC_CSW_Signature_lw], CSW_Signature_lw_expected ; signature lower word
 271 0b5c 07e7 5342 17aa     mov    w[MSC_CSW_Signature_uw], CSW_Signature_uw_expected ; signature upper word
 272 0b62 09e7 19ac 17ac     mov    w[CSW_tag_lw], w[CBW_tag_lw]	; copy lower word of tag from last CBW
 273 0b68 09e7 19ae 17ae     mov    w[CSW_tag_uw], w[CBW_tag_uw] ; copy upper word of tag from last CBW
 274                         ;; iResidue = max( 0, (dwCBWDataTransferLength - dwTransferSize) )
 275 0b6e 09c2 0966          mov    r2, w[dwTransferSize_lw]
 276 0b72 09c3 0968          mov    r3, w[dwTransferSize_uw] ; R3:R2 = dwTransferSize
 277 0b76 09c0 19b0          mov    r0, w[CBW_data_transfer_length_lw]
 278 0b7a 09c1 19b2          mov    r1, w[CBW_data_transfer_length_uw] ; R1:R0 = dwCBWDataTransferLength
 279                         ;; R1:R0 - R3:R2
 280 0b7e af9f 0bb2          call   subtract_16
 281 0b82 c302               jnc    @f	  ; If result < 0?
 282 0b84 9000               xor    r0, r0 ; then iResidue = 0.
 283 0b86 9041               xor    r1, r1
 284 0b88                @@: ; iResidue >= 0:
 285 0b88 0027 17b0          mov    w[CSW_data_residue_lw], r0
 286 0b8c 0067 17b2          mov    w[CSW_data_residue_uw], r1
 287 0b90 07ef 0003 171e     mov    b[scsi_state], SCSI_state_CSW ; next SCSI state = CSW
 288 0b96 cf97               ret
 289                     ;*****************************************************************************

 132                     include util.asm

   0                      ;; /*************************************************************************
   1                      ;; *                     This file is part of Stierlitz:                    *
   2                      ;; *               https://github.com/asciilifeform/Stierlitz               *
   3                      ;; *************************************************************************/
   4                     
   5                      ;; /*************************************************************************
   6                      ;; *                (c) Copyright 2012 Stanislav Datskovskiy                *
   7                      ;; *                         http://www.loper-os.org                        *
   8                      ;; **************************************************************************
   9                      ;; *                                                                        *
  10                      ;; *  This program is free software: you can redistribute it and/or modify  *
  11                      ;; *  it under the terms of the GNU General Public License as published by  *
  12                      ;; *  the Free Software Foundation, either version 3 of the License, or     *
  13                      ;; *  (at your option) any later version.                                   *
  14                      ;; *                                                                        *
  15                      ;; *  This program is distributed in the hope that it will be useful,       *
  16                      ;; *  but WITHOUT ANY WARRANTY; without even the implied warranty of        *
  17                      ;; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
  18                      ;; *  GNU General Public License for more details.                          *
  19                      ;; *                                                                        *
  20                      ;; *  You should have received a copy of the GNU General Public License     *
  21                      ;; *  along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  22                      ;; *                                                                        *
  23                      ;; *************************************************************************/
  24                     
  25                     
  26                     ;*****************************************************************************
  27                     ;; Call BIOS idle
  28                     ;*****************************************************************************
  29 0b98                bios_idle:
  30 0b98 af49               int    PUSHALL_INT
  31 0b9a af46               int    IDLE_INT
  32 0b9c af4a               int    POPALL_INT
  33 0b9e cf97               ret
  34                     ;*****************************************************************************
  35                     
  36                     
  37                     ;*****************************************************************************
  38                     ;; Delay - call idle loop R0 times
  39                     ;*****************************************************************************
  40 0ba0                delay:
  41 0ba0 af9f 0b98          call   bios_idle
  42 0ba4 da00               subi   r0, 1
  43 0ba6 c17c               jnz    delay
  44 0ba8 cf97               ret
  45                     ;*****************************************************************************
  46                     
  47                     
  48                     ;*****************************************************************************
  49                     ; mem_move
  50                     ; r9 = dest, r8 = src, r1 = word count
  51                     ;*****************************************************************************
  52 0baa                mem_move:
  53 0baa                @@:
  54 0baa 0821               mov    w[r9++], w[r8++]	; copy data
  55 0bac da01               dec    r1
  56 0bae c17d               jnz    @b
  57 0bb0 cf97               ret
  58                     ;*****************************************************************************
  59                     
  60                     
  61                     ;*****************************************************************************
  62                     ; subtract (16-bit)
  63                     ; R1:R0 - R3:R2
  64                     ;*****************************************************************************
  65 0bb2                subtract_16:
  66 0bb2 3080               sub    r0, r2 ; Subtract the lower halves.  This may "borrow" from the upper half.
  67 0bb4 40c1               subb   r1, r3 ; Subtract the upper halves.
  68 0bb6 cf97               ret
  69                     ;*****************************************************************************

 133                     include scsi-data.asm

   0                      ;; /*************************************************************************
   1                      ;; *                     This file is part of Stierlitz:                    *
   2                      ;; *               https://github.com/asciilifeform/Stierlitz               *
   3                      ;; *************************************************************************/
   4                     
   5                      ;; /*************************************************************************
   6                      ;; *                (c) Copyright 2012 Stanislav Datskovskiy                *
   7                      ;; *                         http://www.loper-os.org                        *
   8                      ;; **************************************************************************
   9                      ;; *                                                                        *
  10                      ;; *  This program is free software: you can redistribute it and/or modify  *
  11                      ;; *  it under the terms of the GNU General Public License as published by  *
  12                      ;; *  the Free Software Foundation, either version 3 of the License, or     *
  13                      ;; *  (at your option) any later version.                                   *
  14                      ;; *                                                                        *
  15                      ;; *  This program is distributed in the hope that it will be useful,       *
  16                      ;; *  but WITHOUT ANY WARRANTY; without even the implied warranty of        *
  17                      ;; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
  18                      ;; *  GNU General Public License for more details.                          *
  19                      ;; *                                                                        *
  20                      ;; *  You should have received a copy of the GNU General Public License     *
  21                      ;; *  along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  22                      ;; *                                                                        *
  23                      ;; *************************************************************************/
  24                     
  25                     ;*****************************************************************************
  26 0bb8 0000           iChunk				dw	0x0000
  27           0000      align 2
  28                     ;*****************************************************************************
  29                     
  30                     ;*****************************************************************************
  31                     ; Handle SCSI Data Out. (Host to Device)
  32                     ;*****************************************************************************
  33 0bba                handle_data_out:
  34 0bba 07e7 0040 0bb8     mov    w[iChunk], USB_PACKET_SIZE ; start with 64
  35                         
  36 0bc0 09c0 0966          mov    r0, w[dwTransferSize_lw]
  37 0bc4 09c1 0968          mov    r1, w[dwTransferSize_uw] ; R1:R0 = dwTransferSize
  38 0bc8 09c2 096a          mov    r2, w[dwOffset_lw]
  39 0bcc 09c3 096c          mov    r3, w[dwOffset_uw] ; R3:R2 = dwOffset
  40                         ;; R1:R0 - R3:R2
  41 0bd0 af9f 0bb2          call   subtract_16
  42                         ;; jc     no_data_out ; if carry, then dwOffset > dwTransferSize
  43                         
  44                         ;; if (dwOffset < dwTransferSize)
  45                         ;; iChunk = USBHwEPRead(bulk_out_ep, pbData, dwTransferSize - dwOffset)
  46                         ;; r0 already = dwTransferSize - dwOffset
  47                         ;; iChunk = MIN(64, dwTransferSize - dwOffset)
  48 0bd4 6041               and    r1, r1
  49 0bd6 c106               jnz    @f ; if upper word of subtraction result is nonzero, then definitely > 64
  50 0bd8 0004               mov    r4, r0
  51 0bda 67c4 ffc0          and    r4, (1 + (0xFFFF - USB_PACKET_SIZE)) ; 64: 0xFFC0
  52 0bde c102               jnz    @f ; if lower word is greater than 64, then keep iChunk == 64.
  53 0be0 0027 0bb8          mov    w[iChunk], r0 ; otherwise, iChunk <- r0 (dwTransferSize - dwOffset).
  54 0be4                @@:
  55 0be4 09c0 0bb8          mov    r0, w[iChunk] ; number of bytes to receive from bulk_out_ep
  56 0be8 0027 0950          mov    w[usbrecv_len], r0 ; how many bytes to receive
  57 0bec 07e7 1ba8 094e     mov    w[usbrecv_addr], block_receive_buffer ; into Block buffer!
  58                     
  59 0bf2 09c0 096a          mov    r0, w[dwOffset_lw] ; only need lower word of dwoffset to calculate offset into block
  60 0bf6 67c0 01ff          and    r0, 0x01FF ;; dwBufPos = (dwOffset & (BLOCKSIZE - 1))
  61 0bfa 1027 094e          add    w[usbrecv_addr], r0
  62 0bfe af9f 0920          call   usb_receive_data ; receive data from host
  63 0c02 af9f 0e6e          call   SCSI_handle_data
  64 0c06 57ef 0001 0e6c     cmp    b[dat_must_stall_flag], 0x01
  65 0c0c c107               jne    @f
  66                         ;; if pbData == NULL:
  67 0c0e af9f 0b0e          call   stall_transfer
  68 0c12 07c0 0001          mov    r0, CSW_CMD_FAILED
  69 0c16 af9f 0b4e          call   send_csw
  70 0c1a cf97               ret
  71 0c1c                @@:
  72 0c1c 09c0 0bb8          mov    r0, w[iChunk]
  73 0c20 1027 096a          add    w[dwOffset_lw], r0   ; dwOffset += iChunk
  74 0c24 27e7 0000 096c     addc   w[dwOffset_uw], 0 	; add possible carry
  75 0c2a                no_data_out:
  76 0c2a 59e7 0966 096a     cmp    w[dwOffset_lw], w[dwTransferSize_lw]
  77 0c30 c112               jne    data_out_done
  78 0c32 59e7 0968 096c     cmp    w[dwOffset_uw], w[dwTransferSize_uw]
  79 0c38 c10e               jne    data_out_done
  80                         ;; if (dwOffset == dwTransferSize)
  81 0c3a 09c0 19b0          mov    r0, w[CBW_data_transfer_length_lw]
  82 0c3e 5027 096a          cmp    w[dwOffset_lw], r0
  83 0c42 c10a               jne    data_out_stall
  84 0c44 09c0 19b2          mov    r0, w[CBW_data_transfer_length_uw]
  85 0c48 5027 096c          cmp    w[dwOffset_uw], r0
  86 0c4c c105               jne    data_out_stall
  87 0c4e                data_out_send_csw:
  88 0c4e 07c0 0000          mov    r0, CSW_CMD_PASSED
  89 0c52 af9f 0b4e          call   send_csw
  90 0c56                data_out_done:
  91 0c56 cf97               ret
  92 0c58                data_out_stall:
  93 0c58 af9f 0b0e          call   stall_transfer
  94 0c5c cf78               jmp    data_out_send_csw
  95                     ;*****************************************************************************
  96                     
  97                     ;*****************************************************************************
  98                     ; Handle SCSI Data In. (Device to Host)
  99                     ;*****************************************************************************
 100 0c5e                handle_data_in:
 101 0c5e af9f 0e6e          call   SCSI_handle_data
 102 0c62 57ef 0001 0e6c     cmp    b[dat_must_stall_flag], 0x01
 103 0c68 c107               jne    @f
 104                         ;; pbData == NULL:
 105 0c6a af9f 0b0e          call   stall_transfer
 106 0c6e 07c0 0001          mov    r0, CSW_CMD_FAILED
 107 0c72 af9f 0b4e          call   send_csw
 108 0c76 cf97               ret
 109 0c78                @@:
 110                         ;; send data to host?
 111                         ;; if (dwOffset < dwTransferSize)
 112                         ;; iChunk = MIN(64, dwTransferSize - dwOffset)
 113 0c78 07e7 0040 0bb8     mov    w[iChunk], USB_PACKET_SIZE ; start with 64
 114 0c7e 09c0 0966          mov    r0, w[dwTransferSize_lw]
 115 0c82 09c1 0968          mov    r1, w[dwTransferSize_uw] ; R1:R0 = dwTransferSize
 116 0c86 09c2 096a          mov    r2, w[dwOffset_lw]
 117 0c8a 09c3 096c          mov    r3, w[dwOffset_uw] ; R3:R2 = dwOffset
 118                         ;; R1:R0 - R3:R2
 119 0c8e af9f 0bb2          call   subtract_16
 120 0c92 57c1 0000          cmp    r1, 0
 121 0c96 c106               jne    @f ; if upper word of subtraction result is nonzero, then definitely > 64
 122 0c98 0004               mov    r4, r0
 123 0c9a 67c4 ffc0          and    r4, (1 + (0xFFFF - USB_PACKET_SIZE)) ; 64: 0xFFC0
 124 0c9e c102               jnz    @f ; if lower word is greater than 64, then keep iChunk == 64.
 125 0ca0 0027 0bb8          mov    w[iChunk], r0 ; otherwise, iChunk <- r0 (dwTransferSize - dwOffset).
 126 0ca4                @@:
 127 0ca4 09c0 0bb8          mov    r0, w[iChunk] ; number of bytes to transmit to bulk_in_ep
 128 0ca8 0027 0912          mov	   w[usbsend_len], r0
 129 0cac 09c0 096a          mov    r0, w[dwOffset_lw] ; only need lower word of dwoffset to calculate offset into block
 130 0cb0 67c0 01ff          and    r0, 0x01FF ;; dwBufPos = (dwOffset & (BLOCKSIZE - 1))
 131 0cb4 0027 08d4          mov    w[send_buffer_offset], r0
 132 0cb8 af9f 0916          call   bulk_send	; transmit bytes to host
 133 0cbc 09c0 0bb8          mov    r0, w[iChunk]
 134 0cc0 1027 096a          add    w[dwOffset_lw], r0    ; dwOffset += iChunk
 135 0cc4 27e7 0000 096c     addc   w[dwOffset_uw], 0 	 ; add possible carry
 136                         ;; are we done?
 137 0cca 59e7 0966 096a     cmp    w[dwOffset_lw], w[dwTransferSize_lw]
 138 0cd0 c108               jne    data_in_done
 139 0cd2 59e7 0968 096c     cmp    w[dwOffset_uw], w[dwTransferSize_uw]
 140 0cd8 c104               jne    data_in_done
 141                         ;; if (dwOffset == dwTransferSize)
 142                         ;; mov    r0, w[CBW_data_transfer_length_lw]
 143                         ;; cmp    w[dwOffset_lw], r0
 144                         ;; jne    data_in_stall
 145                         ;; mov    r0, w[CBW_data_transfer_length_uw]
 146                         ;; cmp    w[dwOffset_uw], r0
 147                         ;; jne    data_in_stall
 148 0cda                data_in_send_csw:
 149 0cda 07c0 0000          mov    r0, CSW_CMD_PASSED
 150 0cde af9f 0b4e          call   send_csw
 151 0ce2                data_in_done:
 152 0ce2 cf97               ret
 153 0ce4                data_in_stall:
 154 0ce4 af9f 0b0e          call   stall_transfer
 155 0ce8 cf78               jmp    data_in_send_csw
 156                     ;*****************************************************************************

 134                     include scsi-cmd.asm

   0                      ;; /*************************************************************************
   1                      ;; *                     This file is part of Stierlitz:                    *
   2                      ;; *               https://github.com/asciilifeform/Stierlitz               *
   3                      ;; *************************************************************************/
   4                     
   5                      ;; /*************************************************************************
   6                      ;; *                (c) Copyright 2012 Stanislav Datskovskiy                *
   7                      ;; *                         http://www.loper-os.org                        *
   8                      ;; **************************************************************************
   9                      ;; *                                                                        *
  10                      ;; *  This program is free software: you can redistribute it and/or modify  *
  11                      ;; *  it under the terms of the GNU General Public License as published by  *
  12                      ;; *  the Free Software Foundation, either version 3 of the License, or     *
  13                      ;; *  (at your option) any later version.                                   *
  14                      ;; *                                                                        *
  15                      ;; *  This program is distributed in the hope that it will be useful,       *
  16                      ;; *  but WITHOUT ANY WARRANTY; without even the implied warranty of        *
  17                      ;; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
  18                      ;; *  GNU General Public License for more details.                          *
  19                      ;; *                                                                        *
  20                      ;; *  You should have received a copy of the GNU General Public License     *
  21                      ;; *  along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  22                      ;; *                                                                        *
  23                      ;; *************************************************************************/
  24                     
  25                     
  26                     ;*****************************************************************************
  27                     ;; SCSI command handler
  28                     ;*****************************************************************************
  29 0cea 0000           response_length_lw		dw 0x0000 ; Length of intended response data
  30 0cec 0000           response_length_uw		dw 0x0000 ; Length of intended response data - Upper Word
  31 0cee 0000           dev_in_flag			dw 0x0000 ; TRUE if data moving device -> host
  32 0cf0 0000           cmd_must_stall_flag		dw 0x0000 ; TRUE if bad command and must stall
  33           0000      align 2
  34                     ;*****************************************************************************
  35                     ; CDB length table:
  36 0cf2                aiCDBLen_table:
  37 0cf2 06                 db				6
  38 0cf3 0a                 db			       10
  39 0cf4 0a                 db			       10
  40 0cf5 00                 db				0
  41 0cf6 10                 db			       16
  42 0cf7 0c                 db			       12
  43 0cf8 00                 db				0
  44 0cf9 00                 db			        0
  45           0000      align 2
  46                     ;*****************************************************************************
  47 0cfa                SCSI_handle_cmd:
  48 0cfa 07e7 0000 0cea     mov    w[response_length_lw], 0x0000 ; default - no data
  49 0d00 07e7 0000 0cec     mov    w[response_length_uw], 0x0000 ; default - no data
  50 0d06 07ef 0000 0cf0     mov    b[cmd_must_stall_flag], 0x00	 ; default - no stall
  51 0d0c 07ef 0001 0cee     mov    b[dev_in_flag], 0x01	; default direction is device -> host
  52 0d12 9000               xor    r0, r0
  53 0d14 0bc0 19b7          mov    r0, b[Common_SCSI_CDB_op_code]
  54 0d18 dfc3               clc
  55 0d1a d100               shr    r0, 5
  56 0d1c 67c0 0007          and    r0, 0x7		       ; bGroupCode
  57 0d20 000b               mov    r11, r0	               ; table offset
  58 0d22 17cb 0cf2          add    r11, aiCDBLen_table	       ; table origin
  59 0d26 9041               xor    r1, r1
  60 0d28 06c1               mov    r1, b[r11]                  ; aiCDBLen[bGroupCode]
  61 0d2a 506f 19b6          cmp    b[CBW_cb_length], r1	       ; if (CDBLen < aiCDBLen[bGroupCode])
  62 0d2e c23b               jb     bad_scsi_cmd		       ; return NULL (bad cmd)
  63 0d30 9000               xor    r0, r0
  64 0d32 0bc0 19b7          mov    r0, b[Common_SCSI_CDB_op_code]
  65 0d36 57c0 0000          cmp    r0, SCSI_CMD_TEST_UNIT_READY
  66 0d3a c039               je     SCSI_command_test_unit_ready
  67 0d3c 57c0 0003          cmp    r0, SCSI_CMD_REQUEST_SENSE
  68 0d40 c037               je     SCSI_command_request_sense
  69 0d42 57c0 0004          cmp    r0, SCSI_CMD_FORMAT_UNIT
  70 0d46 c09f 0dce          je     SCSI_command_format_unit
  71 0d4a 57c0 0012          cmp    r0, SCSI_CMD_INQUIRY
  72 0d4e c09f 0dd0          je     SCSI_command_inquiry
  73 0d52 57c0 001a          cmp    r0, SCSI_CMD_MODE_SENSE6
  74 0d56 c09f 0dee          je     SCSI_command_mode_sense_6
  75 0d5a 57c0 001e          cmp    r0, SCSI_CMD_P_OR_A_MEDIUM_RMVL
  76 0d5e c09f 0dfc          je     SCSI_command_p_or_a_medium_rmvl
  77 0d62 57c0 0025          cmp    r0, SCSI_CMD_READ_CAPACITY
  78 0d66 c09f 0dfe          je     SCSI_command_read_capacity
  79 0d6a 57c0 0008          cmp    r0, SCSI_CMD_READ_6
  80 0d6e c09f 0e0c          je     SCSI_command_read_6
  81 0d72 57c0 0028          cmp    r0, SCSI_CMD_READ_10
  82 0d76 c09f 0e10          je     SCSI_command_read_10
  83 0d7a 57c0 000a          cmp    r0, SCSI_CMD_WRITE_6
  84 0d7e c09f 0e32          je     SCSI_command_write_6
  85 0d82 57c0 002a          cmp    r0, SCSI_CMD_WRITE_10
  86 0d86 c09f 0e38          je     SCSI_command_write_10
  87 0d8a 57c0 002f          cmp    r0, SCSI_CMD_VERIFY_10
  88 0d8e c09f 0e60          je     SCSI_command_verify_10
  89 0d92 57c0 00a0          cmp    r0, SCSI_CMD_REPORT_LUNS
  90 0d96 c09f 0e66          je     SCSI_command_report_luns
  91 0d9a                scsi_cmd_not_implemented: ;; None of these (unhandled / bad):
  92 0d9a 07e7 2000 171a     mov    w[SCSI_dw_sense_lw], SENSE_INVALID_CMD_OPCODE_lw
  93 0da0 07e7 0005 171c     mov    w[SCSI_dw_sense_uw], SENSE_INVALID_CMD_OPCODE_uw ;; dwSense = INVALID_CMD_OPCODE;
  94 0da6                bad_scsi_cmd:
  95 0da6 07ef 0001 0cf0     mov    b[cmd_must_stall_flag], 0x01 ; Must stall
  96 0dac cf97               ret
  97                     ;; bad_field:
  98                     ;;     mov    w[SCSI_dw_sense_lw], SENSE_INVALID_FIELD_IN_CDB_lw
  99                     ;;     mov    w[SCSI_dw_sense_uw], SENSE_INVALID_FIELD_IN_CDB_uw
 100                     ;;     jmp    bad_scsi_cmd
 101                     ;; SCSI Command Handlers
 102 0dae                SCSI_command_test_unit_ready:
 103 0dae cf97               ret
 104 0db0                SCSI_command_request_sense:
 105                         ;; rsplen = min(18, pCDB->bLength)
 106 0db0 07e7 0000 0cec     mov    w[response_length_uw], 0x0000
 107 0db6 07e7 0012 0cea     mov    w[response_length_lw], 18
 108 0dbc 9000               xor    r0, r0
 109 0dbe 0bc0 19bb          mov    r0, b[Request_Sense_SCSI_CDB_bLength]
 110 0dc2 5027 0cea          cmp    w[response_length_lw], r0
 111 0dc6 c902               jbe    @f
 112 0dc8 0027 0cea          mov    w[response_length_lw], r0
 113 0dcc                @@:
 114 0dcc cf97               ret
 115 0dce                SCSI_command_format_unit:
 116 0dce cf97               ret
 117 0dd0                SCSI_command_inquiry:
 118                         ;; rsplen = min(36, pCDB->bLength)
 119 0dd0 07e7 0000 0cec     mov    w[response_length_uw], 0x0000
 120 0dd6 07e7 0024 0cea     mov    w[response_length_lw], 36
 121 0ddc 9000               xor    r0, r0
 122 0dde 0bc0 19bb          mov    r0, b[Inquiry_SCSI_CDB_bLength]
 123 0de2 5027 0cea          cmp    w[response_length_lw], r0
 124 0de6 c902               jbe    @f
 125 0de8 0027 0cea          mov    w[response_length_lw], r0
 126 0dec                @@:
 127 0dec cf97               ret
 128 0dee                SCSI_command_mode_sense_6:
 129 0dee 07e7 0000 0cec     mov    w[response_length_uw], 0x0000
 130 0df4 07e7 00c0 0cea     mov    w[response_length_lw], 0xC0
 131 0dfa cf97               ret
 132 0dfc                SCSI_command_p_or_a_medium_rmvl:
 133 0dfc cf97               ret
 134 0dfe                SCSI_command_read_capacity:
 135 0dfe 07e7 0000 0cec     mov    w[response_length_uw], 0x0000
 136 0e04 07e7 0008 0cea     mov    w[response_length_lw], 8
 137 0e0a cf97               ret
 138 0e0c                SCSI_command_read_6:
 139 0e0c cf46               jmp    scsi_cmd_not_implemented ;;;;;; NOT IMPLEMENTED YET ;;;;;;
 140 0e0e cf97               ret
 141 0e10                SCSI_command_read_10:
 142                         ;; Calculate response length: BLOCKSIZE will always be 512
 143 0e10 9000               xor    r0, r0 ; will be lower word of rsplen
 144 0e12 9041               xor    r1, r1 ; will be upper word of rsplen
 145 0e14 0bc1 19be          mov    r1, b[Read10_SCSI_CDB_Transfer_Len_1] ; upper byte of transfer length
 146 0e18 d201               shl    r1, 1				 ; shift by 1 (already shifted by 8)
 147 0e1a 0bc0 19bf          mov    r0, b[Read10_SCSI_CDB_Transfer_Len_0] ; lower byte of transfer length
 148 0e1e d3c0               shl    r0, 8
 149 0e20 dfc3               clc
 150 0e22 d200               shl    r0, 1
 151 0e24 27c1 0000          addc   r1, 0 ; if carry, set low bit of upper word of result
 152                         ;; now, rsplen = dwLen * 512
 153 0e28 0027 0cea          mov    w[response_length_lw], r0
 154 0e2c 0067 0cec          mov    w[response_length_uw], r1
 155 0e30 cf97               ret
 156 0e32                SCSI_command_write_6:
 157 0e32 cf9f 0d9a          jmp    scsi_cmd_not_implemented ;;;;;; NOT IMPLEMENTED YET ;;;;;;
 158 0e36 cf97               ret
 159 0e38                SCSI_command_write_10:
 160                         ;; Calculate response length: BLOCKSIZE will always be 512
 161 0e38 9000               xor    r0, r0 ; will be lower word of rsplen
 162 0e3a 9041               xor    r1, r1 ; will be upper word of rsplen
 163 0e3c 0bc1 19be          mov    r1, b[Write10_SCSI_CDB_Transfer_Len_1] ; upper byte of transfer length
 164 0e40 d201               shl    r1, 1				 ; shift by 1 (already shifted by 8)
 165 0e42 0bc0 19bf          mov    r0, b[Write10_SCSI_CDB_Transfer_Len_0] ; lower byte of transfer length
 166 0e46 d3c0               shl    r0, 8
 167 0e48 dfc3               clc
 168 0e4a d200               shl    r0, 1
 169 0e4c 27c1 0000          addc   r1, 0 ; if carry, set low bit of upper word of result
 170                         ;; now, rsplen = dwLen * 512
 171 0e50 0027 0cea          mov    w[response_length_lw], r0
 172 0e54 0067 0cec          mov    w[response_length_uw], r1
 173 0e58 07ef 0000 0cee     mov    b[dev_in_flag], 0x00	; switch comm. direction
 174 0e5e cf97               ret
 175 0e60                SCSI_command_verify_10:
 176 0e60 cf9f 0d9a          jmp    scsi_cmd_not_implemented ;;;;;; NOT IMPLEMENTED YET ;;;;;;
 177 0e64 cf97               ret
 178 0e66                SCSI_command_report_luns:
 179 0e66 cf9f 0d9a          jmp    scsi_cmd_not_implemented ;;;;;; NOT IMPLEMENTED YET ;;;;;;
 180 0e6a cf97               ret
 181                     ;*****************************************************************************
 182                     
 183                     
 184                     
 185                     ;*****************************************************************************
 186                     ;; SCSI data handler
 187                     ;*****************************************************************************
 188 0e6c 00             dat_must_stall_flag		db 0x00 ; TRUE if bad command and must stall
 189           0001      align 2
 190                     ;*****************************************************************************
 191 0e6e                SCSI_handle_data:
 192 0e6e 07ef 0000 0e6c     mov    b[dat_must_stall_flag], 0x00
 193 0e74 9000               xor    r0, r0
 194 0e76 0bc0 19b7          mov    r0, b[Common_SCSI_CDB_op_code]
 195 0e7a 57c0 0000          cmp    r0, SCSI_CMD_TEST_UNIT_READY
 196 0e7e c09f 0f12          je     SCSI_data_cmd_test_unit_ready
 197 0e82 57c0 0003          cmp    r0, SCSI_CMD_REQUEST_SENSE
 198 0e86 c09f 0f2a          je     SCSI_data_cmd_request_sense
 199 0e8a 57c0 0004          cmp    r0, SCSI_CMD_FORMAT_UNIT
 200 0e8e c09f 0fa2          je     SCSI_data_cmd_format_unit
 201 0e92 57c0 0012          cmp    r0, SCSI_CMD_INQUIRY
 202 0e96 c09f 0fa4          je     SCSI_data_cmd_inquiry
 203 0e9a 57c0 001a          cmp    r0, SCSI_CMD_MODE_SENSE6
 204 0e9e c09f 0fb8          je     SCSI_data_cmd_mode_sense_6
 205 0ea2 57c0 001e          cmp    r0, SCSI_CMD_P_OR_A_MEDIUM_RMVL
 206 0ea6 c09f 0fee          je     SCSI_data_cmd_p_or_a_medium_rmvl
 207 0eaa 57c0 0025          cmp    r0, SCSI_CMD_READ_CAPACITY
 208 0eae c09f 0ff0          je     SCSI_data_cmd_read_capacity
 209 0eb2 57c0 0008          cmp    r0, SCSI_CMD_READ_6
 210 0eb6 c09f 1022          je     SCSI_data_cmd_read_6
 211 0eba 57c0 0028          cmp    r0, SCSI_CMD_READ_10
 212 0ebe c09f 1028          je     SCSI_data_cmd_read_10
 213 0ec2 57c0 000a          cmp    r0, SCSI_CMD_WRITE_6
 214 0ec6 c09f 105c          je     SCSI_data_cmd_write_6
 215 0eca 57c0 002a          cmp    r0, SCSI_CMD_WRITE_10
 216 0ece c09f 1062          je     SCSI_data_cmd_write_10
 217 0ed2 57c0 002f          cmp    r0, SCSI_CMD_VERIFY_10
 218 0ed6 c09f 109e          je     SCSI_data_cmd_verify_10
 219 0eda 57c0 00a0          cmp    r0, SCSI_CMD_REPORT_LUNS
 220 0ede c09f 10a0          je     SCSI_data_cmd_report_luns
 221 0ee2                scsi_data_cmd_not_implemented: ;; None of these (unhandled / bad):
 222 0ee2 07e7 2000 171a     mov    w[SCSI_dw_sense_lw], SENSE_INVALID_CMD_OPCODE_lw
 223 0ee8 07e7 0005 171c     mov    w[SCSI_dw_sense_uw], SENSE_INVALID_CMD_OPCODE_uw ;; dwSense = INVALID_CMD_OPCODE;
 224 0eee                bad_scsi_dat_cmd:
 225 0eee 07ef 0001 0e6c     mov    b[dat_must_stall_flag], 0x01 ; Must stall
 226 0ef4 cf97               ret
 227 0ef6                scsi_read_error:
 228 0ef6 07e7 1100 171a     mov    w[SCSI_dw_sense_lw], SENSE_READ_ERROR_lw
 229 0efc 07e7 0003 171c     mov    w[SCSI_dw_sense_uw], SENSE_READ_ERROR_uw
 230 0f02 cf75               jmp    bad_scsi_dat_cmd
 231 0f04                scsi_write_error:
 232 0f04 07e7 0c00 171a     mov    w[SCSI_dw_sense_lw], SENSE_WRITE_ERROR_lw
 233 0f0a 07e7 0003 171c     mov    w[SCSI_dw_sense_uw], SENSE_WRITE_ERROR_uw
 234 0f10 cf6e               jmp    bad_scsi_dat_cmd
 235                     ;; SCSI data command handlers:
 236 0f12                SCSI_data_cmd_test_unit_ready:
 237 0f12 57e7 0000 171a     cmp    w[SCSI_dw_sense_lw], 0
 238 0f18 c007               je     @f
 239 0f1a 57e7 0000 171c     cmp    w[SCSI_dw_sense_uw], 0
 240 0f20 c003               je     @f
 241 0f22 07ef 0001 0e6c     mov    b[dat_must_stall_flag], 0x01 ;; if (dwSense !=0) return NULL;
 242 0f28                @@:
 243 0f28 cf97               ret
 244 0f2a                SCSI_data_cmd_request_sense:
 245                         ;; Build reply to request_sense command:
 246 0f2a 07ef 0070 17a8     mov    b[(send_buffer)], 0x70
 247 0f30 07ef 0000 17a9     mov    b[(send_buffer + 1)], 0x00
 248 0f36 0bef 171b 17aa     mov    b[(send_buffer + 2)], b[dwSense_KEY]
 249 0f3c 07ef 0000 17ab     mov    b[(send_buffer + 3)], 0x00
 250 0f42 07ef 0000 17ac     mov    b[(send_buffer + 4)], 0x00
 251 0f48 07ef 0000 17ad     mov    b[(send_buffer + 5)], 0x00
 252 0f4e 07ef 0000 17ae     mov    b[(send_buffer + 6)], 0x00
 253 0f54 07ef 000a 17af     mov    b[(send_buffer + 7)], 0x0A
 254 0f5a 07ef 0000 17b0     mov    b[(send_buffer + 8)], 0x00
 255 0f60 07ef 0000 17b1     mov    b[(send_buffer + 9)], 0x00
 256 0f66 07ef 0000 17b2     mov    b[(send_buffer + 10)], 0x00
 257 0f6c 07ef 0000 17b3     mov    b[(send_buffer + 11)], 0x00
 258 0f72 0bef 171c 17b4     mov    b[(send_buffer + 12)], b[dwSense_ASC]
 259 0f78 0bef 171d 17b5     mov    b[(send_buffer + 13)], b[dwSense_ASCQ]
 260 0f7e 07ef 0000 17b6     mov    b[(send_buffer + 14)], 0x00
 261 0f84 07ef 0000 17b7     mov    b[(send_buffer + 15)], 0x00
 262 0f8a 07ef 0000 17b8     mov    b[(send_buffer + 16)], 0x00
 263 0f90 07ef 0000 17b9     mov    b[(send_buffer + 17)], 0x00
 264                         ;; reset dwSense
 265 0f96 9000               xor    r0, r0
 266 0f98 0027 171a          mov    w[SCSI_dw_sense_lw], r0
 267 0f9c 0027 171c          mov    w[SCSI_dw_sense_uw], r0
 268 0fa0 cf97               ret
 269 0fa2                SCSI_data_cmd_format_unit: ;; nothing happens
 270 0fa2 cf97               ret
 271 0fa4                SCSI_data_cmd_inquiry:
 272 0fa4 07c9 17a8          mov    r9, send_buffer
 273 0fa8 07c8 1720          mov    r8, SCSI_inquiry_response
 274 0fac 9041               xor    r1, r1
 275 0fae 07c1 0012          mov    r1, (INQ_ADD_LEN >> 1) ; number of WORDS to mem_move
 276 0fb2 af9f 0baa          call   mem_move
 277 0fb6 cf97               ret
 278 0fb8                SCSI_data_cmd_mode_sense_6:
 279 0fb8 af9f 0954          call   zap_send_buffer
 280 0fbc 07ef 0003 17a8     mov    b[(send_buffer)], 0x03 ; Number of bytes which follow
 281 0fc2 07ef 0000 17a9     mov    b[(send_buffer + 1)], 0x00 ; Medium Type: 00h for SBC devices.
 282 0fc8 07ef 0000 17aa     mov    b[(send_buffer + 2)], 0x00 ; Device-Specific Parameter - no WP, no cache
 283 0fce 07ef 0000 17ab     mov    b[(send_buffer + 3)], 0x00 ; No mode-parameter block descriptors.
 284 0fd4 07ef 0000 17ac     mov    b[(send_buffer + 4)], 0x00 ; No blocks
 285 0fda 07ef 0000 17ad     mov    b[(send_buffer + 5)], 0x00 ; No blocks
 286 0fe0 07ef 0000 17ae     mov    b[(send_buffer + 6)], 0x00 ; No blocks
 287 0fe6 07ef 0000 17af     mov    b[(send_buffer + 7)], 0x00 ; No blocks
 288 0fec cf97               ret
 289 0fee                SCSI_data_cmd_p_or_a_medium_rmvl: ;; nothing happens
 290 0fee cf97               ret
 291 0ff0                SCSI_data_cmd_read_capacity:
 292                         ;; maximal block:
 293 0ff0 07ef 0000 17a8     mov    b[(send_buffer)], MAXBLOCK_3
 294 0ff6 07ef 003f 17a9     mov    b[(send_buffer + 1)], MAXBLOCK_2
 295 0ffc 07ef 00ff 17aa     mov    b[(send_buffer + 2)], MAXBLOCK_1
 296 1002 07ef 00ff 17ab     mov    b[(send_buffer + 3)], MAXBLOCK_0
 297                         ;; block size: (always 512)
 298 1008 07ef 0000 17ac     mov    b[(send_buffer + 4)], ((BLOCKSIZE >> 24) && 0xFF)
 299 100e 07ef 0000 17ad     mov    b[(send_buffer + 5)], ((BLOCKSIZE >> 16) && 0xFF)
 300 1014 07ef 0002 17ae     mov    b[(send_buffer + 6)], ((BLOCKSIZE >> 8) && 0xFF)
 301 101a 07ef 0000 17af     mov    b[(send_buffer + 7)], (BLOCKSIZE && 0xFF)
 302 1020 cf97               ret
 303 1022                SCSI_data_cmd_read_6:
 304 1022 cf9f 0ee2          jmp    scsi_data_cmd_not_implemented  ;;;;;; NOT IMPLEMENTED YET ;;;;;;
 305 1026 cf97               ret
 306 1028                SCSI_data_cmd_read_10:
 307                         ;; Calculate current offset into buffer:
 308 1028 09c0 096a          mov    r0, w[dwOffset_lw]
 309 102c 67c0 01ff          and    r0, 0x01FF ;; dwBufPos = (dwOffset & (BLOCKSIZE - 1))
 310 1030 c114               jnz    @f
 311                         ;; load given LBA block index:
 312 1032 90c3               xor    r3, r3
 313 1034 9104               xor    r4, r4
 314 1036 0bc4 19b9          mov    r4, b[Read10_SCSI_CDB_LBA_3]
 315 103a d3c4               shl    r4, 8
 316 103c 8bc4 19ba          or     r4, b[Read10_SCSI_CDB_LBA_2] ;; r4 = old lba high word
 317 1040 0bc3 19bb          mov    r3, b[Read10_SCSI_CDB_LBA_1]
 318 1044 d3c3               shl    r3, 8
 319 1046 8bc3 19bc          or     r3, b[Read10_SCSI_CDB_LBA_0] ;; r3 = old lba low word
 320 104a 00e7 10a6          mov    w[given_lba_lw], r3
 321 104e 0127 10a8          mov    w[given_lba_uw], r4
 322 1052 af9f 10ae          call   compute_actual_block_index	; compute corrected index
 323                         ;; now load:
 324                         ;; TODO: error condition if the blocks to be read extend past end of "disk"
 325 1056 af9f 134e          call   load_lba_block ;; if (dwBufPos == 0) then read new block:
 326 105a                @@: ; not new block: offset into block is calculated in handle_data_in
 327 105a cf97               ret
 328 105c                SCSI_data_cmd_write_6:
 329 105c cf9f 0ee2          jmp    scsi_data_cmd_not_implemented  ;;;;;; NOT IMPLEMENTED YET ;;;;;;
 330 1060 cf97               ret
 331 1062                SCSI_data_cmd_write_10:
 332                         ;; Find out if we just started receiving a block:
 333 1062 09c0 096a          mov    r0, w[dwOffset_lw]
 334 1066 67c0 01ff          and    r0, 0x01FF
 335 106a c112               jnz    @f
 336                         ;; load given LBA block index:
 337 106c 90c3               xor    r3, r3
 338 106e 9104               xor    r4, r4
 339 1070 0bc4 19b9          mov    r4, b[Write10_SCSI_CDB_LBA_3]
 340 1074 d3c4               shl    r4, 8
 341 1076 8bc4 19ba          or     r4, b[Write10_SCSI_CDB_LBA_2] ;; r4 = old lba high word
 342 107a 0bc3 19bb          mov    r3, b[Write10_SCSI_CDB_LBA_1]
 343 107e d3c3               shl    r3, 8
 344 1080 8bc3 19bc          or     r3, b[Write10_SCSI_CDB_LBA_0] ;; r3 = old lba low word
 345 1084 00e7 10a6          mov    w[given_lba_lw], r3
 346 1088 0127 10a8          mov    w[given_lba_uw], r4
 347 108c af9f 10ae          call   compute_actual_block_index	; compute corrected index
 348 1090                @@:
 349                         ;; Did we just finish receiving a block?
 350 1090 57e7 1da8 094e     cmp    w[usbrecv_addr], (block_receive_buffer + BLOCKSIZE)
 351 1096 c102               jne    @f ; no. we're in mid-block.
 352                         ;; Yes, we did:
 353 1098 af9f 1430          call   save_lba_block
 354 109c                @@:
 355 109c cf97               ret
 356 109e                SCSI_data_cmd_verify_10: ;; nothing happens
 357 109e cf97               ret
 358 10a0                SCSI_data_cmd_report_luns:
 359 10a0 cf9f 0ee2          jmp    scsi_data_cmd_not_implemented  ;;;;;; NOT IMPLEMENTED YET ;;;;;;
 360 10a4 cf97               ret
 361                     ;*****************************************************************************
 362                     
 363                     
 364                     ;*****************************************************************************
 365                     ;; Correct LBA block index for current offset
 366                     ;; Low word is in 
 367                     ;*****************************************************************************
 368                     ;; input
 369 10a6 0000           given_lba_lw			dw 0x0000
 370 10a8 0000           given_lba_uw			dw 0x0000
 371                     ;; computed offset
 372 10aa 0000           blocks_offset_lw		dw 0x0000
 373 10ac 0000           blocks_offset_uw		dw 0x0000
 374                     ;*****************************************************************************
 375 10ae                compute_actual_block_index:
 376                         ;; find out if offset extends one or more block forward:
 377 10ae 09c1 096c          mov    r1, w[dwOffset_uw]
 378 10b2 d3c1               shl    r1, 8
 379 10b4 67c1 ff00          and    r1, 0xFF00
 380 10b8 0040               mov    r0, r1  ;; upper byte of r0 == lower byte of uw
 381 10ba 09c1 096a          mov    r1, w[dwOffset_lw]
 382 10be dfc3               clc
 383 10c0 d1c1               shr    r1, 8
 384 10c2 67c1 00ff          and    r1, 0x00FF
 385 10c6 8040               or     r0, r1 ;; r0 == {low{uw}, high{lw}}
 386 10c8 9104               xor    r4, r4
 387 10ca 09c1 096c          mov    r1, w[dwOffset_uw]
 388 10ce dfc3               clc
 389 10d0 d1c1               shr    r1, 8
 390 10d2 77c1 0001          test   r1, 1
 391 10d6 c001               jz     @f
 392 10d8 d804               addi   r4, 1 ; bit 0 of uw
 393 10da                @@:
 394 10da dfc3               clc
 395 10dc d000               shr    r0, 1
 396 10de 6104               and    r4, r4
 397 10e0 c002               jz     @f
 398 10e2 87c0 0080          or     r0, 0x0080 ; set bit 7 of result to equal low bit of uw
 399 10e6                @@:
 400 10e6 dfc3               clc
 401 10e8 d001               shr    r1, 1 ;; now {r1:r0} = {dwOffset_uw:dwOffset_lw} / 512
 402 10ea 0027 10aa          mov    w[blocks_offset_lw], r0
 403 10ee 0067 10ac          mov    w[blocks_offset_uw], r1
 404                         ;; skip block correction if correction factor is zero:
 405 10f2 6000               and    r0, r0
 406 10f4 c103               jnz    @f
 407 10f6 6041               and    r1, r1
 408 10f8 c101               jnz    @f
 409 10fa cf0e               jmp    no_block_correction ;; no need to correct for offset
 410 10fc                @@:
 411                         ;; need to correct for offset:
 412                         ;; load original LBA:
 413 10fc 09c3 10a6          mov    r3, w[given_lba_lw]
 414 1100 09c4 10a8          mov    r4, w[given_lba_uw]
 415                         ;; add correction factor:
 416 1104 dfc3               clc
 417 1106 19c3 10aa          add    r3, w[blocks_offset_lw] ; add lw of corrector to low word of LBA
 418 110a 29c4 10ac          addc   r4, w[blocks_offset_uw] ; add possible carry to high word of LBA
 419                         ;; write actual LBA to access:
 420 110e 00e7 127e          mov    w[actual_lba_lw], r3
 421 1112 0127 1280          mov    w[actual_lba_uw], r4
 422 1116 cf97               ret
 423 1118                no_block_correction:
 424 1118 09e7 10a6 127e     mov    w[actual_lba_lw], w[given_lba_lw]
 425 111e 09e7 10a8 1280     mov    w[actual_lba_uw], w[given_lba_uw]
 426 1124 cf97               ret
 427                     ;*****************************************************************************

 135                     include i2c.asm

   0 1126                i2c_param:
   1 1126 c028               dw 0xc028 ; General Purpose IO Control register high
   2 1128 c024               dw 0xc024 ; General Purpose IO Data register high
   3                         ; dw 0x0001 ; GPIO16 (SDA)
   4                         ; dw 0x0002 ; GPIO17 (SCL)
   5 112a 8000               dw 0x8000 ; GPIO31 (SDA)
   6 112c 4000               dw 0x4000 ; GPIO30 (SCL)
   7 112e a0                 db 0xa0   ; signature byte
   8 112f 0e                 db 14     ; number of bits for address
   9                     
  10 1130                send_i2c_params:
  11 1130 0097               push   r2
  12 1132 0017               push   r0
  13 1134 07c0 0002          mov    r0, 2        ; 2=set param
  14 1138 07c1 1126          mov    r1,i2c_param ; new_parameter
  15 113c af41               int    LI2C_INT     ; call I2C
  16 113e 05c2               pop    r2
  17 1140 05c0               pop    r0
  18 1142 cf97               ret
  19                     
  20 1144                read_i2c_byte: ; r1 has the address
  21 1144 0097               push   r2
  22 1146 07c0 0000          mov    r0,0       ;0=read
  23 114a af41               int    LI2C_INT   ; call I2C
  24 114c 05c2               pop    r2
  25 114e cf97               ret    	      ;return byte in R0
  26                     
  27 1150                write_i2c_byte: ; r1 has the address, r2 has the value
  28 1150 0017               push   r0
  29 1152 07c0 0001          mov    r0,1       ;0=read
  30 1156 af41               int    LI2C_INT   ; call I2C
  31 1158 05c0               pop    r0
  32 115a cf97               ret    	      
  33                     
  34                     ;*****************************************************************************
  35                     ;; Load physical LBA block from I2C
  36                     ;*****************************************************************************
  37 115c                load_physical_lba_block_from_i2c:
  38 115c af9f 1130          call   send_i2c_params
  39                     
  40 1160 07c3 0100          mov    r3, 0x0100
  41 1164 07c9 17a8          mov    r9, send_buffer
  42 1168 09c1 1660          mov    r1, w[physical_lba_lw] ;; assume w[physical_lba_uw] is 0
  43                         ; r1 should be 0..31
  44                         ; real address is LBA * 512
  45 116c d3c1               shl    r1, 8
  46 116e dfc3               clc
  47 1170 d201               shl    r1, 1
  48 1172                @@:
  49 1172 af9f 1144          call   read_i2c_byte ; read byte from r1 to r0
  50                         ; inc    r1  -- in call already increments r1
  51                     
  52 1176 67c0 00ff          and    r0, 0x00FF
  53 117a 0002               mov    r2, r0
  54                     
  55 117c af9f 1144          call   read_i2c_byte ; read byte from r1 to r0
  56                         ; inc    r1  -- in call already increments r1
  57                     
  58 1180 67c0 00ff          and    r0, 0x00FF
  59 1184 d3c0               shl    r0, 8
  60                     
  61 1186 8002               or     r2, r0
  62                     
  63 1188 00a1               mov    w[r9++], r2
  64 118a da03               dec    r3
  65 118c c172               jnz    @b
  66                     
  67 118e cf97               ret
  68                     
  69                     ;*****************************************************************************
  70                     ;; Save physical LBA block to I2C
  71                     ;*****************************************************************************
  72 1190                save_physical_lba_block_i2c:
  73 1190 af9f 1130          call   send_i2c_params
  74                     
  75 1194 07c3 0100          mov    r3, 0x0100  ; 256*word (512 block)
  76 1198 07c9 1ba8          mov    r9, block_receive_buffer
  77 119c 09c1 1660          mov    r1, w[physical_lba_lw] ;; assume w[physical_lba_uw] is 0
  78                         ; r1 should be 0..31
  79                         ; real address is LBA * 512
  80 11a0 d3c1               shl    r1, 8
  81 11a2 dfc3               clc
  82 11a4 d201               shl    r1, 1
  83 11a6                @@:
  84 11a6 0840               mov    r0, w[r9++]
  85 11a8 0002               mov    r2, r0
  86 11aa 67c2 00ff          and    r2, 0x00FF
  87 11ae af9f 1150          call   write_i2c_byte ; write byte r2 to r1
  88                         ; inc    r1  -- in call already increments r1
  89                     
  90 11b2 0002               mov    r2, r0
  91 11b4 d1c2               shr    r2, 8
  92 11b6 67c2 00ff          and    r2, 0x00FF
  93 11ba af9f 1150          call   write_i2c_byte ; write byte r2 to r1
  94                         ; inc    r1  -- in call already increments r1
  95                         
  96 11be da03               dec    r3
  97 11c0 c172               jnz    @b
  98 11c2 cf97               ret

 136                     include cy16.asm

   0                     ;*****************************************************************************
   1                     ;; Load physical LBA block from CY16
   2                     ;*****************************************************************************
   3 11c4                load_physical_lba_block_from_cy16:
   4                     
   5 11c4 07c3 0100          mov    r3, 0x0100
   6 11c8 07c9 17a8          mov    r9, send_buffer
   7 11cc 09c1 1660          mov    r1, w[physical_lba_lw] ;; assume w[physical_lba_uw] is 0
   8                         ; r1 should be 0..31
   9                         ; real address is LBA * 512
  10 11d0 d3c1               shl    r1, 8
  11 11d2 dfc3               clc
  12 11d4 d201               shl    r1, 1
  13 11d6 07c2 00aa          mov    r2, 0xaa
  14 11da                @@:
  15                     
  16 11da 00a1               mov    w[r9++], r2
  17 11dc da03               dec    r3
  18 11de c17d               jnz    @b
  19                     
  20 11e0 cf97               ret
  21                     
  22                     ;*****************************************************************************
  23                     ;; Save physical LBA block to CY16
  24                     ;*****************************************************************************
  25 11e2                save_physical_lba_block_cy16:
  26                     
  27                     ;; trigger reset using watchdog
  28                     
  29 11e2 07c0 0022        mov r0, 34 ; WDT_TIMEOUT_FLG+WDT_EN
  30 11e6 0027 c00c        mov w[WDT_REG], r0
  31                       ;; WRITE_REGISTER( WDT_REG, 34); /* default */
  32 11ea cf97           ret
  33                     
  34 11ec 07c3 0100          mov    r3, 0x0100  ; 256*word (512 block)
  35 11f0 07c9 1ba8          mov    r9, block_receive_buffer
  36 11f4 09c1 1660          mov    r1, w[physical_lba_lw] ;; assume w[physical_lba_uw] is 0
  37                         ; r1 should be 0..31
  38                         ; real address is LBA * 512
  39 11f8 d3c1               shl    r1, 8
  40 11fa dfc3               clc
  41 11fc d201               shl    r1, 1
  42 11fe                @@:
  43 11fe 0840               mov    r0, w[r9++]
  44 1200 0002               mov    r2, r0
  45 1202 67c2 00ff          and    r2, 0x00FF
  46                     
  47                         ; save r2
  48                         ; inc r1
  49                     
  50 1206 0002               mov    r2, r0
  51 1208 d1c2               shr    r2, 8
  52 120a 67c2 00ff          and    r2, 0x00FF
  53                     
  54                         ; save r2
  55                         ; inc r1
  56                         
  57 120e da03               dec    r3
  58 1210 c176               jnz    @b
  59 1212 cf97               ret

 137                     include icap.asm

   0                     ;*****************************************************************************
   1                     ;; Load physical LBA block from CY16
   2                     ;*****************************************************************************
   3 1214                load_physical_lba_block_from_icap:
   4                     
   5                         ; set [our] special address recognized by fpga as icap
   6                         ; w[physical_lba_lw]
   7                         ; w[physical_lba_uw]
   8 1214 07e7 0000 1660     mov w[physical_lba_lw], 0x0000
   9 121a 07e7 0800 1662     mov w[physical_lba_uw], 0x0800
  10                     
  11                         ; push the block
  12 1220 af9f 1664          call load_physical_lba_block
  13 1224 cf97               ret
  14                     
  15 1226 07c3 0100          mov    r3, 0x0100
  16 122a 07c9 17a8          mov    r9, send_buffer
  17 122e 09c1 1660          mov    r1, w[physical_lba_lw] ;; assume w[physical_lba_uw] is 0
  18                         ; r1 should be 0..31
  19                         ; real address is LBA * 512
  20 1232 d3c1               shl    r1, 8
  21 1234 dfc3               clc
  22 1236 d201               shl    r1, 1
  23 1238 07c2 00bb          mov    r2, 0xbb
  24 123c                @@:
  25                     
  26 123c 00a1               mov    w[r9++], r2
  27 123e da03               dec    r3
  28 1240 c17d               jnz    @b
  29                     
  30 1242 cf97               ret
  31                     
  32                     ;*****************************************************************************
  33                     ;; Save physical LBA block to ICAP
  34                     ;*****************************************************************************
  35 1244                save_physical_lba_block_icap:
  36                     
  37                         ; set [our] special address recognized by fpga as icap
  38                         ; w[physical_lba_lw]
  39                         ; w[physical_lba_uw]
  40 1244 07e7 0000 1660     mov w[physical_lba_lw], 0
  41 124a 07e7 0800 1662     mov w[physical_lba_uw], 0x0800
  42                     
  43                         ; push the block
  44 1250 af9f 169e          call save_physical_lba_block
  45 1254 cf97               ret
  46                     
  47 1256 07c3 0100          mov    r3, 0x0100  ; 256*word (512 block)
  48 125a 07c9 1ba8          mov    r9, block_receive_buffer
  49 125e 09c1 1660          mov    r1, w[physical_lba_lw] ;; assume w[physical_lba_uw] is 0
  50                         ; r1 should be 0..31
  51                         ; real address is LBA * 512
  52 1262 d3c1               shl    r1, 8
  53 1264 dfc3               clc
  54 1266 d201               shl    r1, 1
  55 1268                @@:
  56 1268 0840               mov    r0, w[r9++]
  57 126a 0002               mov    r2, r0
  58 126c 67c2 00ff          and    r2, 0x00FF
  59                     
  60                         ; save r2
  61                         ; inc r1
  62                     
  63 1270 0002               mov    r2, r0
  64 1272 d1c2               shr    r2, 8
  65 1274 67c2 00ff          and    r2, 0x00FF
  66                     
  67                         ; save r2
  68                         ; inc r1
  69                         
  70 1278 da03               dec    r3
  71 127a c176               jnz    @b
  72 127c cf97               ret

 138                     include block.asm

   0                      ;; /*************************************************************************
   1                      ;; *                     This file is part of Stierlitz:                    *
   2                      ;; *               https://github.com/asciilifeform/Stierlitz               *
   3                      ;; *************************************************************************/
   4                     
   5                      ;; /*************************************************************************
   6                      ;; *                (c) Copyright 2012 Stanislav Datskovskiy                *
   7                      ;; *                         http://www.loper-os.org                        *
   8                      ;; **************************************************************************
   9                      ;; *                                                                        *
  10                      ;; *  This program is free software: you can redistribute it and/or modify  *
  11                      ;; *  it under the terms of the GNU General Public License as published by  *
  12                      ;; *  the Free Software Foundation, either version 3 of the License, or     *
  13                      ;; *  (at your option) any later version.                                   *
  14                      ;; *                                                                        *
  15                      ;; *  This program is distributed in the hope that it will be useful,       *
  16                      ;; *  but WITHOUT ANY WARRANTY; without even the implied warranty of        *
  17                      ;; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
  18                      ;; *  GNU General Public License for more details.                          *
  19                      ;; *                                                                        *
  20                      ;; *  You should have received a copy of the GNU General Public License     *
  21                      ;; *  along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  22                      ;; *                                                                        *
  23                      ;; *************************************************************************/
  24                     
  25                     ;*****************************************************************************
  26                     ;; Actual index of LBA block to read/write
  27                     ;*****************************************************************************
  28 127e 0000           actual_lba_lw			dw 0x0000
  29 1280 0000           actual_lba_uw			dw 0x0000
  30                     ;*****************************************************************************
  31                     
  32                     
  33                     ;*****************************************************************************
  34                     ;; Test if LBA block is within the given range.
  35                     ;; block is in actual_lba; range is r3:r2 to r4:r5.
  36                     ;; results: r2 is true or false.
  37                     ;;          r1:r0 is index into range (0...N)
  38                     ;*****************************************************************************
  39 1282                test_lba_block_in_range:
  40 1282 09c1 1280          mov    r1, w[actual_lba_uw]
  41 1286 09c0 127e          mov    r0, w[actual_lba_lw]
  42 128a af9f 0bb2          call   subtract_16 ;; R1:R0 - R3:R2
  43 128e c20e               jc     out_of_range	; below range?
  44                         ;; r1:r0 is now index into range, save it
  45 1290 0046               mov    r6, r1
  46 1292 0007               mov    r7, r0
  47 1294 09c1 1280          mov    r1, w[actual_lba_uw]
  48 1298 09c0 127e          mov    r0, w[actual_lba_lw]
  49 129c 0103               mov    r3, r4 ; uw of upper bound
  50 129e 0142               mov    r2, r5 ; lw of upper bound
  51 12a0 af9f 0bb2          call   subtract_16 ;; R1:R0 - R3:R2
  52 12a4 c303               jnc    out_of_range
  53                         ;; is in range:
  54 12a6 07c2 0001          mov    r2, 0x0001 ; True
  55 12aa cf02               jmp    blk_range_done
  56 12ac                out_of_range:
  57 12ac 07c2 0000          mov    r2, 0x0000 ; False
  58 12b0                blk_range_done:
  59 12b0 0181               mov    r1, r6
  60 12b2 01c0               mov    r0, r7
  61 12b4 cf97               ret
  62                     ;*****************************************************************************
  63                     
  64                     
  65                     ;*****************************************************************************
  66                     ;; Test if LBA block is within the payload range.
  67                     ;*****************************************************************************
  68                     ;; watch out for carry (unhandled because QTASM is RETARDED ...)
  69                     ;; TODO: there's none right now. but check here again when we up the virtual file size.
  70           0000490f  FILE_TOP_LW	equ	(FAT16_DATA_AREA_LBA_LW_EFFECTIVE_BOTTOM + FILE_SIZE_IN_BLKS_LW )
  71           00000000  FILE_TOP_UW	equ	(FAT16_DATA_AREA_LBA_UW_EFFECTIVE_BOTTOM + FILE_SIZE_IN_BLKS_UW )
  72                     ;*****************************************************************************
  73 12b6                test_lba_block_in_payload_range:
  74 12b6 07c3 0000          mov    r3, FAT16_DATA_AREA_LBA_UW_EFFECTIVE_BOTTOM
  75 12ba 07c2 029e          mov    r2, FAT16_DATA_AREA_LBA_LW_EFFECTIVE_BOTTOM
  76 12be 07c4 0000          mov    r4, FILE_TOP_UW
  77 12c2 07c5 490f          mov    r5, FILE_TOP_LW
  78 12c6 af9f 1282          call   test_lba_block_in_range
  79 12ca 77c2 0001          test   r2, 1
  80 12ce c004               jz     @f
  81 12d0 0067 1662          mov    w[physical_lba_uw], r1
  82 12d4 0027 1660          mov    w[physical_lba_lw], r0
  83 12d8                @@:
  84 12d8 0080               mov    r0, r2
  85 12da cf97               ret
  86                     ;*****************************************************************************
  87                     
  88                     ;*****************************************************************************
  89                     ; second file
  90                     ; TODO: hack -- fix sum of LWs overflow
  91                     ;*****************************************************************************
  92                     ; FILE2_BOTTOM_LW	equ	(FAT16_DATA_AREA_LBA_LW_EFFECTIVE_BOTTOM + (FAKE_FILE_CLUSTERS * (FAT16_CLUSTER_SIZE / BLOCKSIZE)))
  93           0000491e  FILE2_BOTTOM_LW	equ	(FAT16_DATA_AREA_LBA_LW_EFFECTIVE_BOTTOM + (FAKE_FILE_CLUSTERS * 0x040))
  94           00000000  FILE2_BOTTOM_UW	equ	0
  95           0000493e  FILE2_TOP_LW	equ	(FILE2_BOTTOM_LW + FILE2_SIZE_IN_BLKS_LW)
  96           00000000  FILE2_TOP_UW	equ	0
  97                     ;*****************************************************************************
  98 12dc                test_file2_lba_block_in_payload_range:
  99 12dc 07c3 0000          mov    r3, FILE2_BOTTOM_UW
 100 12e0 07c2 491e          mov    r2, FILE2_BOTTOM_LW
 101 12e4 07c4 0000          mov    r4, FILE2_TOP_UW
 102 12e8 07c5 493e          mov    r5, FILE2_TOP_LW
 103 12ec af9f 1282          call   test_lba_block_in_range
 104 12f0 77c2 0001          test   r2, 1
 105 12f4 c004               jz     @f
 106 12f6 0067 1662          mov    w[physical_lba_uw], r1
 107 12fa 0027 1660          mov    w[physical_lba_lw], r0
 108 12fe                @@:
 109 12fe 0080               mov    r0, r2
 110 1300 cf97               ret
 111                     ;*****************************************************************************
 112                     
 113                     ;*****************************************************************************
 114                     ; third file
 115                     ; TODO: hack -- fix sum of LWs overflow
 116                     ;*****************************************************************************
 117           0000495e  FILE3_BOTTOM_LW	equ	(FAT16_DATA_AREA_LBA_LW_EFFECTIVE_BOTTOM + (FAKE_FILE_CLUSTERS * 0x040) + (FAKE_FILE2_CLUSTERS * 0x040))
 118           00000000  FILE3_BOTTOM_UW	equ	0
 119           0000495f  FILE3_TOP_LW	equ	(FILE3_BOTTOM_LW + FILE3_SIZE_IN_BLKS_LW)
 120           00000000  FILE3_TOP_UW	equ	0
 121                     ;*****************************************************************************
 122 1302                test_file3_lba_block_in_payload_range:
 123 1302 07c3 0000          mov    r3, FILE3_BOTTOM_UW
 124 1306 07c2 495e          mov    r2, FILE3_BOTTOM_LW
 125 130a 07c4 0000          mov    r4, FILE3_TOP_UW
 126 130e 07c5 495f          mov    r5, FILE3_TOP_LW
 127 1312 af9f 1282          call   test_lba_block_in_range
 128 1316 77c2 0001          test   r2, 1
 129 131a c004               jz     @f
 130 131c 0067 1662          mov    w[physical_lba_uw], r1
 131 1320 0027 1660          mov    w[physical_lba_lw], r0
 132 1324                @@:
 133 1324 0080               mov    r0, r2
 134 1326 cf97               ret
 135                     ;*****************************************************************************
 136                     
 137                     ;*****************************************************************************
 138                     ; fourth file
 139                     ; TODO: hack -- fix sum of LWs overflow
 140                     ;*****************************************************************************
 141           0000499e  FILE4_BOTTOM_LW	equ	(FAT16_DATA_AREA_LBA_LW_EFFECTIVE_BOTTOM + (FAKE_FILE_CLUSTERS * 0x040) + (FAKE_FILE2_CLUSTERS * 0x040) + (FAKE_FILE3_CLUSTERS * 0x040))
 142           00000000  FILE4_BOTTOM_UW	equ	0
 143           0000499f  FILE4_TOP_LW	equ	(FILE4_BOTTOM_LW + FILE4_SIZE_IN_BLKS_LW)
 144           00000000  FILE4_TOP_UW	equ	0
 145                     ;*****************************************************************************
 146 1328                test_file4_lba_block_in_payload_range:
 147 1328 07c3 0000          mov    r3, FILE4_BOTTOM_UW
 148 132c 07c2 499e          mov    r2, FILE4_BOTTOM_LW
 149 1330 07c4 0000          mov    r4, FILE4_TOP_UW
 150 1334 07c5 499f          mov    r5, FILE4_TOP_LW
 151 1338 af9f 1282          call   test_lba_block_in_range
 152 133c 77c2 0001          test   r2, 1
 153 1340 c004               jz     @f
 154 1342 0067 1662          mov    w[physical_lba_uw], r1
 155 1346 0027 1660          mov    w[physical_lba_lw], r0
 156 134a                @@:
 157 134a 0080               mov    r0, r2
 158 134c cf97               ret
 159                     ;*****************************************************************************
 160                     
 161                     ;*****************************************************************************
 162                     ;; Load LBA block
 163                     ;*****************************************************************************
 164 134e                load_lba_block:
 165 134e af9f 12b6          call   test_lba_block_in_payload_range
 166 1352 77c0 0001          test   r0, 1
 167 1356 c003               jz     @f
 168 1358 af9f 1664          call   load_physical_lba_block ; this was a payload block
 169 135c cf97               ret	; and so we're done here.
 170 135e                @@: ; Or, well, not:
 171                     
 172 135e af9f 12dc          call   test_file2_lba_block_in_payload_range
 173 1362 77c0 0001          test   r0, 1
 174 1366 c003               jz     @f
 175 1368 af9f 115c          call   load_physical_lba_block_from_i2c ; this was a payload block w[physical_lba_uw] and w[physical_lba_lw]
 176                         ; call  zap_with_test_data
 177 136c cf97               ret	; and so we're done here.
 178 136e                @@: ; Or, well, not:
 179                     
 180 136e af9f 1302          call   test_file3_lba_block_in_payload_range
 181 1372 77c0 0001          test   r0, 1
 182 1376 c003               jz     @f
 183 1378 af9f 11c4          call   load_physical_lba_block_from_cy16 ; this was a payload block w[physical_lba_uw] and w[physical_lba_lw]
 184                         ; call  zap_with_test_data
 185 137c cf97               ret	; and so we're done here.
 186 137e                @@: ; Or, well, not:
 187                     
 188 137e af9f 1328          call   test_file4_lba_block_in_payload_range
 189 1382 77c0 0001          test   r0, 1
 190 1386 c003               jz     @f
 191 1388 af9f 1214          call   load_physical_lba_block_from_icap ; this was a payload block w[physical_lba_uw] and w[physical_lba_lw]
 192                         ; call  zap_with_test_data
 193 138c cf97               ret	; and so we're done here.
 194 138e                @@: ; Or, well, not:
 195                     
 196                         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 197                         ;; call   dbg_print_read_block_index
 198                         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 199                     
 200                         ;; What is it then?
 201                         ;; Primary FAT:
 202 138e 07c3 0000          mov    r3, FAT16_FAT_TABLES_BLOCK_LBA_UW
 203 1392 07c2 0040          mov    r2, FAT16_FAT_TABLES_BLOCK_LBA_LW
 204 1396 07c4 0000          mov    r4, FAT16_FAT_TABLES_BLOCK_LBA_UW ; should work, since we are the 1st partition
 205 139a 07c5 013f          mov    r5, (FAT16_FAT_TABLES_BLOCK_LBA_LW + FAT16_PART0_SECTORS_PER_FAT)
 206 139e af9f 1282          call   test_lba_block_in_range
 207 13a2 77c2 0001          test   r2, 1
 208 13a6 c003               jz     @f
 209 13a8 af9f 149e          call   build_fat16_fat ;; Build FAT
 210 13ac cf97               ret
 211 13ae                @@:
 212                         ;; Secondary FAT:
 213 13ae 07c3 0000          mov    r3, FAT16_FAT_TABLES_COPY_BLOCK_LBA_UW
 214 13b2 07c2 013f          mov    r2, FAT16_FAT_TABLES_COPY_BLOCK_LBA_LW
 215 13b6 07c4 0000          mov    r4, FAT16_FAT_TABLES_COPY_BLOCK_LBA_UW ; should work, since we are the 1st partition
 216 13ba 07c5 023e          mov    r5, (FAT16_FAT_TABLES_COPY_BLOCK_LBA_LW + FAT16_PART0_SECTORS_PER_FAT)
 217 13be af9f 1282          call   test_lba_block_in_range
 218 13c2 77c2 0001          test   r2, 1
 219 13c6 c003               jz     @f
 220 13c8 af9f 149e          call   build_fat16_fat ;; Build FAT
 221 13cc cf97               ret
 222 13ce                @@:
 223                         ;; MBR:
 224 13ce 57e7 0000 127e     cmp    w[actual_lba_lw], MBR_BLOCK_LBA_LW
 225 13d4 c107               jne    @f
 226 13d6 57e7 0000 1280     cmp    w[actual_lba_uw], MBR_BLOCK_LBA_UW
 227 13dc c103               jne    @f
 228                         ;; Build MBR
 229 13de af9f 1482          call   build_fat16_mbr
 230 13e2 cf97               ret
 231                         ;; Boot Block - start of partition:
 232 13e4 57e7 003f 127e @@: cmp    w[actual_lba_lw], FAT16_BOOT_BLOCK_LBA_LW
 233 13ea c107               jne    @f
 234 13ec 57e7 0000 1280     cmp    w[actual_lba_uw], FAT16_BOOT_BLOCK_LBA_UW
 235 13f2 c103               jne    @f
 236 13f4 af9f 1604          call   build_fat16_boot_block
 237 13f8 cf97               ret
 238                         ;; Root Directory Entries:
 239 13fa 57e7 023e 127e @@: cmp    w[actual_lba_lw], FAT16_ROOT_DIRECTORY_ENTRY_LBA_LW
 240 1400 c107               jne    @f
 241 1402 57e7 0000 1280     cmp    w[actual_lba_uw], FAT16_ROOT_DIRECTORY_ENTRY_LBA_UW
 242 1408 c103               jne    @f
 243                         ;; Build Root Dir
 244 140a af9f 15b0          call   build_fat16_root_dir
 245 140e cf97               ret
 246 1410                zero_block: ; default - null block:
 247 1410                @@: 
 248 1410 af9f 0954          call   zap_send_buffer
 249 1414 cf97               ret
 250                     
 251 1416                zap_with_test_data:
 252 1416 07c1 0080          mov    r1, 0x0080
 253 141a 07c9 17a8          mov    r9, send_buffer
 254 141e 09c0 127e          mov    r0, w[actual_lba_lw]
 255 1422 09c2 1280          mov    r2, w[actual_lba_uw]
 256 1426                @@:
 257 1426 0021               mov    w[r9++], r0
 258 1428 00a1               mov    w[r9++], r2
 259 142a da01               dec    r1
 260 142c c17c               jnz    @b
 261 142e cf97               ret
 262                     ;*****************************************************************************
 263                     
 264                     
 265                     ;*****************************************************************************
 266                     ;; Save LBA block
 267                     ;*****************************************************************************
 268 1430                save_lba_block:
 269 1430 af9f 12b6          call   test_lba_block_in_payload_range
 270 1434 77c0 0001          test   r0, 1
 271 1438 c003               jz     @f
 272                         ;; this was a payload block:
 273 143a af9f 169e          call   save_physical_lba_block
 274 143e cf97               ret	; and so we're done here.
 275                     
 276 1440                @@: ;; try second file
 277                     
 278 1440 af9f 12dc          call   test_file2_lba_block_in_payload_range
 279 1444 77c0 0001          test   r0, 1
 280 1448 c003               jz     @f
 281                         ;; this was a payload block:
 282 144a af9f 1190          call   save_physical_lba_block_i2c
 283 144e cf97               ret	; and so we're done here.
 284                     
 285 1450                @@: ;; try third file
 286                     
 287 1450 af9f 1302          call   test_file3_lba_block_in_payload_range
 288 1454 77c0 0001          test   r0, 1
 289 1458 c003               jz     @f
 290                         ;; this was a payload block:
 291 145a af9f 11e2          call   save_physical_lba_block_cy16
 292 145e cf97               ret	; and so we're done here.
 293                     
 294 1460                @@: ;; try fourth file
 295                     
 296 1460 af9f 1328          call   test_file4_lba_block_in_payload_range
 297 1464 77c0 0001          test   r0, 1
 298 1468 c003               jz     @f
 299                         ;; this was a payload block:
 300 146a af9f 1244          call   save_physical_lba_block_icap
 301 146e cf97               ret	; and so we're done here.
 302                     
 303 1470                @@: ;; don't do anything for non-payload blocks...
 304 1470 cf97               ret
 305                     ;*****************************************************************************
 306                     
 307                     
 308                     ;*****************************************************************************
 309                     ;; FAT16 MBR
 310                     ;*****************************************************************************
 311           0000      align 2
 312 1472                part0_mbr_record_data:
 313 1472 00             	db	PART0_STATUS
 314 1473 01             	db	PART0_START_HEAD
 315 1474 01             	db	PART0_START_SECT_76CYLHIGH
 316 1475 00             	db	PART0_START_CYL
 317 1476 0e             	db	PART0_PARTITION_TYPE
 318 1477 7f             	db	PART0_END_HEAD
 319 1478 bf             	db	PART0_END_SECT_76CYLHIGH
 320 1479 05             	db	PART0_END_CYL
 321 147a 003f           	dw	PART0_START_LBA_LW
 322 147c 0000           	dw	PART0_START_LBA_UW
 323 147e bcc1           	dw	PART0_SECTORS_LW
 324 1480 003f           	dw	PART0_SECTORS_UW
 325           00000010  	PART0_MBR_RECORD_DATA_LEN equ ($-part0_mbr_record_data)
 326                     ;*****************************************************************************
 327           0000      align 2
 328 1482                build_fat16_mbr:
 329 1482 af9f 0954          call   zap_send_buffer
 330 1486 07c8 1472          mov    r8, part0_mbr_record_data
 331 148a 07c9 1966          mov    r9, PART0_MBR_RECORD_OFFSET
 332 148e 07c1 0008          mov    r1, (PART0_MBR_RECORD_DATA_LEN >> 1) ; word count
 333 1492 af9f 0baa          call   mem_move
 334 1496 07e7 aa55 19a6     mov    w[BOOT_SIGNATURE_OFFSET], BOOT_SIGNATURE
 335 149c cf97               ret
 336                     ;*****************************************************************************
 337                     
 338                     
 339                     ;*****************************************************************************
 340                     ;; FAT16 FAT
 341                     ;*****************************************************************************
 342                     ;; ! QTASM IS RETARDED ! QTASM IS RETARDED ! QTASM IS RETARDED ! QTASM IS RETARDED
 343                     ;*****************************************************************************
 344                     ;; FAT16_PART0_SECTORS_PER_CLUSTER == 0x040
 345                     ;; FAKE_FILE_BYTES		equ	0x100000 ; 1 MB
 346                     ;; FAT16_CLUSTER_SIZE		equ	(0x040 * BLOCKSIZE)
 347                     ;; FAKE_FILE_CLUSTERS		equ	(FAKE_FILE_BYTES / FAT16_CLUSTER_SIZE)
 348                     ;*****************************************************************************
 349                     ;; ! QTASM IS RETARDED ! QTASM IS RETARDED ! QTASM IS RETARDED ! QTASM IS RETARDED
 350                     ;*****************************************************************************
 351                     
 352           0000      align 2
 353 149e                build_fat16_fat:
 354                         ;; r0 contains index of FAT page to load (0...FF)
 355 149e 07c9 17a8          mov    r9, send_buffer
 356 14a2 6000               and    r0, r0
 357 14a4 c109               jnz    @f
 358                         ;; If we were asked for the first page of the FAT:
 359 14a6 07e1 fff8          mov    w[r9++], 0xfff8 ; Partition Type = HDD (0xf8);
 360 14aa 07e1 ffff          mov    w[r9++], 0xffff ; State = Good (0xff) - TODO: Might need to be writable for mount! <---- Should we make this dirty?
 361 14ae 07e1 0000          mov    w[r9++], 0x0000 ; Cluster 0 is reserved, and its address is 2.
 362 14b2 07c0 0004          mov    r0, FIRST_CLUSTER_INDEX ; Number of first cluster of file + 1
 363 14b6 cf0d               jmp    build_fat
 364 14b8                @@: ;; Not the first page:
 365 14b8 0001               mov    r1, r0
 366 14ba 9000               xor    r0, r0
 367 14bc                @@:
 368 14bc 17c0 0100          add    r0, 0x0100 ; 512 is block, 2 bytes per entry, 256 entries
 369 14c0 da01               subi   r1, 1      ; find out where we are r0=256*FAT page number (0..FF) -- are we past the allocated clusters?
 370 14c2 c17c               jnz    @b
 371                         ;; if we're past the last page?
 372 14c4 57c0 011d          cmp    r0, (FAKE_FILE_CLUSTERS+FAKE_FILE2_CLUSTERS+FAKE_FILE3_CLUSTERS+FAKE_FILE4_CLUSTERS)
 373 14c8 c903               jbe    @f
 374 14ca af9f 0954          call   zap_send_buffer
 375 14ce cf1f               jmp    fat_build_done
 376 14d0                @@: ;; now, r0 is either 3+1 (page 0) or 0xFF * page-index.
 377 14d0 d800               addi   r0, 1
 378                         ;; r0 is where we are pointing next
 379 14d2                build_fat:
 380 14d2                @@:
 381                         ;; block full?
 382 14d2 57c9 19a8          cmp    r9, (send_buffer + BLOCKSIZE) ; stop if the block is full
 383 14d6 c01b               je     fat_build_done
 384                         ;; There is room:
 385                         ;; cmp    r0, (FIRST_CLUSTER_INDEX + FAKE_FILE_CLUSTERS + FAKE_FILE2_CLUSTERS - 1)
 386 14d8 57c0 011d          cmp    r0, (FIRST_CLUSTER_INDEX + FAKE_FILE_CLUSTERS - 1)
 387 14dc c00c               je     penult_cluster ; this was the penultimate cluster for file1
 388 14de 57c0 011e          cmp    r0, (FIRST_CLUSTER_INDEX + FAKE_FILE_CLUSTERS + FAKE_FILE2_CLUSTERS - 1)
 389 14e2 c009               je     penult_cluster ; this was the penultimate cluster for file2
 390 14e4 57c0 011f          cmp    r0, (FIRST_CLUSTER_INDEX + FAKE_FILE_CLUSTERS + FAKE_FILE2_CLUSTERS + FAKE_FILE3_CLUSTERS - 1)
 391 14e8 c006               je     penult_cluster ; this was the penultimate cluster for file2
 392 14ea 57c0 0120          cmp    r0, (FIRST_CLUSTER_INDEX + FAKE_FILE_CLUSTERS + FAKE_FILE2_CLUSTERS + FAKE_FILE3_CLUSTERS + FAKE_FILE4_CLUSTERS - 1)
 393 14ee c003               je     penult_cluster ; this was the penultimate cluster for file2
 394 14f0 0021               mov    w[r9++], r0
 395 14f2 d800               addi   r0, 1
 396 14f4 cf6e               jmp    @b ; keep adding cluster records.
 397                     
 398 14f6                penult_cluster:
 399 14f6 07e1 ffff          mov    w[r9++], 0xFFFF ; Now write the last cluster of file.
 400 14fa d800               addi   r0, 1
 401 14fc 57c0 0120          cmp    r0, (FIRST_CLUSTER_INDEX + FAKE_FILE_CLUSTERS + FAKE_FILE2_CLUSTERS + FAKE_FILE3_CLUSTERS + FAKE_FILE4_CLUSTERS - 1)
 402 1500 c968               jbe     build_fat ; still need to build file2,3,4
 403                     
 404                         ;; this was file2 -- clean the rest
 405 1502 9000               xor    r0, r0 ; r0=0
 406 1504                @@:
 407 1504 57c9 19a8          cmp    r9, (send_buffer + BLOCKSIZE) ; stop if the block is full
 408 1508 c002               je     fat_build_done
 409 150a 0021               mov    w[r9++], r0 ; fill the rest with zeros
 410 150c cf7b               jmp    @b
 411 150e                fat_build_done:
 412 150e cf97               ret
 413                     ;*****************************************************************************
 414                     
 415                     
 416                     ;*****************************************************************************
 417                     ;; FAT16 Root Directory
 418                     ;*****************************************************************************
 419                     ;; Note: Linux actually tries to write access dates here, upon sync.
 420                     ;; But we don't care. There is no good reason to waste EEPROM write cycles
 421                     ;; only to store such garbage. The FAT16 bookkeeping will be kept constant.
 422                     ;*****************************************************************************
 423           0000      align 2
 424 1510                fat16_root_dir_data:
 425                             ;; *****************************************************************
 426                             ;; Volume Label
 427                             ;; *****************************************************************
 428 1510 53 54 49 52 4c 	db      'STIRLITZ   ' ; Volume Label (8 chars body + 3 chars ext)
          49 54 5a 20 20 
          20 
 429 151b 08             	db	0x08   ; Attrib = 0x08 (Volume Label)
 430 151c 0000           	dw	0x0000 ; b. 12 - n/a; b. 13 - creation time (10th of secs)
 431 151e 0000           	dw	0x0000 ; 14, 15: creation time (hours, minutes, seconds)
 432 1520 0000           	dw	0x0000 ; creation date
 433 1522 0000           	dw	0x0000 ; access date
 434 1524 0000           	dw	0x0000 ; high word of 1st cluster address
 435 1526 0000           	dw	0x0000 ; modified time (hours, minutes, seconds)
 436 1528 0000           	dw	0x0000 ; modified date
 437 152a 0000           	dw	0x0000 ; low word of 1st cluster address
 438 152c 0000           	dw	0x0000 ; lower word of size (0 for directories)
 439 152e 0000           	dw	0x0000 ; upper word of size (0 for directories)
 440                             ;; *****************************************************************
 441                     	;; If we wanted long file name, it would live here...
 442                     	;; *****************************************************************
 443                             ;; The File itself
 444                             ;; *****************************************************************
 445 1530 42 50 49 20 20     	db      'BPI     BIN' ; Volume Label (8 chars body + 3 chars ext)
          20 20 20 42 49 
          4e 
 446 153b 20             	db	0x20   ; Attrib = 0x20 ("Archive")
 447 153c 0000           	dw	0x0000 ; b. 12 - n/a; b. 13 - creation time (10th of secs)
 448 153e 0000           	dw	0x0000 ; 14, 15: creation time (hours, minutes, seconds)
 449 1540 0000           	dw	0x0000 ; creation date
 450 1542 0000           	dw	0x0000 ; access date
 451 1544 0000           	dw	0x0000 ; high word of 1st cluster address
 452 1546 0000           	dw	0x0000 ; modified time (hours, minutes, seconds)
 453 1548 0000           	dw	0x0000 ; modified date
 454 154a 0003           	dw	0x0003 ; low word of 1st cluster address
 455 154c e03c           	dw	FILE_SIZE_LW ; lower word of size (0 for directories)
 456 154e 008c           	dw	FILE_SIZE_UW ; upper word of size (0 for directories)	
 457                     	;; *****************************************************************
 458                             ;; The File itself
 459                             ;; *****************************************************************
 460 1550 49 32 43 20 20     	db      'I2C     BIN' ; Volume Label (8 chars body + 3 chars ext)
          20 20 20 42 49 
          4e 
 461 155b 20             	db	0x20   ; Attrib = 0x20 ("Archive")
 462 155c 0000           	dw	0x0000 ; b. 12 - n/a; b. 13 - creation time (10th of secs)
 463 155e 0000           	dw	0x0000 ; 14, 15: creation time (hours, minutes, seconds)
 464 1560 0000           	dw	0x0000 ; creation date
 465 1562 0000           	dw	0x0000 ; access date
 466 1564 0000           	dw	0x0000 ; high word of 1st cluster address
 467 1566 0000           	dw	0x0000 ; modified time (hours, minutes, seconds)
 468 1568 0000           	dw	0x0000 ; modified date
 469 156a 011d           	dw	FILE2_CLUSTER_START_LW ; low word of 1st cluster address
 470 156c 4000           	dw	FILE2_SIZE_LW ; lower word of size (0 for directories)
 471 156e 0000           	dw	FILE2_SIZE_UW ; upper word of size (0 for directories)	
 472                     	;; *****************************************************************
 473                             ;; The File itself
 474                             ;; *****************************************************************
 475 1570 43 59 31 36 20     	db      'CY16    BIN' ; Volume Label (8 chars body + 3 chars ext)
          20 20 20 42 49 
          4e 
 476 157b 20             	db	0x20   ; Attrib = 0x20 ("Archive")
 477 157c 0000           	dw	0x0000 ; b. 12 - n/a; b. 13 - creation time (10th of secs)
 478 157e 0000           	dw	0x0000 ; 14, 15: creation time (hours, minutes, seconds)
 479 1580 0000           	dw	0x0000 ; creation date
 480 1582 0000           	dw	0x0000 ; access date
 481 1584 0000           	dw	0x0000 ; high word of 1st cluster address
 482 1586 0000           	dw	0x0000 ; modified time (hours, minutes, seconds)
 483 1588 0000           	dw	0x0000 ; modified date
 484 158a 011e           	dw	FILE3_CLUSTER_START_LW ; low word of 1st cluster address
 485 158c 0200           	dw	FILE3_SIZE_LW ; lower word of size (0 for directories)
 486 158e 0000           	dw	FILE3_SIZE_UW ; upper word of size (0 for directories)	
 487                     	;; *****************************************************************
 488                             ;; The File itself
 489                             ;; *****************************************************************
 490 1590 49 43 41 50 20     	db      'ICAP    BIN' ; Volume Label (8 chars body + 3 chars ext)
          20 20 20 42 49 
          4e 
 491 159b 20             	db	0x20   ; Attrib = 0x20 ("Archive")
 492 159c 0000           	dw	0x0000 ; b. 12 - n/a; b. 13 - creation time (10th of secs)
 493 159e 0000           	dw	0x0000 ; 14, 15: creation time (hours, minutes, seconds)
 494 15a0 0000           	dw	0x0000 ; creation date
 495 15a2 0000           	dw	0x0000 ; access date
 496 15a4 0000           	dw	0x0000 ; high word of 1st cluster address
 497 15a6 0000           	dw	0x0000 ; modified time (hours, minutes, seconds)
 498 15a8 0000           	dw	0x0000 ; modified date
 499 15aa 011f           	dw	FILE4_CLUSTER_START_LW ; low word of 1st cluster address
 500 15ac 0200           	dw	FILE4_SIZE_LW ; lower word of size (0 for directories)
 501 15ae 0000           	dw	FILE4_SIZE_UW ; upper word of size (0 for directories)	
 502                             ;; *****************************************************************
 503           000000a0  	FAT16_ROOT_DIR_DATA_LEN equ ($-fat16_root_dir_data)
 504                     ;*****************************************************************************
 505           0000      align 2
 506 15b0                build_fat16_root_dir:
 507 15b0 af9f 0954          call   zap_send_buffer
 508 15b4 07c8 1510          mov    r8, fat16_root_dir_data
 509 15b8 07c9 17a8          mov    r9, send_buffer
 510 15bc 07c1 0050          mov    r1, (FAT16_ROOT_DIR_DATA_LEN >> 1) ; word count
 511 15c0 af9f 0baa          call   mem_move
 512 15c4 cf97               ret
 513                     ;*****************************************************************************
 514                     
 515                     
 516                     ;*****************************************************************************
 517                     ;; FAT16 Boot Block
 518                     ;*****************************************************************************
 519           0000      align 2
 520 15c6                boot_block_data:
 521 15c6 eb                 	db	0xeb ; jmp
 522 15c7 3c             	db	0x3c ; jmp
 523 15c8 90             	db	0x90 ; nop
 524 15c9 4d 53 57 49 4e 	db      'MSWIN4.0' ; OEM name (8 chars)
          34 2e 30 
 525 15d1 0200           	dw      FAT16_PART0_BYTES_PER_SECTOR
 526 15d3 40             	db      FAT16_PART0_SECTORS_PER_CLUSTER
 527 15d4 0001           	dw      FAT16_PART0_RESERVED_SECTORS
 528 15d6 02             	db      FAT16_PART0_COPIES_OF_FAT
 529 15d7 0200           	dw      FAT16_PART0_MAX_ROOT_DIR_ENTRIES
 530 15d9 0000           	dw      FAT16_PART0_MAX_SECTS_IF_UNDR_32M
 531 15db f8             	db      FAT16_PART0_MEDIA_DESCRIPTOR
 532 15dc 00ff           	dw      FAT16_PART0_SECTORS_PER_FAT
 533 15de 003f           	dw      FAT16_PART0_SECTORS_PER_TRACK
 534 15e0 0080           	dw      FAT16_PART0_HEADS
 535 15e2 003f           	dw      PART0_START_LBA_LW ; # of hidden sectors (LW) from MBR
 536 15e4 0000           	dw      PART0_START_LBA_UW ; # of hidden sectors (UW) from MBR
 537 15e6 bcc1           	dw      PART0_SECTORS_LW ; # of sectors (LW) from MBR
 538 15e8 003f           	dw      PART0_SECTORS_UW ; # of sectors (UW) from MBR
 539 15ea 0080           	dw      FAT16_PART0_LOGICAL_DRIVE_NUMBER
 540 15ec 29             	db      FAT16_PART0_EXTENDED_SIGNATURE
 541 15ed 5f7b           	dw      FAT16_PART0_PARTITION_SERIAL_NUM_LW
 542 15ef 4f30           	dw      FAT16_PART0_PARTITION_SERIAL_NUM_UW
 543 15f1 53 54 49 45 52 	db	'STIERLITZ  ' ; Volume name of partition (11 chars)
          4c 49 54 5a 20 
          20 
 544 15fc 46 41 54 31 36 	db      'FAT16   ' ; FAT Name (must equal "FAT16   ")
          20 20 20 
 545           0000003e  	BOOT_BLOCK_DATA_LEN equ ($-boot_block_data)
 546                     ;*****************************************************************************
 547           0000      align 2
 548 1604                build_fat16_boot_block:
 549 1604 07c8 15c6          mov    r8, boot_block_data
 550 1608 07c9 17a8          mov    r9, send_buffer
 551 160c 07c1 001f          mov    r1, (BOOT_BLOCK_DATA_LEN >> 1) ; word count
 552 1610 af9f 0baa          call   mem_move
 553                         ;; fill remainder:
 554 1614 07c9 17e6          mov    r9, (send_buffer + BOOT_BLOCK_DATA_LEN) ; redundant?
 555 1618 07c1 00e0          mov    r1, (((BLOCKSIZE - BOOT_BLOCK_DATA_LEN) >> 1) - 1)
 556 161c                @@:
 557 161c 07e1 f6f6          mov    w[r9++], FAT16_BOOT_BLOCK_FILLER
 558 1620 da01               dec    r1
 559 1622 c17c               jnz    @b
 560 1624 07e7 aa55 19a6     mov    w[BOOT_SIGNATURE_OFFSET], BOOT_SIGNATURE
 561 162a cf97               ret
 562                     ;*****************************************************************************

 139                     include hpi.asm

   0                      ;; /*************************************************************************
   1                      ;; *                     This file is part of Stierlitz:                    *
   2                      ;; *               https://github.com/asciilifeform/Stierlitz               *
   3                      ;; *************************************************************************/
   4                     
   5                      ;; /*************************************************************************
   6                      ;; *                (c) Copyright 2012 Stanislav Datskovskiy                *
   7                      ;; *                         http://www.loper-os.org                        *
   8                      ;; **************************************************************************
   9                      ;; *                                                                        *
  10                      ;; *  This program is free software: you can redistribute it and/or modify  *
  11                      ;; *  it under the terms of the GNU General Public License as published by  *
  12                      ;; *  the Free Software Foundation, either version 3 of the License, or     *
  13                      ;; *  (at your option) any later version.                                   *
  14                      ;; *                                                                        *
  15                      ;; *  This program is distributed in the hope that it will be useful,       *
  16                      ;; *  but WITHOUT ANY WARRANTY; without even the implied warranty of        *
  17                      ;; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
  18                      ;; *  GNU General Public License for more details.                          *
  19                      ;; *                                                                        *
  20                      ;; *  You should have received a copy of the GNU General Public License     *
  21                      ;; *  along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  22                      ;; *                                                                        *
  23                      ;; *************************************************************************/
  24                     
  25                     
  26                     ;*****************************************************************************
  27                     ;; Spin until host reads HPI
  28                     ;*****************************************************************************
  29                     ;; TODO: timeouts
  30 162c                wait_for_hpi_read:
  31 162c                @@:
  32 162c 57ef 0001 079a     cmp    b[hpi_was_read], 0x01
  33 1632 c17c               jne    @b
  34 1634 07ef 0000 079a     mov    b[hpi_was_read], 0x00
  35 163a cf97               ret
  36                     ;*****************************************************************************
  37                     
  38                     
  39                     ;*****************************************************************************
  40                     ;; Spin until host writes HPI
  41                     ;*****************************************************************************
  42                     ;; TODO: timeouts
  43 163c                wait_for_hpi_written:
  44 163c                @@:
  45 163c 57ef 0001 07a8     cmp    b[hpi_was_written], 0x01
  46 1642 c17c               jne    @b
  47 1644 07ef 0000 07a8     mov    b[hpi_was_written], 0x00
  48 164a cf97               ret
  49                     ;*****************************************************************************
  50                     
  51                     
  52                     ;*****************************************************************************
  53                     ;; Send r0 to HPI port, synchronously
  54                     ;*****************************************************************************
  55 164c                hpi_mb_tx:
  56 164c 0027 c0c6          mov    w[HPI_MAILBOX_REG], r0
  57 1650 af9f 162c          call   wait_for_hpi_read
  58 1654 cf97               ret
  59                     ;*****************************************************************************
  60                     
  61                     
  62                     ;*****************************************************************************
  63                     ;; Receive r0 from HPI port, synchronously
  64                     ;*****************************************************************************
  65 1656                hpi_mb_rx:
  66 1656 af9f 163c          call   wait_for_hpi_written
  67 165a 09c0 c0c6          mov    r0, w[HPI_MAILBOX_REG]
  68 165e cf97               ret
  69                     ;*****************************************************************************

 140                     include payload.asm

   0                      ;; /*************************************************************************
   1                      ;; *                     This file is part of Stierlitz:                    *
   2                      ;; *               https://github.com/asciilifeform/Stierlitz               *
   3                      ;; *************************************************************************/
   4                     
   5                      ;; /*************************************************************************
   6                      ;; *                (c) Copyright 2012 Stanislav Datskovskiy                *
   7                      ;; *                         http://www.loper-os.org                        *
   8                      ;; **************************************************************************
   9                      ;; *                                                                        *
  10                      ;; *  This program is free software: you can redistribute it and/or modify  *
  11                      ;; *  it under the terms of the GNU General Public License as published by  *
  12                      ;; *  the Free Software Foundation, either version 3 of the License, or     *
  13                      ;; *  (at your option) any later version.                                   *
  14                      ;; *                                                                        *
  15                      ;; *  This program is distributed in the hope that it will be useful,       *
  16                      ;; *  but WITHOUT ANY WARRANTY; without even the implied warranty of        *
  17                      ;; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
  18                      ;; *  GNU General Public License for more details.                          *
  19                      ;; *                                                                        *
  20                      ;; *  You should have received a copy of the GNU General Public License     *
  21                      ;; *  along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  22                      ;; *                                                                        *
  23                      ;; *************************************************************************/
  24                     
  25                      
  26                     ;*****************************************************************************
  27 1660 0000           physical_lba_lw			dw 0x0000
  28 1662 0000           physical_lba_uw			dw 0x0000
  29                     ;*****************************************************************************
  30                     
  31                     ;*****************************************************************************
  32                     ;; Load physical LBA block.
  33                     ;*****************************************************************************
  34 1664                load_physical_lba_block:
  35 1664 af9f 16d8          call   send_host_physical_lba
  36                     
  37 1668 07c1 0100          mov    r1, 0x0100
  38 166c 07c9 17a8          mov    r9, send_buffer
  39 1670                @@:
  40 1670 07c0 4000          mov    r0, 0x4000 ; Read byte from bus
  41 1674 af9f 164c          call   hpi_mb_tx  ; Send read command
  42 1678 af9f 1656          call   hpi_mb_rx  ; Receive result
  43 167c 67c0 00ff          and    r0, 0x00FF
  44                     
  45 1680 0002               mov    r2, r0
  46                         
  47 1682 07c0 4000          mov    r0, 0x4000 ; Read byte from bus
  48 1686 af9f 164c          call   hpi_mb_tx  ; Send read command
  49 168a af9f 1656          call   hpi_mb_rx  ; Receive result
  50 168e 67c0 00ff          and    r0, 0x00FF
  51 1692 d3c0               shl    r0, 8
  52                     
  53 1694 8002               or     r2, r0
  54                         
  55 1696 00a1               mov    w[r9++], r2
  56 1698 da01               dec    r1
  57 169a c16a               jnz    @b
  58                     
  59 169c cf97               ret
  60                     ;*****************************************************************************
  61                     
  62                     
  63                     ;*****************************************************************************
  64                     ;; Save physical LBA block.
  65                     ;*****************************************************************************
  66 169e                save_physical_lba_block:
  67 169e af9f 16d8          call   send_host_physical_lba
  68                     
  69 16a2 07c1 0100          mov    r1, 0x0100
  70 16a6 07c9 1ba8          mov    r9, block_receive_buffer
  71 16aa                @@:
  72 16aa 0842               mov    r2, w[r9++]
  73                     
  74 16ac 0080               mov    r0, r2
  75 16ae 67c0 00ff          and    r0, 0x00FF
  76 16b2 87c0 8000          or     r0, 0x8000 ; Write byte to bus
  77 16b6 af9f 164c          call   hpi_mb_tx  ; Send write command
  78 16ba af9f 1656          call   hpi_mb_rx  ; Receive confirmation
  79                     
  80 16be 0080               mov    r0, r2
  81 16c0 d1c0               shr    r0, 8
  82 16c2 67c0 00ff          and    r0, 0x00FF
  83 16c6 87c0 8000          or     r0, 0x8000 ; Write byte to bus
  84 16ca af9f 164c          call   hpi_mb_tx  ; Send write command
  85 16ce af9f 1656          call   hpi_mb_rx  ; Receive confirmation
  86                         
  87 16d2 da01               dec    r1
  88 16d4 c16a               jnz    @b
  89 16d6 cf97               ret    
  90                     ;*****************************************************************************
  91                     
  92                     
  93                     ;*****************************************************************************
  94                     ;; Set host's LBA registers.
  95                     ;*****************************************************************************
  96 16d8                send_host_physical_lba:
  97                         ;; Send LBA[0]:
  98 16d8 09c0 1660          mov    r0, w[physical_lba_lw]
  99 16dc 67c0 00ff          and    r0, 0xFF
 100 16e0 af9f 164c          call   hpi_mb_tx
 101                         ;; Send LBA[1]:
 102 16e4 09c0 1660          mov    r0, w[physical_lba_lw]
 103 16e8 d1c0               shr    r0, 8
 104 16ea 67c0 00ff          and    r0, 0xFF
 105 16ee 87c0 0100          or     r0, 0x100
 106 16f2 af9f 164c          call   hpi_mb_tx
 107                         ;; Send LBA[2]:
 108 16f6 09c0 1662          mov    r0, w[physical_lba_uw]
 109 16fa d1c0               shr    r0, 8
 110 16fc 67c0 00ff          and    r0, 0xFF
 111 1700 87c0 0200          or     r0, 0x200
 112 1704 af9f 164c          call   hpi_mb_tx
 113                         ;; Send LBA[3]:
 114 1708 09c0 1662          mov    r0, w[physical_lba_uw]
 115 170c 67c0 00ff          and    r0, 0xFF
 116 1710 87c0 0300          or     r0, 0x300
 117 1714 af9f 164c          call   hpi_mb_tx
 118 1718 cf97               ret
 119                     ;*****************************************************************************
 120                     
 121                     
 122                     ;; ;*****************************************************************************
 123                     ;; ;; Load physical LBA block.
 124                     ;; ;*****************************************************************************
 125                     ;; load_physical_lba_block:
 126                     ;;     call   send_host_physical_lba
 127                     
 128                     ;;     ;; right now, just a lame test.
 129                     ;;     mov    r1, 0x0080
 130                     ;;     mov    r9, send_buffer
 131                     ;; @@:
 132                     ;;     mov    w[r9++], w[physical_lba_lw]
 133                     ;;     mov    w[r9++], w[physical_lba_uw]
 134                     ;;     dec    r1
 135                     ;;     jnz    @b
 136                     ;;     ret
 137                     ;; ;*****************************************************************************
 138                     
 139                     ;; ;*****************************************************************************
 140                     ;; ;; Save physical LBA block.
 141                     ;; ;*****************************************************************************
 142                     ;; save_physical_lba_block:
 143                     ;;     call   send_host_physical_lba
 144                     
 145                     ;;     ;; right now, a test.
 146                     ;;     int    PUSHALL_INT
 147                     ;;     ;;-------------------------------------------
 148                     ;;     ;; See if expected values match:
 149                     ;;     mov    r1, 0x0080
 150                     ;;     mov    r9, block_receive_buffer
 151                     ;; @@:
 152                     ;;     mov    r0, w[r9++]
 153                     ;;     cmp    r0, w[physical_lba_lw]
 154                     ;;     jne    sad_block
 155                     ;;     mov    r2, w[r9++]
 156                     ;;     cmp    r2, w[physical_lba_uw]
 157                     ;;     jne    sad_block
 158                     ;;     dec    r1
 159                     ;;     jnz    @b
 160                     ;;     ;; all ok:
 161                     ;;     jmp    happy_block
 162                     ;; sad_block:
 163                     ;;     mov    w[Debug_LW], r0
 164                     ;;     mov    w[Debug_UW], r2
 165                     ;;     mov	   r0, 0x004E		; N
 166                     ;;     call   dbg_putchar
 167                     ;;     mov    w[Debug_Title], 0x42 ; B
 168                     ;;     call   dbg_print_32bit
 169                     ;;     mov	   r0, 0x0020		; [space]
 170                     ;;     call   dbg_putchar
 171                     ;;     mov	   r0, 0x004E		; N
 172                     ;;     call   dbg_putchar
 173                     ;;     mov	   r0, 0x004F		; O
 174                     ;;     call   dbg_putchar
 175                     ;;     ;; test
 176                     ;;     call   print_newline
 177                     ;;     mov    w[Debug_LW], w[physical_lba_lw]
 178                     ;;     mov    w[Debug_UW], 0x0000
 179                     ;;     mov    w[Debug_Title], 0x49 ; I
 180                     ;;     call   dbg_print_32bit
 181                     ;;     call   print_newline
 182                     ;;     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 183                     ;; happy_block:
 184                     ;;     ;; mov	   r0, 0x004F		; O
 185                     ;;     ;; call   dbg_putchar
 186                     ;;     ;; mov	   r0, 0x004B		; K
 187                     ;;     ;; call   dbg_putchar
 188                     ;; done_block:
 189                     ;;     ;;-------------------------------------------
 190                     ;;     int    POPALL_INT
 191                     ;;     ret
 192                     ;; ;*****************************************************************************
 193                     
 194                     

 141                     include scsi-state.asm

   0                      ;; /*************************************************************************
   1                      ;; *                     This file is part of Stierlitz:                    *
   2                      ;; *               https://github.com/asciilifeform/Stierlitz               *
   3                      ;; *************************************************************************/
   4                     
   5                      ;; /*************************************************************************
   6                      ;; *                (c) Copyright 2012 Stanislav Datskovskiy                *
   7                      ;; *                         http://www.loper-os.org                        *
   8                      ;; **************************************************************************
   9                      ;; *                                                                        *
  10                      ;; *  This program is free software: you can redistribute it and/or modify  *
  11                      ;; *  it under the terms of the GNU General Public License as published by  *
  12                      ;; *  the Free Software Foundation, either version 3 of the License, or     *
  13                      ;; *  (at your option) any later version.                                   *
  14                      ;; *                                                                        *
  15                      ;; *  This program is distributed in the hope that it will be useful,       *
  16                      ;; *  but WITHOUT ANY WARRANTY; without even the implied warranty of        *
  17                      ;; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
  18                      ;; *  GNU General Public License for more details.                          *
  19                      ;; *                                                                        *
  20                      ;; *  You should have received a copy of the GNU General Public License     *
  21                      ;; *  along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  22                      ;; *                                                                        *
  23                      ;; *************************************************************************/
  24                     
  25                     
  26                     ;*****************************************************************************
  27                     ;; SCSI State
  28                     ;*****************************************************************************
  29                     ;; sense key
  30 171a                SCSI_dw_sense:
  31 171a 0000           SCSI_dw_sense_lw		dw 0x0000
  32 171c 0000           SCSI_dw_sense_uw		dw 0x0000
  33                     
  34                     ;; hex: 00aabbcc, where aa=KEY, bb=ASC, cc=ASCQ
  35           0000171b  dwSense_KEY			EQU	(SCSI_dw_sense + 1)
  36           0000171c  dwSense_ASC			EQU	(SCSI_dw_sense + 2)
  37           0000171d  dwSense_ASCQ			EQU	(SCSI_dw_sense + 3)
  38                     
  39                     ;; state machine state
  40 171e                scsi_state:
  41 171e 00                 db				0x00
  42                     ;; Possible states:
  43           00000000  SCSI_state_CBW		EQU	0x00
  44           00000001  SCSI_state_data_out	EQU	0x01
  45           00000002  SCSI_state_data_in	EQU	0x02
  46           00000003  SCSI_state_CSW		EQU	0x03
  47           00000004  SCSI_state_stalled	EQU	0x04
  48                     ;*****************************************************************************
  49                     
  50                     ;*****************************************************************************
  51                     ;; SCSI Command Block Wrapper (received)
  52                     ;*****************************************************************************
  53           0000001f  CBW_Size			EQU	0x1F
  54           000019a8  MSC_CBW_Signature_lw		EQU	(receive_buffer)
  55           000019aa  MSC_CBW_Signature_uw		EQU	(receive_buffer + 2)
  56           000019ac  CBW_tag_lw			EQU	(receive_buffer + 4)
  57           000019ae  CBW_tag_uw			EQU	(receive_buffer + 6)
  58           000019b0  CBW_data_transfer_length_lw	EQU	(receive_buffer + 8)
  59           000019b2  CBW_data_transfer_length_uw	EQU	(receive_buffer + 10)
  60           000019b4  CBW_flags			EQU	(receive_buffer + 12)
  61           000019b5  CBW_lun				EQU	(receive_buffer + 13)
  62           000019b6  CBW_cb_length			EQU	(receive_buffer + 14)
  63           000019b7  CBW_cb				EQU	(receive_buffer + 15)
  64                     ;*****************************************************************************
  65                     
  66                     ;*****************************************************************************
  67                     ;; All SCSI Command CDBs
  68                     ;*****************************************************************************
  69           000019b7  Common_SCSI_CDB_op_code		EQU	(CBW_cb)
  70                     ;*****************************************************************************
  71                     
  72                     ;*****************************************************************************
  73                     ;; 'Inquiry' SCSI Command
  74                     ;*****************************************************************************
  75           000019bb  Inquiry_SCSI_CDB_bLength	EQU	(CBW_cb + 4)
  76                     ;*****************************************************************************
  77                     
  78                     ;*****************************************************************************
  79                     ;; 'Request Sense' SCSI Command
  80                     ;*****************************************************************************
  81           000019bb  Request_Sense_SCSI_CDB_bLength	EQU	(CBW_cb + 4)
  82                     ;*****************************************************************************
  83                     
  84                     ;*****************************************************************************
  85                     ;; 'Read-10' SCSI Command
  86                     ;*****************************************************************************
  87           000019b8  Read10_SCSI_CDB_LUN_etc		EQU	(CBW_cb + 1)
  88           000019b9  Read10_SCSI_CDB_LBA_3		EQU	(CBW_cb + 2)
  89           000019ba  Read10_SCSI_CDB_LBA_2		EQU	(CBW_cb + 3)
  90           000019bb  Read10_SCSI_CDB_LBA_1		EQU	(CBW_cb + 4)
  91           000019bc  Read10_SCSI_CDB_LBA_0		EQU	(CBW_cb + 5)
  92           000019be  Read10_SCSI_CDB_Transfer_Len_1	EQU	(CBW_cb + 7)
  93           000019bf  Read10_SCSI_CDB_Transfer_Len_0	EQU	(CBW_cb + 8)
  94                     ;*****************************************************************************
  95                     
  96                     ;*****************************************************************************
  97                     ;; 'Write-10' SCSI Command
  98                     ;*****************************************************************************
  99           000019b8  Write10_SCSI_CDB_LUN_etc	EQU	(CBW_cb + 1)
 100           000019b9  Write10_SCSI_CDB_LBA_3		EQU	(CBW_cb + 2)
 101           000019ba  Write10_SCSI_CDB_LBA_2		EQU	(CBW_cb + 3)
 102           000019bb  Write10_SCSI_CDB_LBA_1		EQU	(CBW_cb + 4)
 103           000019bc  Write10_SCSI_CDB_LBA_0		EQU	(CBW_cb + 5)
 104           000019be  Write10_SCSI_CDB_Transfer_Len_1	EQU	(CBW_cb + 7)
 105           000019bf  Write10_SCSI_CDB_Transfer_Len_0	EQU	(CBW_cb + 8)
 106                     ;*****************************************************************************
 107                     
 108                     ;*****************************************************************************
 109                     ;; SCSI Command Status Wrapper (to send to host)
 110                     ;*****************************************************************************
 111           0000000d  CSW_Size			EQU	13
 112           000017a8  MSC_CSW_Signature_lw		EQU	(send_buffer)
 113           000017aa  MSC_CSW_Signature_uw		EQU	(send_buffer + 2)
 114           000017ac  CSW_tag_lw			EQU	(send_buffer + 4)
 115           000017ae  CSW_tag_uw			EQU	(send_buffer + 6)
 116           000017b0  CSW_data_residue_lw		EQU	(send_buffer + 8)
 117           000017b2  CSW_data_residue_uw		EQU	(send_buffer + 10)
 118           000017b4  CSW_status			EQU	(send_buffer + 12)
 119                     ;*****************************************************************************
 120                     
 121                     ;*****************************************************************************
 122                     ;; Inquiry Response
 123                     ;*****************************************************************************
 124           0001      align 2
 125 1720                SCSI_inquiry_response:
 126 1720 00                 db		0x00		; Device = Direct Access
 127 1721 80                 db		0x80		; RMB = 1: Removable Medium
 128 1722 00                 db		0x00		; Standard Version = None
 129 1723 01                 db		0x01		; Data Format = unknown
 130 1724 20                 db		(INQ_ADD_LEN-4)	; Additional Length
 131 1725 00                 db		0x00		; Flags: nothing special
 132 1726 00                 db		0x00		; Flags: normal device, no extra features
 133 1727 00                 db		0x00		; Flags: no rel. addressing, sync. xmit, linked commands, or queuing
 134 1728 4c 6f 70 65 72     db          'Loper OS'	; Manufacturer ID (bytes 8..15)
          20 4f 53 
 135 1730 42 75 73 20 74     db		'Bus to Thumb Drv' ; Product ID (bytes 16..31)
          6f 20 54 68 75 
          6d 62 20 44 72 
          76 
 136 1740 31 2e 30 30        db		'1.00'		; Product Revision Level (Bytes 32..35)
 137           00000024      INQ_ADD_LEN equ ($-SCSI_inquiry_response)
 138                     ;*****************************************************************************

 142                     include descriptor.asm

   0                      ;; /*************************************************************************
   1                      ;; *                     This file is part of Stierlitz:                    *
   2                      ;; *               https://github.com/asciilifeform/Stierlitz               *
   3                      ;; *************************************************************************/
   4                     
   5                      ;; /*************************************************************************
   6                      ;; *                (c) Copyright 2012 Stanislav Datskovskiy                *
   7                      ;; *                         http://www.loper-os.org                        *
   8                      ;; **************************************************************************
   9                      ;; *                                                                        *
  10                      ;; *  This program is free software: you can redistribute it and/or modify  *
  11                      ;; *  it under the terms of the GNU General Public License as published by  *
  12                      ;; *  the Free Software Foundation, either version 3 of the License, or     *
  13                      ;; *  (at your option) any later version.                                   *
  14                      ;; *                                                                        *
  15                      ;; *  This program is distributed in the hope that it will be useful,       *
  16                      ;; *  but WITHOUT ANY WARRANTY; without even the implied warranty of        *
  17                      ;; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
  18                      ;; *  GNU General Public License for more details.                          *
  19                      ;; *                                                                        *
  20                      ;; *  You should have received a copy of the GNU General Public License     *
  21                      ;; *  along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  22                      ;; *                                                                        *
  23                      ;; *************************************************************************/
  24                     
  25                     
  26                     ;*****************************************************************************
  27                     ; EZ-Host/EZ-OTG device descriptor
  28                     ;*****************************************************************************
  29 1744                dev_desc:
  30 1744 12                   db 0x12       ; bLength
  31 1745 01                   db 0x01       ; bDescriptorType
  32 1746 0110                 dw USB_VER    ; bcdUSB
  33 1748 00                   db 0x00       ; bDeviceClass
  34 1749 00                   db 0x00       ; bDeviceSubClass
  35 174a 00                   db 0x00       ; bDeviceProtocol
  36 174b 40                   db 0x40       ; bMaxPacketSize0
  37 174c 08ec                 dw VENDOR_ID  ; idVendor
  38 174e 0020                 dw PRODUCT_ID ; idProduct
  39 1750 0001                 dw FW_REV     ; bcdDevice
  40 1752 01                   db 1          ; iManufacturer (index of manufacture string)
  41 1753 02                   db 2          ; iProduct (index of product string)
  42 1754 03                   db 3          ; iSerialNumber (index of serial number string)
  43 1755 01                   db 1          ; bNumConfigurations (number of configurations)
  44                     ;****************************************************************
  45                     ; EZ-Host/EZ-OTG configuration descriptor
  46                     ;****************************************************************
  47 1756                conf_desc:
  48           00000000  bLength             equ ($-conf_desc)
  49 1756 09                   db 9          ; len of config
  50           00000001  bDescriptorType     equ ($-conf_desc)
  51 1757 02                   db 2          ; type of config
  52           00000002  wTotalLength        equ ($-conf_desc)
  53 1758 0020                 dw (end_all-conf_desc)
  54           00000004  bNumInterfaces      equ ($-conf_desc)
  55 175a 01                   db 1          ; one interface
  56           00000005  bConfigurationValue equ ($-conf_desc)
  57 175b 01                   db 1          ; config #1
  58           00000006  iConfiguration      equ ($-conf_desc)
  59 175c 00                   db 0          ; index of string describing config
  60           00000007  bmAttributes        equ ($-conf_desc)
  61 175d 80                   db 0x80       ; attributes (self powered)
  62           00000008  MaxPower            equ ($-conf_desc)
  63 175e 32                   db 50
  64                     ;****************************************************************
  65                     ; Interface Descriptor
  66                     ;****************************************************************
  67 175f                interface_desc:
  68 175f 09                   db 9
  69 1760 04                   db 4
  70           00000002  bInterfaceNumber    equ ($-interface_desc)
  71 1761 00                   db 0          ; base #
  72           00000003  bAlternateSetting   equ ($-interface_desc)
  73 1762 00                   db 0          ; alt
  74           00000004  bNumEndpoints       equ ($-interface_desc)
  75 1763 02                   db 2          ; 2 endpoints
  76           00000005  bInterfaceClass     equ ($-interface_desc)
  77 1764 08                   db 0x08       ; interface class (Mass Storage)
  78           00000006  bInterfaceSubClass  equ ($-interface_desc)
  79 1765 06                   db 0x06       ; subclass (SCSI)
  80           00000007  bInterfaceProtocol  equ ($-interface_desc)
  81 1766 50                   db 0x50       ; interface proto (Bulk-Only Transport)
  82           00000008  iInterface          equ ($-interface_desc)
  83 1767 00                   db 0          ; index of string describing interface
  84           00000009  INTERFACE_DESC_LEN equ ($-interface_desc)
  85                     ;****************************************************************
  86                     ; EZ-Host/EZ-OTG endpoints descriptor
  87                     ;****************************************************************
  88                     ;; --------------------------------------------------
  89 1768 07             ep1:  db 0x07       ; len
  90 1769 05                   db 0x05       ; type (endpoint)
  91 176a 81                   db EP_IN_ADDR ; bEndpointAddress (EP 1 IN)
  92 176b 02                   db 0x02	    ; bmAttributes = Bulk
  93 176c 0040                 dw USB_PACKET_SIZE ; packet size = 64 bytes
  94 176e 00                   db EP_IN_BINTERVAL ; bInterval
  95                     ;; --------------------------------------------------
  96 176f 07             ep2:  db 0x07       ; len
  97 1770 05                   db 0x05       ; type (endpoint)
  98 1771 02                   db EP_OUT_ADDR ; bEndpointAddress (EP 2 OUT)
  99 1772 02                   db 0x02       ; bmAttributes = Bulk
 100 1773 0040                 dw USB_PACKET_SIZE ; packet size = 64 bytes
 101 1775 00                   db EP_OUT_BINTERVAL ; bInterval
 102                     ;; --------------------------------------------------
 103 1776                end_all:
 104           0000            align 2
 105                     ;================================================
 106                     ; String: Require the string must be align 2
 107                     ;================================================
 108                     ;;-----------------------------------------------
 109 1776                string_desc:
 110 1776 04                   db STR0_LEN
 111 1777 03                   db 3
 112 1778 0409                 dw 0x409     ; language id = English
 113           00000004  STR0_LEN equ ($-string_desc)
 114                     ;;-----------------------------------------------
 115 177a                str1:
 116 177a 12                   db STR1_LEN
 117 177b 03                   db 3
 118 177c 004c 006f 0070       dw 'Loper OS'
          0065 0072 0020 
          004f 0053 
 119           00000012  STR1_LEN equ ($-str1)
 120                     ;;-----------------------------------------------
 121 178c 14             str2: db STR2_LEN
 122 178d 03                   db 3
 123 178e 0053 0074 0069       dw 'Stierlitz'
          0065 0072 006c 
          0069 0074 007a 

 124           00000014  STR2_LEN equ ($-str2)
 125                     ;;-----------------------------------------------
 126 17a0 08             str3: db STR3_LEN
 127 17a1 03                   db 3
 128 17a2 0033 0030 0030       dw '300'
 129           00000008  STR3_LEN equ ($-str3)
 130                     ;;-----------------------------------------------
 131           0000            align 2

 143                     include fat16.asm

   0                      ;; /*************************************************************************
   1                      ;; *                     This file is part of Stierlitz:                    *
   2                      ;; *               https://github.com/asciilifeform/Stierlitz               *
   3                      ;; *************************************************************************/
   4                     
   5                      ;; /*************************************************************************
   6                      ;; *                (c) Copyright 2012 Stanislav Datskovskiy                *
   7                      ;; *                         http://www.loper-os.org                        *
   8                      ;; **************************************************************************
   9                      ;; *                                                                        *
  10                      ;; *  This program is free software: you can redistribute it and/or modify  *
  11                      ;; *  it under the terms of the GNU General Public License as published by  *
  12                      ;; *  the Free Software Foundation, either version 3 of the License, or     *
  13                      ;; *  (at your option) any later version.                                   *
  14                      ;; *                                                                        *
  15                      ;; *  This program is distributed in the hope that it will be useful,       *
  16                      ;; *  but WITHOUT ANY WARRANTY; without even the implied warranty of        *
  17                      ;; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
  18                      ;; *  GNU General Public License for more details.                          *
  19                      ;; *                                                                        *
  20                      ;; *  You should have received a copy of the GNU General Public License     *
  21                      ;; *  along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  22                      ;; *                                                                        *
  23                      ;; *************************************************************************/
  24                     
  25                     
  26                     ;*****************************************************************************
  27                     ;; Derived partition constants
  28                     ;*****************************************************************************
  29           00000000  MBR_BLOCK_LBA_UW			equ     0x0000
  30           00000000  MBR_BLOCK_LBA_LW			equ     0x0000
  31           00000000  FAT16_BOOT_BLOCK_LBA_UW			equ	PART0_START_LBA_UW
  32           0000003f  FAT16_BOOT_BLOCK_LBA_LW			equ	PART0_START_LBA_LW
  33           00000000  FAT16_FAT_TABLES_BLOCK_LBA_UW		equ	0x0000 ; Forget about upper word... Because QTASM is retarded.
  34           00000040  FAT16_FAT_TABLES_BLOCK_LBA_LW		equ	((FAT16_BOOT_BLOCK_LBA_LW) + 1)
  35           00000000  FAT16_FAT_TABLES_COPY_BLOCK_LBA_UW	equ     0x0000
  36           0000013f  FAT16_FAT_TABLES_COPY_BLOCK_LBA_LW	equ     (FAT16_FAT_TABLES_BLOCK_LBA_LW + FAT16_PART0_SECTORS_PER_FAT)
  37           00000000  FAT16_ROOT_DIRECTORY_ENTRY_LBA_UW	equ     0x0000
  38           0000023e  FAT16_ROOT_DIRECTORY_ENTRY_LBA_LW	equ     (FAT16_FAT_TABLES_BLOCK_LBA_LW + ((FAT16_PART0_SECTORS_PER_FAT) * 2))
  39                     
  40           00000000  FAT16_DATA_AREA_LBA_UW			equ	0x0000
  41           0000025e  FAT16_DATA_AREA_LBA_LW			equ	(FAT16_ROOT_DIRECTORY_ENTRY_LBA_LW + ((FAT16_PART0_MAX_ROOT_DIR_ENTRIES * 32) / BLOCKSIZE))
  42                     
  43                     ;; Now, this is because 64 blocks are taken up by Cluster 0 (reserved)
  44           00000000  FAT16_DATA_AREA_LBA_UW_EFFECTIVE_BOTTOM	equ	0x0000
  45           0000029e  FAT16_DATA_AREA_LBA_LW_EFFECTIVE_BOTTOM equ	(FAT16_DATA_AREA_LBA_LW + 64)
  46                     
  47           00000004  FIRST_CLUSTER_INDEX			equ	0x0004
  48                     ;*****************************************************************************
  49                     
  50                     
  51                     ;*****************************************************************************
  52                     ;; Partition Format
  53                     ;*****************************************************************************
  54           ffffaa55  BOOT_SIGNATURE				equ	0xaa55 ; for both boot block and MBA
  55                     ;; Partition Record in MBR
  56           00001966  PART0_MBR_RECORD_OFFSET			equ     (send_buffer + 0x01BE)
  57           000019a6  BOOT_SIGNATURE_OFFSET			equ	(send_buffer + 0x01fe)
  58           fffff6f6  FAT16_BOOT_BLOCK_FILLER			equ	0xf6f6  ; how MSDOS did it
  59                     ;*****************************************************************************
  60                     
  61                     
  62                     ;*****************************************************************************
  63                     ;; Partition Data (2GB - maximum for FAT16.)
  64                     ;*****************************************************************************
  65                     ;; Fields:
  66           00000000  PART0_STATUS				equ	  0x00 ;  0:  P0 status (0x00 = non-bootable, 0x80 = bootable)
  67           00000001  PART0_START_HEAD			equ	  0x01 ;  1: Start CHS: Head
  68           00000001  PART0_START_SECT_76CYLHIGH		equ	  0x01 ;  2: Start CHS: Sector in bits 5..0; bits 7..6 are high bits of Cylinder
  69           00000000  PART0_START_CYL				equ	  0x00 ;  3: Start CHS: Bits 7..0 of Cylinder
  70           0000000e  PART0_PARTITION_TYPE			equ	  0x0e ;  4: Partition Type
  71           0000007f  PART0_END_HEAD				equ	  0x7f ;  5: Ending CHS: Head
  72           000000bf  PART0_END_SECT_76CYLHIGH		equ	  0xbf ;  6: Ending CHS: Sector in bits 5..0; bits 7..6 are high bits of Cylinder
  73           00000005  PART0_END_CYL				equ	  0x05 ;  7: Ending CHS: Bits 7..0 of Cylinder
  74           00000000  PART0_START_LBA_UW			equ	0x0000 ; 11: Starting LBA: Upper Word
  75           0000003f  PART0_START_LBA_LW			equ	0x003f ;  8: Starting LBA: Lower Word
  76           0000003f  PART0_SECTORS_UW			equ	0x003f ; 14: Size in sectors
  77           ffffbcc1  PART0_SECTORS_LW			equ	0xbcc1 ; 12: Size in sectors
  78                     
  79                     ;; Our partition parameters
  80           00000200  FAT16_PART0_BYTES_PER_SECTOR		equ	0x0200 ; Bytes per sector
  81           00000040  FAT16_PART0_SECTORS_PER_CLUSTER		equ	  0x40 ; Sectors per cluster
  82           00000001  FAT16_PART0_RESERVED_SECTORS		equ	0x0001 ; Reserved sectors
  83           00000002  FAT16_PART0_COPIES_OF_FAT		equ	  0x02 ; # of copies of FAT
  84           00000200  FAT16_PART0_MAX_ROOT_DIR_ENTRIES	equ	0x0200 ; Max root dir entries
  85           00000000  FAT16_PART0_MAX_SECTS_IF_UNDR_32M	equ	0x0000 ; # of sectors in part < 32MB
  86           000000f8  FAT16_PART0_MEDIA_DESCRIPTOR		equ	  0xf8 ; media descriptor
  87           000000ff  FAT16_PART0_SECTORS_PER_FAT		equ	0x00FF ; sectors per FAT
  88           0000003f  FAT16_PART0_SECTORS_PER_TRACK		equ	0x003f ; sectors per track
  89           00000080  FAT16_PART0_HEADS			equ	0x0080 ; # of heads
  90           00000080  FAT16_PART0_LOGICAL_DRIVE_NUMBER	equ	0x0080 ; Logical drive number of partition
  91           00000029  FAT16_PART0_EXTENDED_SIGNATURE		equ	  0x29 ; Extended signature - must equal 0x29
  92           00004f30  FAT16_PART0_PARTITION_SERIAL_NUM_UW	equ	0x4f30 ; Serial number of partition (B1)
  93           00005f7b  FAT16_PART0_PARTITION_SERIAL_NUM_LW	equ	0x5f7b ; Serial number of partition (B0)
  94                     
  95                     ;*****************************************************************************

 144                     ;*****************************************************************************
 145                     ;; Buffers
 146           0000      align 2
 147                     
 148 17a8                send_buffer			dup 512
 149 19a8                receive_buffer			dup 512
 150 1ba8                block_receive_buffer		dup 512
 151                     ;*****************************************************************************
 152                     
 153                     ;*****************************************************************************
 154 1da8                rom_end:
 155 1da8 c3b6               dw     SCAN_SIGNATURE       ; signature 
 156 1daa 0002               dw	   2                    ; length
 157 1dac 05                 db     5                    ; jump opcode
 158 1dad 0500               dw     ORIGIN               ; Jump to BIOS Start in RAM
 159 1daf 00                 db 	   0                    ; end scan
 160                     ;*****************************************************************************
 161                     ;*****************************************************************************
 162                     ;*****************************************************************************
 163                     ;*****************************************************************************
Total Passes = 6
